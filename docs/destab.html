<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Replicating Table 1</title>

<script src="site_libs/header-attrs-2.14/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>
<script src="site_libs/kePrint-0.0.1/kePrint.js"></script>
<link href="site_libs/lightable-0.0.1/lightable.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="prep.html">Preparation</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Descriptives
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="des.html">Procedure</a>
    </li>
    <li>
      <a href="destab.html">Table 1: Descriptives</a>
    </li>
    <li>
      <a href="desfig.html">Figure 5: Development of the mean running</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Model selection
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="explore.html">Club 1</a>
    </li>
    <li>
      <a href="other.html">Clubs 2-5</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Meta-analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="meta.html">Running frequency models</a>
    </li>
    <li>
      <a href="vol_meta.html">Running volume models</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    GOF
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="GOF1.html">Running frequency models</a>
    </li>
    <li>
      <a href="GOF2.html">Running volume</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Influence effects
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="influenceeffects.html">Different influence operationalizations</a>
    </li>
    <li>
      <a href="interaction.html">Interaction effects for influence dynamics</a>
    </li>
    <li>
      <a href="figure3.html">Figure 6: Ego-alter influence plot</a>
    </li>
    <li>
      <a href="RI.html">Figure 7: Relative importance of effects</a>
    </li>
    <li>
      <a href="simulations.html">Empirically calibrated ABMs</a>
    </li>
    <li>
      <a href="moderation.html">Post-hoc probing of moderational effects</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/robfranken/Strava">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Replicating Table 1</h1>
<h4 class="date">Last compiled on september, 2022</h4>

</div>


<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('right', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
<hr />
<p>This script replicates Table 1 of the manuscript (Descriptive
statistics of Strava Clubs).</p>
<p><br></p>
<div id="getting-started" class="section level1">
<h1>Getting started</h1>
<div id="clean-up" class="section level2">
<h2>clean up</h2>
<pre class="r test"><code>rm (list = ls( ))</code></pre>
<p><br></p>
</div>
<div id="custom-functions" class="section level2">
<h2>custom functions</h2>
<ul>
<li><code>fpackage.check</code>: Check if packages are installed (and
install if not) in R (<a
href="https://vbaliga.github.io/verify-that-r-packages-are-installed-and-loaded/">source</a>)</li>
</ul>
<pre class="r test"><code>fpackage.check &lt;- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}</code></pre>
<p><br></p>
</div>
<div id="necessary-packages" class="section level2">
<h2>necessary packages</h2>
<p>We install and load the packages we need later on: -
<code>RSiena</code> - <code>igraph</code>: Descriptives (dyad/triad
census, degrees) - <code>dplyr</code>: for data manipulation -
<code>sna</code>: for network analysis - <code>knitr</code>: for
generating tables - <code>kableExtra</code>: for manipulating tables</p>
<pre class="r test"><code>packages = c(&quot;RSiena&quot;, &quot;igraph&quot;, &quot;dplyr&quot;, &quot;sna&quot;, &quot;knitr&quot;, &quot;kableExtra&quot;)
fpackage.check(packages)</code></pre>
</div>
<div id="additional-functions" class="section level2">
<h2>additional functions</h2>
<pre class="r test"><code># density: observed relations divided by possible relations
fdensity &lt;- function(x) {
    # x is your nomination network make sure diagonal cells are NA
    diag(x) &lt;- NA
    # take care of RSiena structural zeros, set as missing.
    x[x == 10] &lt;- NA
    sum(x == 1, na.rm = T)/(sum(x == 1 | x == 0, na.rm = T))
}

# calculate intragroup density
fdensityintra &lt;- function(x, A) {
    # A is matrix indicating whether nodes in dyad have same node attributes
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    diag(A) &lt;- NA
    sum(x == 1 &amp; A == 1, na.rm = T)/(sum((x == 1 | x == 0) &amp; A == 1, na.rm = T))
}

# calculate intragroup density
fdensityinter &lt;- function(x, A) {
    # A is matrix indicating whether nodes in dyad have same node attributes
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    diag(A) &lt;- NA
    sum(x == 1 &amp; A != 1, na.rm = T)/(sum((x == 1 | x == 0) &amp; A != 1, na.rm = T))
}

# construct dyad characteristic whether nodes are similar/homogenous
fhomomat &lt;- function(x) {
    # x is a vector of node-covariate
    xmat &lt;- matrix(x, nrow = length(x), ncol = length(x))
    xmatt &lt;- t(xmat)
    xhomo &lt;- xmat == xmatt
    return(xhomo)
}

# a function to calculate all valid dyads.
fndyads &lt;- function(x) {
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    (sum((x == 1 | x == 0), na.rm = T))
}

# a function to calculate all valid intragroupdyads.
fndyads2 &lt;- function(x, A) {
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    diag(A) &lt;- NA
    (sum((x == 1 | x == 0) &amp; A == 1, na.rm = T))
}


fscolnet &lt;- function(network, ccovar) {
    # Calculate coleman on network level:
    # https://reader.elsevier.com/reader/sd/pii/S0378873314000239?token=A42F99FF6E2B750436DD2CB0DB7B1F41BDEC16052A45683C02644DAF88215A3379636B2AA197B65941D6373E9E2EE413
    
    fhomomat &lt;- function(x) {
        xmat &lt;- matrix(x, nrow = length(x), ncol = length(x))
        xmatt &lt;- t(xmat)
        xhomo &lt;- xmat == xmatt
        return(xhomo)
    }
    
    fsumintra &lt;- function(x, A) {
        # A is matrix indicating whether nodes constituting dyad have same characteristics
        diag(x) &lt;- NA
        x[x == 10] &lt;- NA
        diag(A) &lt;- NA
        sum(x == 1 &amp; A == 1, na.rm = T)
    }
    
    # expecation w*=sum_g sum_i (ni((ng-1)/(N-1)))
    network[network == 10] &lt;- NA
    ni &lt;- rowSums(network, na.rm = T)
    ng &lt;- NA
    for (i in 1:length(ccovar)) {
        ng[i] &lt;- table(ccovar)[rownames(table(ccovar)) == ccovar[i]]
    }
    N &lt;- length(ccovar)
    wexp &lt;- sum(ni * ((ng - 1)/(N - 1)), na.rm = T)
    
    # wgg1 how many intragroup ties
    w &lt;- fsumintra(network, fhomomat(ccovar))
    
    Scol_net &lt;- ifelse(w &gt;= wexp, (w - wexp)/(sum(ni, na.rm = T) - wexp), (w - wexp)/wexp)
    return(Scol_net)
}

fMoran.I &lt;- function(x, weight, scaled = FALSE, na.rm = FALSE, alternative = &quot;two.sided&quot;, rowstandardize = TRUE) {
    if (rowstandardize) {
        if (dim(weight)[1] != dim(weight)[2]) 
            stop(&quot;&#39;weight&#39; must be a square matrix&quot;)
        n &lt;- length(x)
        if (dim(weight)[1] != n) 
            stop(&quot;&#39;weight&#39; must have as many rows as observations in &#39;x&#39;&quot;)
        ei &lt;- -1/(n - 1)
        nas &lt;- is.na(x)
        if (any(nas)) {
            if (na.rm) {
                x &lt;- x[!nas]
                n &lt;- length(x)
                weight &lt;- weight[!nas, !nas]
            } else {
                warning(&quot;&#39;x&#39; has missing values: maybe you wanted to set na.rm = TRUE?&quot;)
                return(list(observed = NA, expected = ei, sd = NA, p.value = NA))
            }
        }
        ROWSUM &lt;- rowSums(weight)
        ROWSUM[ROWSUM == 0] &lt;- 1
        weight &lt;- weight/ROWSUM
        s &lt;- sum(weight)
        m &lt;- mean(x)
        y &lt;- x - m
        cv &lt;- sum(weight * y %o% y)
        v &lt;- sum(y^2)
        obs &lt;- (n/s) * (cv/v)
        if (scaled) {
            i.max &lt;- (n/s) * (sd(rowSums(weight) * y)/sqrt(v/(n - 1)))
            obs &lt;- obs/i.max
        }
        S1 &lt;- 0.5 * sum((weight + t(weight))^2)
        S2 &lt;- sum((apply(weight, 1, sum) + apply(weight, 2, sum))^2)
        s.sq &lt;- s^2
        k &lt;- (sum(y^4)/n)/(v/n)^2
        sdi &lt;- sqrt((n * ((n^2 - 3 * n + 3) * S1 - n * S2 + 3 * s.sq) - k * (n * (n - 1) * S1 - 2 * n * 
            S2 + 6 * s.sq))/((n - 1) * (n - 2) * (n - 3) * s.sq) - 1/((n - 1)^2))
        alternative &lt;- match.arg(alternative, c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;))
        pv &lt;- pnorm(obs, mean = ei, sd = sdi)
        if (alternative == &quot;two.sided&quot;) 
            pv &lt;- if (obs &lt;= ei) 
                2 * pv else 2 * (1 - pv)
        if (alternative == &quot;greater&quot;) 
            pv &lt;- 1 - pv
        list(observed = obs, expected = ei, sd = sdi, p.value = pv)
    } else {
        if (dim(weight)[1] != dim(weight)[2]) 
            stop(&quot;&#39;weight&#39; must be a square matrix&quot;)
        n &lt;- length(x)
        if (dim(weight)[1] != n) 
            stop(&quot;&#39;weight&#39; must have as many rows as observations in &#39;x&#39;&quot;)
        ei &lt;- -1/(n - 1)
        nas &lt;- is.na(x)
        if (any(nas)) {
            if (na.rm) {
                x &lt;- x[!nas]
                n &lt;- length(x)
                weight &lt;- weight[!nas, !nas]
            } else {
                warning(&quot;&#39;x&#39; has missing values: maybe you wanted to set na.rm = TRUE?&quot;)
                return(list(observed = NA, expected = ei, sd = NA, p.value = NA))
            }
        }
        # ROWSUM &lt;- rowSums(weight) ROWSUM[ROWSUM == 0] &lt;- 1 weight &lt;- weight/ROWSUM
        s &lt;- sum(weight)
        m &lt;- mean(x)
        y &lt;- x - m
        cv &lt;- sum(weight * y %o% y)
        v &lt;- sum(y^2)
        obs &lt;- (n/s) * (cv/v)
        if (scaled) {
            i.max &lt;- (n/s) * (sd(rowSums(weight) * y)/sqrt(v/(n - 1)))
            obs &lt;- obs/i.max
        }
        S1 &lt;- 0.5 * sum((weight + t(weight))^2)
        S2 &lt;- sum((apply(weight, 1, sum) + apply(weight, 2, sum))^2)
        s.sq &lt;- s^2
        k &lt;- (sum(y^4)/n)/(v/n)^2
        sdi &lt;- sqrt((n * ((n^2 - 3 * n + 3) * S1 - n * S2 + 3 * s.sq) - k * (n * (n - 1) * S1 - 2 * n * 
            S2 + 6 * s.sq))/((n - 1) * (n - 2) * (n - 3) * s.sq) - 1/((n - 1)^2))
        alternative &lt;- match.arg(alternative, c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;))
        pv &lt;- pnorm(obs, mean = ei, sd = sdi)
        if (alternative == &quot;two.sided&quot;) 
            pv &lt;- if (obs &lt;= ei) 
                2 * pv else 2 * (1 - pv)
        if (alternative == &quot;greater&quot;) 
            pv &lt;- 1 - pv
        list(observed = obs, expected = ei, sd = sdi, p.value = pv)
    }
    
    
}</code></pre>
<p><br></p>
</div>
<div id="load-data-objects" class="section level2">
<h2>load data objects</h2>
<pre class="r test"><code># load the RSiena objects
load(&quot;clubdata_rsiena_freq.RData&quot;)
load(&quot;clubdata_rsiena_vol.RData&quot;)
load(&quot;clubdata.RData&quot;)</code></pre>
<hr />
<p><br></p>
</div>
</div>
<div id="descriptives-table" class="section level1">
<h1>Descriptives table</h1>
<p>Replicate the descriptives table:</p>
<pre class="r test"><code>tab &lt;- matrix(nrow=16, ncol=5)
rownames(tab) &lt;- c(&quot;Density&quot;, &quot;Average degree&quot;, &quot;Reciprocity index&quot;, &quot;Global transitivity index&quot;, &quot;Jaccard index&quot;, &quot;Gender segregation&quot;, &quot;Network autocorrelation&quot;, &quot;Direct ties&quot;, &quot;Frequency (per week)&quot;, &quot;Hours (per week)&quot;, &quot;Distance decay&quot;, &quot;Frequency (per week)&quot;, &quot;Hours (per week)&quot;, &quot;Weekly running frequency at t1&quot;, &quot;Weekly running hours at t1&quot;, &quot;Male sex (%)&quot; )
colnames(tab) &lt;- c(&quot;Club 1&quot;,&quot;Club 2&quot;, &quot;Club 3&quot;, &quot;Club 4&quot;, &quot;Club 5&quot;)

for (i in 1:5) { # for each club
  # densities over time
  densities &lt;- as.numeric(strsplit(substring(capture.output(clubdata_rsiena_freq[[i]])[12], 20), &quot; &quot;)[[1]])
  # mean (standard deviation)
  tab[1, i] &lt;- paste(as.character(round(mean(densities), 3)), &quot; (&quot;, as.character(round(sd(densities), 3)), &quot;)&quot;, sep=&quot;&quot;)
}


# Average degrees
for (i in 1:5) { # for each club
  # calculate average out-degree over time
  d &lt;- vector ()
  for (t in 1:12) {
    d[[t]] &lt;- mean(igraph::degree(igraph::graph_from_adjacency_matrix(clubdata_rsiena_freq[[i]]$depvars$kudonet[,,t]), mode = &quot;out&quot;))
    
  }
  # mean (standard deviation)
  tab[2, i] &lt;- paste(as.character(round(mean(d), 3)), &quot; (&quot;, as.character(round(sd(d), 3)), &quot;)&quot;, sep=&quot;&quot;)
}


# Reciprocity index
for (i in 1:5) { # for each club
  # calculate reciprocity index over time
  ri &lt;- vector ()
  
  for (t in 1:12) {
    mut &lt;- igraph::dyad.census(igraph::graph_from_adjacency_matrix(clubdata_rsiena_freq[[i]]$depvars$kudonet[,,t]))[[1]]
    nonmut &lt;- igraph::dyad.census(igraph::graph_from_adjacency_matrix(clubdata_rsiena_freq[[i]]$depvars$kudonet[,,t]))[[2]]
    ri[[t]] &lt;- mut/(mut+nonmut)
    
  }
  tab[3, i] &lt;- paste(as.character(round(mean(ri), 3)), &quot; (&quot;, as.character(round(sd(ri), 3)), &quot;)&quot;, sep=&quot;&quot;)
}

# Transitivity index
for (i in 1:5) { # for each club
  # calculate transitivity index over time
  ti &lt;- vector ()
  
  for (t in 1:12) {
    ti[[t]] &lt;- igraph::transitivity(igraph::graph_from_adjacency_matrix(clubdata_rsiena_freq[[i]]$depvars$kudonet[,,t]))
    
  }
  tab[4, i] &lt;- paste(as.character(round(mean(ti), 3)), &quot; (&quot;, as.character(round(sd(ti), 3)), &quot;)&quot;, sep=&quot;&quot;)
}

# Jaccard index

# Gender segregation 
for (i in 1:5) { # for each club
  # calculate coleman&#39;s homophily index over time
  col &lt;- vector ()
  
  for (t in 1:12) {
    col[[t]] &lt;- fscolnet(clubdata_rsiena_freq[[i]]$depvars$kudonet[,,t], clubdata_rsiena_freq[[i]]$cCovars$gender)
  }
  tab[6, i] &lt;- paste(as.character(round(mean(col), 3)), &quot; (&quot;, as.character(round(sd(col), 3)), &quot;)&quot;, sep=&quot;&quot;)
}

# Network autocorrelation
# frequency
for (i in 1:5) { # for each club
  # we calculate moran&#39;s i
  # both with direct ties and indirect ties as well
  # for frequency and volume
  mor_freq_dir &lt;- vector ()
  mor_freq_dist &lt;- vector ()
  mor_vol_dir &lt;- vector ()
  mor_vol_dist &lt;- vector ()
  
  for (t in 1:12) {         
    freq &lt;- clubdata[[i]]$freq_run[,,t]   # attributes at time t
    vol &lt;- clubdata[[i]]$time_run[,,t]   
    knet &lt;- network::as.network(clubdata_rsiena_freq[[i]]$depvars$kudonet[,,t]) # net a time t
    geodistances &lt;- sna::geodist(knet, count.paths=T) # geodesic distance
    geodistances &lt;- geodistances$gdist 
    diag(geodistances) &lt;- Inf
    weights1 &lt;- geodistances == 1               # only direct ties
    weights2 &lt;- exp(-geodistances)              # also indirect
    
    mor_freq_dir[[t]] &lt;- fMoran.I(freq, scaled = FALSE, # calculate moran on direct
                                  weight = weights1, 
                                  na.rm = TRUE, 
                                  rowstandardize = FALSE)[[1]] 
    mor_freq_dist[[t]] &lt;- fMoran.I(freq, scaled = FALSE, # and indirect
                                   weight = weights2, 
                                   na.rm = TRUE, 
                                   rowstandardize = FALSE)[[1]]
    mor_vol_dir[[t]] &lt;- fMoran.I(vol, scaled = FALSE, # calculate moran on direct
                                 weight = weights1, 
                                 na.rm = TRUE, 
                                 rowstandardize = FALSE)[[1]] 
    mor_vol_dist[[t]] &lt;- fMoran.I(vol, scaled = FALSE, # and indirect
                                  weight = weights2, 
                                  na.rm = TRUE, 
                                  rowstandardize = FALSE)[[1]]
  }
  tab[9, i] &lt;- paste(as.character(round(mean(mor_freq_dir), 3)), &quot; (&quot;, as.character(round(sd(mor_freq_dir), 3)), &quot;)&quot;, sep=&quot;&quot;)
  tab[10, i] &lt;- paste(as.character(round(mean(mor_vol_dir), 3)), &quot; (&quot;, as.character(round(sd(mor_vol_dir), 3)), &quot;)&quot;, sep=&quot;&quot;)
  tab[12, i] &lt;- paste(as.character(round(mean(mor_freq_dist), 3)), &quot; (&quot;, as.character(round(sd(mor_freq_dist), 3)), &quot;)&quot;, sep=&quot;&quot;)
  tab[13, i] &lt;- paste(as.character(round(mean(mor_vol_dist), 3)), &quot; (&quot;, as.character(round(sd(mor_vol_dist), 3)), &quot;)&quot;, sep=&quot;&quot;)
}

# behavior at baseline (w1)
for (i in 1:5) { # for each club
  # running attributes at w1
  tab[14, i] &lt;- paste(as.character(round(mean(clubdata[[i]]$freq_run[,,1], na.rm=T), 3)), &quot; (&quot;, as.character(round(sd(clubdata[[i]]$freq_run[,,1], na.rm=T), 3)), &quot;)&quot;, sep=&quot;&quot;)
  tab[15, i] &lt;- paste(as.character(round(mean(clubdata[[i]]$time_run[,,1], na.rm=T), 3)), &quot; (&quot;, as.character(round(sd(clubdata[[i]]$time_run[,,1], na.rm=T), 3)), &quot;)&quot;, sep=&quot;&quot;)
}
# male sex (%)
for (i in 1:5) { # for each club
  # percentage male
  tab[16, i] &lt;- round((length(clubdata[[i]][clubdata[[i]]$male==1])/clubdata[[i]]$netsize)*100, 3)
}

# for now we include jaccard manually; but we want to use a function to calculate these ideally.
tab[5, ] &lt;- c(&quot;0.850 (0.060)&quot;, &quot;0.75 (0.030)&quot;, &quot;0.500 (0.060)&quot;, &quot;0.800 (0.090)&quot;, &quot;0.690 (0.020)&quot;)</code></pre>
<p><b></p>
</div>
<div id="table" class="section level1">
<h1>Table</h1>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;border-bottom: 0;">
<caption>
Table 1. Descriptive statistics of Strava clubs
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:left;">
Club 1
</th>
<th style="text-align:left;">
Club 2
</th>
<th style="text-align:left;">
Club 3
</th>
<th style="text-align:left;">
Club 4
</th>
<th style="text-align:left;">
Club 5
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Density
</td>
<td style="text-align:left;">
0.083 (0.014)
</td>
<td style="text-align:left;">
0.168 (0.014)
</td>
<td style="text-align:left;">
0.011 (0.002)
</td>
<td style="text-align:left;">
0.115 (0.018)
</td>
<td style="text-align:left;">
0.098 (0.013)
</td>
</tr>
<tr>
<td style="text-align:left;">
Average degree
</td>
<td style="text-align:left;">
2.392 (0.408)
</td>
<td style="text-align:left;">
10.156 (0.838)
</td>
<td style="text-align:left;">
1.787 (0.28)
</td>
<td style="text-align:left;">
1.385 (0.205)
</td>
<td style="text-align:left;">
7.418 (0.994)
</td>
</tr>
<tr>
<td style="text-align:left;">
Reciprocity index
</td>
<td style="text-align:left;">
0.803 (0.06)
</td>
<td style="text-align:left;">
0.634 (0.036)
</td>
<td style="text-align:left;">
0.386 (0.062)
</td>
<td style="text-align:left;">
0.72 (0.129)
</td>
<td style="text-align:left;">
0.607 (0.03)
</td>
</tr>
<tr>
<td style="text-align:left;">
Global transitivity index
</td>
<td style="text-align:left;">
0.581 (0.035)
</td>
<td style="text-align:left;">
0.544 (0.016)
</td>
<td style="text-align:left;">
0.276 (0.076)
</td>
<td style="text-align:left;">
0.735 (0.143)
</td>
<td style="text-align:left;">
0.526 (0.018)
</td>
</tr>
<tr>
<td style="text-align:left;">
Jaccard index
</td>
<td style="text-align:left;">
0.850 (0.060)
</td>
<td style="text-align:left;">
0.75 (0.030)
</td>
<td style="text-align:left;">
0.500 (0.060)
</td>
<td style="text-align:left;">
0.800 (0.090)
</td>
<td style="text-align:left;">
0.690 (0.020)
</td>
</tr>
<tr>
<td style="text-align:left;">
Gender segregation
</td>
<td style="text-align:left;">
0.235 (0.109)
</td>
<td style="text-align:left;">
0.294 (0.038)
</td>
<td style="text-align:left;">
0.093 (0.064)
</td>
<td style="text-align:left;">
-0.139 (0.12)
</td>
<td style="text-align:left;">
0.015 (0.034)
</td>
</tr>
<tr>
<td style="text-align:left;">
Network autocorrelation
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
</tr>
<tr>
<td style="text-align:left;">
Direct ties
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
</tr>
<tr>
<td style="text-align:left;">
Frequency (per week)
</td>
<td style="text-align:left;">
0.173 (0.169)
</td>
<td style="text-align:left;">
0.217 (0.081)
</td>
<td style="text-align:left;">
0.203 (0.069)
</td>
<td style="text-align:left;">
0.296 (0.264)
</td>
<td style="text-align:left;">
0.276 (0.04)
</td>
</tr>
<tr>
<td style="text-align:left;">
Hours (per week)
</td>
<td style="text-align:left;">
0.207 (0.151)
</td>
<td style="text-align:left;">
0.197 (0.099)
</td>
<td style="text-align:left;">
0.244 (0.065)
</td>
<td style="text-align:left;">
0.243 (0.302)
</td>
<td style="text-align:left;">
0.324 (0.054)
</td>
</tr>
<tr>
<td style="text-align:left;">
Distance decay
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
</tr>
<tr>
<td style="text-align:left;">
Frequency (per week)
</td>
<td style="text-align:left;">
0.108 (0.117)
</td>
<td style="text-align:left;">
0.112 (0.036)
</td>
<td style="text-align:left;">
0.141 (0.061)
</td>
<td style="text-align:left;">
0.311 (0.254)
</td>
<td style="text-align:left;">
0.157 (0.022)
</td>
</tr>
<tr>
<td style="text-align:left;">
Hours (per week)
</td>
<td style="text-align:left;">
0.138 (0.101)
</td>
<td style="text-align:left;">
0.107 (0.043)
</td>
<td style="text-align:left;">
0.161 (0.04)
</td>
<td style="text-align:left;">
0.275 (0.276)
</td>
<td style="text-align:left;">
0.18 (0.028)
</td>
</tr>
<tr>
<td style="text-align:left;">
Weekly running frequency at t1
</td>
<td style="text-align:left;">
2.033 (1.351)
</td>
<td style="text-align:left;">
3 (2.15)
</td>
<td style="text-align:left;">
1.885 (1.658)
</td>
<td style="text-align:left;">
1.385 (1.502)
</td>
<td style="text-align:left;">
3.208 (2.313)
</td>
</tr>
<tr>
<td style="text-align:left;">
Weekly running hours at t1
</td>
<td style="text-align:left;">
2.1 (1.561)
</td>
<td style="text-align:left;">
2.952 (2.161)
</td>
<td style="text-align:left;">
1.915 (1.726)
</td>
<td style="text-align:left;">
1.538 (1.613)
</td>
<td style="text-align:left;">
3.143 (2.475)
</td>
</tr>
<tr>
<td style="text-align:left;">
Male sex (%)
</td>
<td style="text-align:left;">
56.667
</td>
<td style="text-align:left;">
70.968
</td>
<td style="text-align:left;">
70.909
</td>
<td style="text-align:left;">
61.538
</td>
<td style="text-align:left;">
67.532
</td>
</tr>
</tbody>
<tfoot>
<tr>
<td style="padding: 0; " colspan="100%">
<span style="font-style: italic;">Note: </span>
</td>
</tr>
<tr>
<td style="padding: 0; " colspan="100%">
<sup></sup> For network measures, mean values over time are given with
standard deviations in parentheses. For behavioral attributes, means and
standard deviations at baseline (t1: December) are given. Degrees
reflect kudos ties, with awarding 1 or more kudos constituting the
presence of a tie. The reciprocity index is the proportion of kudos ties
that were reciprocated; the transitivity index is the number of closed
triplets over the total number of triplets (both open and closed).
</td>
</tr>
<tr>
<td style="padding: 0; " colspan="100%">
<sup>a</sup> The Jaccard similarity index measures the extent of tie
change between consecutive waves
</td>
</tr>
<tr>
<td style="padding: 0; " colspan="100%">
<sup>b</sup> The gender segregation measure used is Coleman’s homophily
index.
</td>
</tr>
<tr>
<td style="padding: 0; " colspan="100%">
<sup>c</sup> The network autocorrelation measure used is Moran’s I. We
calculated Moran’s I for direct ties (i.e. with undirected path length
1) and for all ties to whom ego is (directly or indirectly) tied, using
a distance-decay function for assigning weights. To construct the weight
matrix, we measured the geodistance (d) for each dyad as the shortest
(undirected) path length. We then used the negative exponential
distance-decay function. We did not row-standardize.
</td>
</tr>
</tfoot>
</table>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIlJlcGxpY2F0aW5nIFRhYmxlIDEiDQpkYXRlOiAiTGFzdCBjb21waWxlZCBvbiBgciBmb3JtYXQoU3lzLnRpbWUoKSwgJyVCLCAlWScpYCINCmJpYmxpb2dyYXBoeTogcmVmZXJlbmNlcy5iaWINCm91dHB1dDoNCiAgaHRtbF9kb2N1bWVudDoNCiAgICBjc3M6IHR3ZWFrcy5jc3MNCiAgICB0b2M6IHRydWUNCiAgICB0b2NfZmxvYXQ6IHRydWUNCiAgICBjb2xsYXBzZWQ6IGZhbHNlDQogICAgbnVtYmVyX3NlY3Rpb25zOiBmYWxzZQ0KICAgIHRvY19kZXB0aDogMQ0KICAgIGNvZGVfZm9sZGluZzogc2hvdw0KICAgIGNvZGVfZG93bmxvYWQ6IHllcw0KLS0tDQoNCg0KYGBge3IsIGdsb2JhbHNldHRpbmdzLCBlY2hvPUZBTFNFLCB3YXJuaW5nPUZBTFNFLCByZXN1bHRzPSdoaWRlJ30NCg0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KGVjaG8gPSBUUlVFKQ0Kb3B0c19jaHVuayRzZXQodGlkeS5vcHRzPWxpc3Qod2lkdGguY3V0b2ZmPTEwMCksdGlkeT1UUlVFLCB3YXJuaW5nID0gRkFMU0UsIG1lc3NhZ2UgPSBGQUxTRSxjb21tZW50ID0gIiM+IiwgY2FjaGU9VFJVRSwgY2xhc3Muc291cmNlPWMoInRlc3QiKSwgY2xhc3Mub3V0cHV0PWMoInRlc3QyIikpDQpvcHRpb25zKHdpZHRoID0gMTAwKQ0KcmdsOjpzZXR1cEtuaXRyKCkNCg0KDQoNCmNvbG9yaXplIDwtIGZ1bmN0aW9uKHgsIGNvbG9yKSB7c3ByaW50ZigiPHNwYW4gc3R5bGU9J2NvbG9yOiAlczsnPiVzPC9zcGFuPiIsIGNvbG9yLCB4KSB9DQoNCmBgYA0KDQpgYGB7ciBrbGlwcHksIGVjaG89RkFMU0UsIGluY2x1ZGU9VFJVRX0NCmtsaXBweTo6a2xpcHB5KHBvc2l0aW9uID0gYygndG9wJywgJ3JpZ2h0JykpDQoja2xpcHB5OjprbGlwcHkoY29sb3IgPSAnZGFya3JlZCcpDQoja2xpcHB5OjprbGlwcHkodG9vbHRpcF9tZXNzYWdlID0gJ0NsaWNrIHRvIGNvcHknLCB0b29sdGlwX3N1Y2Nlc3MgPSAnRG9uZScpDQpgYGANCg0KDQoNCi0tLQ0KDQpUaGlzIHNjcmlwdCByZXBsaWNhdGVzIFRhYmxlIDEgb2YgdGhlIG1hbnVzY3JpcHQgKERlc2NyaXB0aXZlIHN0YXRpc3RpY3Mgb2YgU3RyYXZhIENsdWJzKS4NCg0KPGJyPg0KDQoNCiMgR2V0dGluZyBzdGFydGVkDQoNCiMjIGNsZWFuIHVwDQoNCmBgYHtyLCBhdHRyLm91dHB1dD0nc3R5bGU9Im1heC1oZWlnaHQ6IDIwMHB4OyInfQ0Kcm0gKGxpc3QgPSBscyggKSkNCmBgYA0KDQo8YnI+IA0KDQojIyBjdXN0b20gZnVuY3Rpb25zDQoNCi0gYGZwYWNrYWdlLmNoZWNrYDogQ2hlY2sgaWYgcGFja2FnZXMgYXJlIGluc3RhbGxlZCAoYW5kIGluc3RhbGwgaWYgbm90KSBpbiBSIChbc291cmNlXShodHRwczovL3ZiYWxpZ2EuZ2l0aHViLmlvL3ZlcmlmeS10aGF0LXItcGFja2FnZXMtYXJlLWluc3RhbGxlZC1hbmQtbG9hZGVkLykpDQoNCmBgYHtyLCByZXN1bHRzPSdoaWRlJ30NCg0KZnBhY2thZ2UuY2hlY2sgPC0gZnVuY3Rpb24ocGFja2FnZXMpIHsNCiAgICBsYXBwbHkocGFja2FnZXMsIEZVTiA9IGZ1bmN0aW9uKHgpIHsNCiAgICAgICAgaWYgKCFyZXF1aXJlKHgsIGNoYXJhY3Rlci5vbmx5ID0gVFJVRSkpIHsNCiAgICAgICAgICAgIGluc3RhbGwucGFja2FnZXMoeCwgZGVwZW5kZW5jaWVzID0gVFJVRSkNCiAgICAgICAgICAgIGxpYnJhcnkoeCwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKQ0KICAgICAgICB9DQogICAgfSkNCn0NCmBgYA0KDQo8YnI+DQoNCg0KIyMgbmVjZXNzYXJ5IHBhY2thZ2VzDQoNCldlIGluc3RhbGwgYW5kIGxvYWQgdGhlIHBhY2thZ2VzIHdlIG5lZWQgbGF0ZXIgb246DQotIGBSU2llbmFgDQotIGBpZ3JhcGhgOiBEZXNjcmlwdGl2ZXMgKGR5YWQvdHJpYWQgY2Vuc3VzLCBkZWdyZWVzKQ0KLSBgZHBseXJgOiBmb3IgZGF0YSBtYW5pcHVsYXRpb24NCi0gYHNuYWA6IGZvciBuZXR3b3JrIGFuYWx5c2lzDQotIGBrbml0cmA6IGZvciBnZW5lcmF0aW5nIHRhYmxlcw0KLSBga2FibGVFeHRyYWA6IGZvciBtYW5pcHVsYXRpbmcgdGFibGVzDQoNCmBgYHtyIHBhY2thZ2VzLCByZXN1bHRzPSdoaWRlJ30NCnBhY2thZ2VzID0gYygiUlNpZW5hIiwgImlncmFwaCIsICJkcGx5ciIsICJzbmEiLCAia25pdHIiLCAia2FibGVFeHRyYSIpDQpmcGFja2FnZS5jaGVjayhwYWNrYWdlcykNCmBgYA0KIyMgYWRkaXRpb25hbCBmdW5jdGlvbnMgDQoNCmBgYHtyIGV2YWw9VH0NCiMgZGVuc2l0eTogb2JzZXJ2ZWQgcmVsYXRpb25zIGRpdmlkZWQgYnkgcG9zc2libGUgcmVsYXRpb25zDQpmZGVuc2l0eSA8LSBmdW5jdGlvbih4KSB7DQogICAgIyB4IGlzIHlvdXIgbm9taW5hdGlvbiBuZXR3b3JrIG1ha2Ugc3VyZSBkaWFnb25hbCBjZWxscyBhcmUgTkENCiAgICBkaWFnKHgpIDwtIE5BDQogICAgIyB0YWtlIGNhcmUgb2YgUlNpZW5hIHN0cnVjdHVyYWwgemVyb3MsIHNldCBhcyBtaXNzaW5nLg0KICAgIHhbeCA9PSAxMF0gPC0gTkENCiAgICBzdW0oeCA9PSAxLCBuYS5ybSA9IFQpLyhzdW0oeCA9PSAxIHwgeCA9PSAwLCBuYS5ybSA9IFQpKQ0KfQ0KDQojIGNhbGN1bGF0ZSBpbnRyYWdyb3VwIGRlbnNpdHkNCmZkZW5zaXR5aW50cmEgPC0gZnVuY3Rpb24oeCwgQSkgew0KICAgICMgQSBpcyBtYXRyaXggaW5kaWNhdGluZyB3aGV0aGVyIG5vZGVzIGluIGR5YWQgaGF2ZSBzYW1lIG5vZGUgYXR0cmlidXRlcw0KICAgIGRpYWcoeCkgPC0gTkENCiAgICB4W3ggPT0gMTBdIDwtIE5BDQogICAgZGlhZyhBKSA8LSBOQQ0KICAgIHN1bSh4ID09IDEgJiBBID09IDEsIG5hLnJtID0gVCkvKHN1bSgoeCA9PSAxIHwgeCA9PSAwKSAmIEEgPT0gMSwgbmEucm0gPSBUKSkNCn0NCg0KIyBjYWxjdWxhdGUgaW50cmFncm91cCBkZW5zaXR5DQpmZGVuc2l0eWludGVyIDwtIGZ1bmN0aW9uKHgsIEEpIHsNCiAgICAjIEEgaXMgbWF0cml4IGluZGljYXRpbmcgd2hldGhlciBub2RlcyBpbiBkeWFkIGhhdmUgc2FtZSBub2RlIGF0dHJpYnV0ZXMNCiAgICBkaWFnKHgpIDwtIE5BDQogICAgeFt4ID09IDEwXSA8LSBOQQ0KICAgIGRpYWcoQSkgPC0gTkENCiAgICBzdW0oeCA9PSAxICYgQSAhPSAxLCBuYS5ybSA9IFQpLyhzdW0oKHggPT0gMSB8IHggPT0gMCkgJiBBICE9IDEsIG5hLnJtID0gVCkpDQp9DQoNCiMgY29uc3RydWN0IGR5YWQgY2hhcmFjdGVyaXN0aWMgd2hldGhlciBub2RlcyBhcmUgc2ltaWxhci9ob21vZ2Vub3VzDQpmaG9tb21hdCA8LSBmdW5jdGlvbih4KSB7DQogICAgIyB4IGlzIGEgdmVjdG9yIG9mIG5vZGUtY292YXJpYXRlDQogICAgeG1hdCA8LSBtYXRyaXgoeCwgbnJvdyA9IGxlbmd0aCh4KSwgbmNvbCA9IGxlbmd0aCh4KSkNCiAgICB4bWF0dCA8LSB0KHhtYXQpDQogICAgeGhvbW8gPC0geG1hdCA9PSB4bWF0dA0KICAgIHJldHVybih4aG9tbykNCn0NCg0KIyBhIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBhbGwgdmFsaWQgZHlhZHMuDQpmbmR5YWRzIDwtIGZ1bmN0aW9uKHgpIHsNCiAgICBkaWFnKHgpIDwtIE5BDQogICAgeFt4ID09IDEwXSA8LSBOQQ0KICAgIChzdW0oKHggPT0gMSB8IHggPT0gMCksIG5hLnJtID0gVCkpDQp9DQoNCiMgYSBmdW5jdGlvbiB0byBjYWxjdWxhdGUgYWxsIHZhbGlkIGludHJhZ3JvdXBkeWFkcy4NCmZuZHlhZHMyIDwtIGZ1bmN0aW9uKHgsIEEpIHsNCiAgICBkaWFnKHgpIDwtIE5BDQogICAgeFt4ID09IDEwXSA8LSBOQQ0KICAgIGRpYWcoQSkgPC0gTkENCiAgICAoc3VtKCh4ID09IDEgfCB4ID09IDApICYgQSA9PSAxLCBuYS5ybSA9IFQpKQ0KfQ0KDQoNCmZzY29sbmV0IDwtIGZ1bmN0aW9uKG5ldHdvcmssIGNjb3Zhcikgew0KICAgICMgQ2FsY3VsYXRlIGNvbGVtYW4gb24gbmV0d29yayBsZXZlbDoNCiAgICAjIGh0dHBzOi8vcmVhZGVyLmVsc2V2aWVyLmNvbS9yZWFkZXIvc2QvcGlpL1MwMzc4ODczMzE0MDAwMjM5P3Rva2VuPUE0MkY5OUZGNkUyQjc1MDQzNkREMkNCMERCN0IxRjQxQkRFQzE2MDUyQTQ1NjgzQzAyNjQ0REFGODgyMTVBMzM3OTYzNkIyQUExOTdCNjU5NDFENjM3M0U5RTJFRTQxMw0KICAgIA0KICAgIGZob21vbWF0IDwtIGZ1bmN0aW9uKHgpIHsNCiAgICAgICAgeG1hdCA8LSBtYXRyaXgoeCwgbnJvdyA9IGxlbmd0aCh4KSwgbmNvbCA9IGxlbmd0aCh4KSkNCiAgICAgICAgeG1hdHQgPC0gdCh4bWF0KQ0KICAgICAgICB4aG9tbyA8LSB4bWF0ID09IHhtYXR0DQogICAgICAgIHJldHVybih4aG9tbykNCiAgICB9DQogICAgDQogICAgZnN1bWludHJhIDwtIGZ1bmN0aW9uKHgsIEEpIHsNCiAgICAgICAgIyBBIGlzIG1hdHJpeCBpbmRpY2F0aW5nIHdoZXRoZXIgbm9kZXMgY29uc3RpdHV0aW5nIGR5YWQgaGF2ZSBzYW1lIGNoYXJhY3RlcmlzdGljcw0KICAgICAgICBkaWFnKHgpIDwtIE5BDQogICAgICAgIHhbeCA9PSAxMF0gPC0gTkENCiAgICAgICAgZGlhZyhBKSA8LSBOQQ0KICAgICAgICBzdW0oeCA9PSAxICYgQSA9PSAxLCBuYS5ybSA9IFQpDQogICAgfQ0KICAgIA0KICAgICMgZXhwZWNhdGlvbiB3Kj1zdW1fZyBzdW1faSAobmkoKG5nLTEpLyhOLTEpKSkNCiAgICBuZXR3b3JrW25ldHdvcmsgPT0gMTBdIDwtIE5BDQogICAgbmkgPC0gcm93U3VtcyhuZXR3b3JrLCBuYS5ybSA9IFQpDQogICAgbmcgPC0gTkENCiAgICBmb3IgKGkgaW4gMTpsZW5ndGgoY2NvdmFyKSkgew0KICAgICAgICBuZ1tpXSA8LSB0YWJsZShjY292YXIpW3Jvd25hbWVzKHRhYmxlKGNjb3ZhcikpID09IGNjb3ZhcltpXV0NCiAgICB9DQogICAgTiA8LSBsZW5ndGgoY2NvdmFyKQ0KICAgIHdleHAgPC0gc3VtKG5pICogKChuZyAtIDEpLyhOIC0gMSkpLCBuYS5ybSA9IFQpDQogICAgDQogICAgIyB3Z2cxIGhvdyBtYW55IGludHJhZ3JvdXAgdGllcw0KICAgIHcgPC0gZnN1bWludHJhKG5ldHdvcmssIGZob21vbWF0KGNjb3ZhcikpDQogICAgDQogICAgU2NvbF9uZXQgPC0gaWZlbHNlKHcgPj0gd2V4cCwgKHcgLSB3ZXhwKS8oc3VtKG5pLCBuYS5ybSA9IFQpIC0gd2V4cCksICh3IC0gd2V4cCkvd2V4cCkNCiAgICByZXR1cm4oU2NvbF9uZXQpDQp9DQoNCmZNb3Jhbi5JIDwtIGZ1bmN0aW9uKHgsIHdlaWdodCwgc2NhbGVkID0gRkFMU0UsIG5hLnJtID0gRkFMU0UsIGFsdGVybmF0aXZlID0gInR3by5zaWRlZCIsIHJvd3N0YW5kYXJkaXplID0gVFJVRSkgew0KICAgIGlmIChyb3dzdGFuZGFyZGl6ZSkgew0KICAgICAgICBpZiAoZGltKHdlaWdodClbMV0gIT0gZGltKHdlaWdodClbMl0pIA0KICAgICAgICAgICAgc3RvcCgiJ3dlaWdodCcgbXVzdCBiZSBhIHNxdWFyZSBtYXRyaXgiKQ0KICAgICAgICBuIDwtIGxlbmd0aCh4KQ0KICAgICAgICBpZiAoZGltKHdlaWdodClbMV0gIT0gbikgDQogICAgICAgICAgICBzdG9wKCInd2VpZ2h0JyBtdXN0IGhhdmUgYXMgbWFueSByb3dzIGFzIG9ic2VydmF0aW9ucyBpbiAneCciKQ0KICAgICAgICBlaSA8LSAtMS8obiAtIDEpDQogICAgICAgIG5hcyA8LSBpcy5uYSh4KQ0KICAgICAgICBpZiAoYW55KG5hcykpIHsNCiAgICAgICAgICAgIGlmIChuYS5ybSkgew0KICAgICAgICAgICAgICAgIHggPC0geFshbmFzXQ0KICAgICAgICAgICAgICAgIG4gPC0gbGVuZ3RoKHgpDQogICAgICAgICAgICAgICAgd2VpZ2h0IDwtIHdlaWdodFshbmFzLCAhbmFzXQ0KICAgICAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICAgICAgICB3YXJuaW5nKCIneCcgaGFzIG1pc3NpbmcgdmFsdWVzOiBtYXliZSB5b3Ugd2FudGVkIHRvIHNldCBuYS5ybSA9IFRSVUU/IikNCiAgICAgICAgICAgICAgICByZXR1cm4obGlzdChvYnNlcnZlZCA9IE5BLCBleHBlY3RlZCA9IGVpLCBzZCA9IE5BLCBwLnZhbHVlID0gTkEpKQ0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIFJPV1NVTSA8LSByb3dTdW1zKHdlaWdodCkNCiAgICAgICAgUk9XU1VNW1JPV1NVTSA9PSAwXSA8LSAxDQogICAgICAgIHdlaWdodCA8LSB3ZWlnaHQvUk9XU1VNDQogICAgICAgIHMgPC0gc3VtKHdlaWdodCkNCiAgICAgICAgbSA8LSBtZWFuKHgpDQogICAgICAgIHkgPC0geCAtIG0NCiAgICAgICAgY3YgPC0gc3VtKHdlaWdodCAqIHkgJW8lIHkpDQogICAgICAgIHYgPC0gc3VtKHleMikNCiAgICAgICAgb2JzIDwtIChuL3MpICogKGN2L3YpDQogICAgICAgIGlmIChzY2FsZWQpIHsNCiAgICAgICAgICAgIGkubWF4IDwtIChuL3MpICogKHNkKHJvd1N1bXMod2VpZ2h0KSAqIHkpL3NxcnQodi8obiAtIDEpKSkNCiAgICAgICAgICAgIG9icyA8LSBvYnMvaS5tYXgNCiAgICAgICAgfQ0KICAgICAgICBTMSA8LSAwLjUgKiBzdW0oKHdlaWdodCArIHQod2VpZ2h0KSleMikNCiAgICAgICAgUzIgPC0gc3VtKChhcHBseSh3ZWlnaHQsIDEsIHN1bSkgKyBhcHBseSh3ZWlnaHQsIDIsIHN1bSkpXjIpDQogICAgICAgIHMuc3EgPC0gc14yDQogICAgICAgIGsgPC0gKHN1bSh5XjQpL24pLyh2L24pXjINCiAgICAgICAgc2RpIDwtIHNxcnQoKG4gKiAoKG5eMiAtIDMgKiBuICsgMykgKiBTMSAtIG4gKiBTMiArIDMgKiBzLnNxKSAtIGsgKiAobiAqIChuIC0gMSkgKiBTMSAtIDIgKiBuICogDQogICAgICAgICAgICBTMiArIDYgKiBzLnNxKSkvKChuIC0gMSkgKiAobiAtIDIpICogKG4gLSAzKSAqIHMuc3EpIC0gMS8oKG4gLSAxKV4yKSkNCiAgICAgICAgYWx0ZXJuYXRpdmUgPC0gbWF0Y2guYXJnKGFsdGVybmF0aXZlLCBjKCJ0d28uc2lkZWQiLCAibGVzcyIsICJncmVhdGVyIikpDQogICAgICAgIHB2IDwtIHBub3JtKG9icywgbWVhbiA9IGVpLCBzZCA9IHNkaSkNCiAgICAgICAgaWYgKGFsdGVybmF0aXZlID09ICJ0d28uc2lkZWQiKSANCiAgICAgICAgICAgIHB2IDwtIGlmIChvYnMgPD0gZWkpIA0KICAgICAgICAgICAgICAgIDIgKiBwdiBlbHNlIDIgKiAoMSAtIHB2KQ0KICAgICAgICBpZiAoYWx0ZXJuYXRpdmUgPT0gImdyZWF0ZXIiKSANCiAgICAgICAgICAgIHB2IDwtIDEgLSBwdg0KICAgICAgICBsaXN0KG9ic2VydmVkID0gb2JzLCBleHBlY3RlZCA9IGVpLCBzZCA9IHNkaSwgcC52YWx1ZSA9IHB2KQ0KICAgIH0gZWxzZSB7DQogICAgICAgIGlmIChkaW0od2VpZ2h0KVsxXSAhPSBkaW0od2VpZ2h0KVsyXSkgDQogICAgICAgICAgICBzdG9wKCInd2VpZ2h0JyBtdXN0IGJlIGEgc3F1YXJlIG1hdHJpeCIpDQogICAgICAgIG4gPC0gbGVuZ3RoKHgpDQogICAgICAgIGlmIChkaW0od2VpZ2h0KVsxXSAhPSBuKSANCiAgICAgICAgICAgIHN0b3AoIid3ZWlnaHQnIG11c3QgaGF2ZSBhcyBtYW55IHJvd3MgYXMgb2JzZXJ2YXRpb25zIGluICd4JyIpDQogICAgICAgIGVpIDwtIC0xLyhuIC0gMSkNCiAgICAgICAgbmFzIDwtIGlzLm5hKHgpDQogICAgICAgIGlmIChhbnkobmFzKSkgew0KICAgICAgICAgICAgaWYgKG5hLnJtKSB7DQogICAgICAgICAgICAgICAgeCA8LSB4WyFuYXNdDQogICAgICAgICAgICAgICAgbiA8LSBsZW5ndGgoeCkNCiAgICAgICAgICAgICAgICB3ZWlnaHQgPC0gd2VpZ2h0WyFuYXMsICFuYXNdDQogICAgICAgICAgICB9IGVsc2Ugew0KICAgICAgICAgICAgICAgIHdhcm5pbmcoIid4JyBoYXMgbWlzc2luZyB2YWx1ZXM6IG1heWJlIHlvdSB3YW50ZWQgdG8gc2V0IG5hLnJtID0gVFJVRT8iKQ0KICAgICAgICAgICAgICAgIHJldHVybihsaXN0KG9ic2VydmVkID0gTkEsIGV4cGVjdGVkID0gZWksIHNkID0gTkEsIHAudmFsdWUgPSBOQSkpDQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgIyBST1dTVU0gPC0gcm93U3Vtcyh3ZWlnaHQpIFJPV1NVTVtST1dTVU0gPT0gMF0gPC0gMSB3ZWlnaHQgPC0gd2VpZ2h0L1JPV1NVTQ0KICAgICAgICBzIDwtIHN1bSh3ZWlnaHQpDQogICAgICAgIG0gPC0gbWVhbih4KQ0KICAgICAgICB5IDwtIHggLSBtDQogICAgICAgIGN2IDwtIHN1bSh3ZWlnaHQgKiB5ICVvJSB5KQ0KICAgICAgICB2IDwtIHN1bSh5XjIpDQogICAgICAgIG9icyA8LSAobi9zKSAqIChjdi92KQ0KICAgICAgICBpZiAoc2NhbGVkKSB7DQogICAgICAgICAgICBpLm1heCA8LSAobi9zKSAqIChzZChyb3dTdW1zKHdlaWdodCkgKiB5KS9zcXJ0KHYvKG4gLSAxKSkpDQogICAgICAgICAgICBvYnMgPC0gb2JzL2kubWF4DQogICAgICAgIH0NCiAgICAgICAgUzEgPC0gMC41ICogc3VtKCh3ZWlnaHQgKyB0KHdlaWdodCkpXjIpDQogICAgICAgIFMyIDwtIHN1bSgoYXBwbHkod2VpZ2h0LCAxLCBzdW0pICsgYXBwbHkod2VpZ2h0LCAyLCBzdW0pKV4yKQ0KICAgICAgICBzLnNxIDwtIHNeMg0KICAgICAgICBrIDwtIChzdW0oeV40KS9uKS8odi9uKV4yDQogICAgICAgIHNkaSA8LSBzcXJ0KChuICogKChuXjIgLSAzICogbiArIDMpICogUzEgLSBuICogUzIgKyAzICogcy5zcSkgLSBrICogKG4gKiAobiAtIDEpICogUzEgLSAyICogbiAqIA0KICAgICAgICAgICAgUzIgKyA2ICogcy5zcSkpLygobiAtIDEpICogKG4gLSAyKSAqIChuIC0gMykgKiBzLnNxKSAtIDEvKChuIC0gMSleMikpDQogICAgICAgIGFsdGVybmF0aXZlIDwtIG1hdGNoLmFyZyhhbHRlcm5hdGl2ZSwgYygidHdvLnNpZGVkIiwgImxlc3MiLCAiZ3JlYXRlciIpKQ0KICAgICAgICBwdiA8LSBwbm9ybShvYnMsIG1lYW4gPSBlaSwgc2QgPSBzZGkpDQogICAgICAgIGlmIChhbHRlcm5hdGl2ZSA9PSAidHdvLnNpZGVkIikgDQogICAgICAgICAgICBwdiA8LSBpZiAob2JzIDw9IGVpKSANCiAgICAgICAgICAgICAgICAyICogcHYgZWxzZSAyICogKDEgLSBwdikNCiAgICAgICAgaWYgKGFsdGVybmF0aXZlID09ICJncmVhdGVyIikgDQogICAgICAgICAgICBwdiA8LSAxIC0gcHYNCiAgICAgICAgbGlzdChvYnNlcnZlZCA9IG9icywgZXhwZWN0ZWQgPSBlaSwgc2QgPSBzZGksIHAudmFsdWUgPSBwdikNCiAgICB9DQogICAgDQogICAgDQp9DQpgYGANCg0KPGJyPg0KDQojIyBsb2FkIGRhdGEgb2JqZWN0cyANCg0KYGBge3IsIHdhcm5pbmc9RkFMU0V9DQojIGxvYWQgdGhlIFJTaWVuYSBvYmplY3RzDQpsb2FkKCJjbHViZGF0YV9yc2llbmFfZnJlcS5SRGF0YSIpDQpsb2FkKCJjbHViZGF0YV9yc2llbmFfdm9sLlJEYXRhIikNCmxvYWQoImNsdWJkYXRhLlJEYXRhIikNCg0KYGBgDQoNCg0KDQotLS0tDQoNCg0KPGJyPg0KDQoNCiMgRGVzY3JpcHRpdmVzIHRhYmxlDQoNClJlcGxpY2F0ZSB0aGUgZGVzY3JpcHRpdmVzIHRhYmxlOg0KDQpgYGB7ciBldmFsPVR9DQp0YWIgPC0gbWF0cml4KG5yb3c9MTYsIG5jb2w9NSkNCnJvd25hbWVzKHRhYikgPC0gYygiRGVuc2l0eSIsICJBdmVyYWdlIGRlZ3JlZSIsICJSZWNpcHJvY2l0eSBpbmRleCIsICJHbG9iYWwgdHJhbnNpdGl2aXR5IGluZGV4IiwgIkphY2NhcmQgaW5kZXgiLCAiR2VuZGVyIHNlZ3JlZ2F0aW9uIiwgIk5ldHdvcmsgYXV0b2NvcnJlbGF0aW9uIiwgIkRpcmVjdCB0aWVzIiwgIkZyZXF1ZW5jeSAocGVyIHdlZWspIiwgIkhvdXJzIChwZXIgd2VlaykiLCAiRGlzdGFuY2UgZGVjYXkiLCAiRnJlcXVlbmN5IChwZXIgd2VlaykiLCAiSG91cnMgKHBlciB3ZWVrKSIsICJXZWVrbHkgcnVubmluZyBmcmVxdWVuY3kgYXQgdDEiLCAiV2Vla2x5IHJ1bm5pbmcgaG91cnMgYXQgdDEiLCAiTWFsZSBzZXggKCUpIiApDQpjb2xuYW1lcyh0YWIpIDwtIGMoIkNsdWIgMSIsIkNsdWIgMiIsICJDbHViIDMiLCAiQ2x1YiA0IiwgIkNsdWIgNSIpDQoNCmZvciAoaSBpbiAxOjUpIHsgIyBmb3IgZWFjaCBjbHViDQogICMgZGVuc2l0aWVzIG92ZXIgdGltZQ0KICBkZW5zaXRpZXMgPC0gYXMubnVtZXJpYyhzdHJzcGxpdChzdWJzdHJpbmcoY2FwdHVyZS5vdXRwdXQoY2x1YmRhdGFfcnNpZW5hX2ZyZXFbW2ldXSlbMTJdLCAyMCksICIgIilbWzFdXSkNCiAgIyBtZWFuIChzdGFuZGFyZCBkZXZpYXRpb24pDQogIHRhYlsxLCBpXSA8LSBwYXN0ZShhcy5jaGFyYWN0ZXIocm91bmQobWVhbihkZW5zaXRpZXMpLCAzKSksICIgKCIsIGFzLmNoYXJhY3Rlcihyb3VuZChzZChkZW5zaXRpZXMpLCAzKSksICIpIiwgc2VwPSIiKQ0KfQ0KDQoNCiMgQXZlcmFnZSBkZWdyZWVzDQpmb3IgKGkgaW4gMTo1KSB7ICMgZm9yIGVhY2ggY2x1Yg0KICAjIGNhbGN1bGF0ZSBhdmVyYWdlIG91dC1kZWdyZWUgb3ZlciB0aW1lDQogIGQgPC0gdmVjdG9yICgpDQogIGZvciAodCBpbiAxOjEyKSB7DQogICAgZFtbdF1dIDwtIG1lYW4oaWdyYXBoOjpkZWdyZWUoaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoY2x1YmRhdGFfcnNpZW5hX2ZyZXFbW2ldXSRkZXB2YXJzJGt1ZG9uZXRbLCx0XSksIG1vZGUgPSAib3V0IikpDQogICAgDQogIH0NCiAgIyBtZWFuIChzdGFuZGFyZCBkZXZpYXRpb24pDQogIHRhYlsyLCBpXSA8LSBwYXN0ZShhcy5jaGFyYWN0ZXIocm91bmQobWVhbihkKSwgMykpLCAiICgiLCBhcy5jaGFyYWN0ZXIocm91bmQoc2QoZCksIDMpKSwgIikiLCBzZXA9IiIpDQp9DQoNCg0KIyBSZWNpcHJvY2l0eSBpbmRleA0KZm9yIChpIGluIDE6NSkgeyAjIGZvciBlYWNoIGNsdWINCiAgIyBjYWxjdWxhdGUgcmVjaXByb2NpdHkgaW5kZXggb3ZlciB0aW1lDQogIHJpIDwtIHZlY3RvciAoKQ0KICANCiAgZm9yICh0IGluIDE6MTIpIHsNCiAgICBtdXQgPC0gaWdyYXBoOjpkeWFkLmNlbnN1cyhpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChjbHViZGF0YV9yc2llbmFfZnJlcVtbaV1dJGRlcHZhcnMka3Vkb25ldFssLHRdKSlbWzFdXQ0KICAgIG5vbm11dCA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGNsdWJkYXRhX3JzaWVuYV9mcmVxW1tpXV0kZGVwdmFycyRrdWRvbmV0WywsdF0pKVtbMl1dDQogICAgcmlbW3RdXSA8LSBtdXQvKG11dCtub25tdXQpDQogICAgDQogIH0NCiAgdGFiWzMsIGldIDwtIHBhc3RlKGFzLmNoYXJhY3Rlcihyb3VuZChtZWFuKHJpKSwgMykpLCAiICgiLCBhcy5jaGFyYWN0ZXIocm91bmQoc2QocmkpLCAzKSksICIpIiwgc2VwPSIiKQ0KfQ0KDQojIFRyYW5zaXRpdml0eSBpbmRleA0KZm9yIChpIGluIDE6NSkgeyAjIGZvciBlYWNoIGNsdWINCiAgIyBjYWxjdWxhdGUgdHJhbnNpdGl2aXR5IGluZGV4IG92ZXIgdGltZQ0KICB0aSA8LSB2ZWN0b3IgKCkNCiAgDQogIGZvciAodCBpbiAxOjEyKSB7DQogICAgdGlbW3RdXSA8LSBpZ3JhcGg6OnRyYW5zaXRpdml0eShpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChjbHViZGF0YV9yc2llbmFfZnJlcVtbaV1dJGRlcHZhcnMka3Vkb25ldFssLHRdKSkNCiAgICANCiAgfQ0KICB0YWJbNCwgaV0gPC0gcGFzdGUoYXMuY2hhcmFjdGVyKHJvdW5kKG1lYW4odGkpLCAzKSksICIgKCIsIGFzLmNoYXJhY3Rlcihyb3VuZChzZCh0aSksIDMpKSwgIikiLCBzZXA9IiIpDQp9DQoNCiMgSmFjY2FyZCBpbmRleA0KDQojIEdlbmRlciBzZWdyZWdhdGlvbiANCmZvciAoaSBpbiAxOjUpIHsgIyBmb3IgZWFjaCBjbHViDQogICMgY2FsY3VsYXRlIGNvbGVtYW4ncyBob21vcGhpbHkgaW5kZXggb3ZlciB0aW1lDQogIGNvbCA8LSB2ZWN0b3IgKCkNCiAgDQogIGZvciAodCBpbiAxOjEyKSB7DQogICAgY29sW1t0XV0gPC0gZnNjb2xuZXQoY2x1YmRhdGFfcnNpZW5hX2ZyZXFbW2ldXSRkZXB2YXJzJGt1ZG9uZXRbLCx0XSwgY2x1YmRhdGFfcnNpZW5hX2ZyZXFbW2ldXSRjQ292YXJzJGdlbmRlcikNCiAgfQ0KICB0YWJbNiwgaV0gPC0gcGFzdGUoYXMuY2hhcmFjdGVyKHJvdW5kKG1lYW4oY29sKSwgMykpLCAiICgiLCBhcy5jaGFyYWN0ZXIocm91bmQoc2QoY29sKSwgMykpLCAiKSIsIHNlcD0iIikNCn0NCg0KIyBOZXR3b3JrIGF1dG9jb3JyZWxhdGlvbg0KIyBmcmVxdWVuY3kNCmZvciAoaSBpbiAxOjUpIHsgIyBmb3IgZWFjaCBjbHViDQogICMgd2UgY2FsY3VsYXRlIG1vcmFuJ3MgaQ0KICAjIGJvdGggd2l0aCBkaXJlY3QgdGllcyBhbmQgaW5kaXJlY3QgdGllcyBhcyB3ZWxsDQogICMgZm9yIGZyZXF1ZW5jeSBhbmQgdm9sdW1lDQogIG1vcl9mcmVxX2RpciA8LSB2ZWN0b3IgKCkNCiAgbW9yX2ZyZXFfZGlzdCA8LSB2ZWN0b3IgKCkNCiAgbW9yX3ZvbF9kaXIgPC0gdmVjdG9yICgpDQogIG1vcl92b2xfZGlzdCA8LSB2ZWN0b3IgKCkNCiAgDQogIGZvciAodCBpbiAxOjEyKSB7ICAgICAgICAgDQogICAgZnJlcSA8LSBjbHViZGF0YVtbaV1dJGZyZXFfcnVuWywsdF0gICAjIGF0dHJpYnV0ZXMgYXQgdGltZSB0DQogICAgdm9sIDwtIGNsdWJkYXRhW1tpXV0kdGltZV9ydW5bLCx0XSAgIA0KICAgIGtuZXQgPC0gbmV0d29yazo6YXMubmV0d29yayhjbHViZGF0YV9yc2llbmFfZnJlcVtbaV1dJGRlcHZhcnMka3Vkb25ldFssLHRdKSAjIG5ldCBhIHRpbWUgdA0KICAgIGdlb2Rpc3RhbmNlcyA8LSBzbmE6Omdlb2Rpc3Qoa25ldCwgY291bnQucGF0aHM9VCkgIyBnZW9kZXNpYyBkaXN0YW5jZQ0KICAgIGdlb2Rpc3RhbmNlcyA8LSBnZW9kaXN0YW5jZXMkZ2Rpc3QgDQogICAgZGlhZyhnZW9kaXN0YW5jZXMpIDwtIEluZg0KICAgIHdlaWdodHMxIDwtIGdlb2Rpc3RhbmNlcyA9PSAxICAgICAgICAgICAgICAgIyBvbmx5IGRpcmVjdCB0aWVzDQogICAgd2VpZ2h0czIgPC0gZXhwKC1nZW9kaXN0YW5jZXMpICAgICAgICAgICAgICAjIGFsc28gaW5kaXJlY3QNCiAgICANCiAgICBtb3JfZnJlcV9kaXJbW3RdXSA8LSBmTW9yYW4uSShmcmVxLCBzY2FsZWQgPSBGQUxTRSwgIyBjYWxjdWxhdGUgbW9yYW4gb24gZGlyZWN0DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0czEsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hLnJtID0gVFJVRSwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93c3RhbmRhcmRpemUgPSBGQUxTRSlbWzFdXSANCiAgICBtb3JfZnJlcV9kaXN0W1t0XV0gPC0gZk1vcmFuLkkoZnJlcSwgc2NhbGVkID0gRkFMU0UsICMgYW5kIGluZGlyZWN0DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodCA9IHdlaWdodHMyLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmEucm0gPSBUUlVFLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93c3RhbmRhcmRpemUgPSBGQUxTRSlbWzFdXQ0KICAgIG1vcl92b2xfZGlyW1t0XV0gPC0gZk1vcmFuLkkodm9sLCBzY2FsZWQgPSBGQUxTRSwgIyBjYWxjdWxhdGUgbW9yYW4gb24gZGlyZWN0DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHRzMSwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYS5ybSA9IFRSVUUsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93c3RhbmRhcmRpemUgPSBGQUxTRSlbWzFdXSANCiAgICBtb3Jfdm9sX2Rpc3RbW3RdXSA8LSBmTW9yYW4uSSh2b2wsIHNjYWxlZCA9IEZBTFNFLCAjIGFuZCBpbmRpcmVjdA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodCA9IHdlaWdodHMyLCANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYS5ybSA9IFRSVUUsIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpW1sxXV0NCiAgfQ0KICB0YWJbOSwgaV0gPC0gcGFzdGUoYXMuY2hhcmFjdGVyKHJvdW5kKG1lYW4obW9yX2ZyZXFfZGlyKSwgMykpLCAiICgiLCBhcy5jaGFyYWN0ZXIocm91bmQoc2QobW9yX2ZyZXFfZGlyKSwgMykpLCAiKSIsIHNlcD0iIikNCiAgdGFiWzEwLCBpXSA8LSBwYXN0ZShhcy5jaGFyYWN0ZXIocm91bmQobWVhbihtb3Jfdm9sX2RpciksIDMpKSwgIiAoIiwgYXMuY2hhcmFjdGVyKHJvdW5kKHNkKG1vcl92b2xfZGlyKSwgMykpLCAiKSIsIHNlcD0iIikNCiAgdGFiWzEyLCBpXSA8LSBwYXN0ZShhcy5jaGFyYWN0ZXIocm91bmQobWVhbihtb3JfZnJlcV9kaXN0KSwgMykpLCAiICgiLCBhcy5jaGFyYWN0ZXIocm91bmQoc2QobW9yX2ZyZXFfZGlzdCksIDMpKSwgIikiLCBzZXA9IiIpDQogIHRhYlsxMywgaV0gPC0gcGFzdGUoYXMuY2hhcmFjdGVyKHJvdW5kKG1lYW4obW9yX3ZvbF9kaXN0KSwgMykpLCAiICgiLCBhcy5jaGFyYWN0ZXIocm91bmQoc2QobW9yX3ZvbF9kaXN0KSwgMykpLCAiKSIsIHNlcD0iIikNCn0NCg0KIyBiZWhhdmlvciBhdCBiYXNlbGluZSAodzEpDQpmb3IgKGkgaW4gMTo1KSB7ICMgZm9yIGVhY2ggY2x1Yg0KICAjIHJ1bm5pbmcgYXR0cmlidXRlcyBhdCB3MQ0KICB0YWJbMTQsIGldIDwtIHBhc3RlKGFzLmNoYXJhY3Rlcihyb3VuZChtZWFuKGNsdWJkYXRhW1tpXV0kZnJlcV9ydW5bLCwxXSwgbmEucm09VCksIDMpKSwgIiAoIiwgYXMuY2hhcmFjdGVyKHJvdW5kKHNkKGNsdWJkYXRhW1tpXV0kZnJlcV9ydW5bLCwxXSwgbmEucm09VCksIDMpKSwgIikiLCBzZXA9IiIpDQogIHRhYlsxNSwgaV0gPC0gcGFzdGUoYXMuY2hhcmFjdGVyKHJvdW5kKG1lYW4oY2x1YmRhdGFbW2ldXSR0aW1lX3J1blssLDFdLCBuYS5ybT1UKSwgMykpLCAiICgiLCBhcy5jaGFyYWN0ZXIocm91bmQoc2QoY2x1YmRhdGFbW2ldXSR0aW1lX3J1blssLDFdLCBuYS5ybT1UKSwgMykpLCAiKSIsIHNlcD0iIikNCn0NCiMgbWFsZSBzZXggKCUpDQpmb3IgKGkgaW4gMTo1KSB7ICMgZm9yIGVhY2ggY2x1Yg0KICAjIHBlcmNlbnRhZ2UgbWFsZQ0KICB0YWJbMTYsIGldIDwtIHJvdW5kKChsZW5ndGgoY2x1YmRhdGFbW2ldXVtjbHViZGF0YVtbaV1dJG1hbGU9PTFdKS9jbHViZGF0YVtbaV1dJG5ldHNpemUpKjEwMCwgMykNCn0NCg0KIyBmb3Igbm93IHdlIGluY2x1ZGUgamFjY2FyZCBtYW51YWxseTsgYnV0IHdlIHdhbnQgdG8gdXNlIGEgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZXNlIGlkZWFsbHkuDQp0YWJbNSwgXSA8LSBjKCIwLjg1MCAoMC4wNjApIiwgIjAuNzUgKDAuMDMwKSIsICIwLjUwMCAoMC4wNjApIiwgIjAuODAwICgwLjA5MCkiLCAiMC42OTAgKDAuMDIwKSIpDQoNCg0KDQoNCmBgYCANCiAgDQoNCg0KPGI+DQoNCiMgVGFibGUNCg0KYGBge3IgdGFibGUsIGVjaG89RiwgaW5jbHVkZT1UfQ0KDQpvcHRpb25zKGtuaXRyLmthYmxlLk5BID0gJycpDQoNCmtuaXRyOjprYWJsZSh0YWIsIGRpZ2l0cz0zLCAiaHRtbCIsIGNhcHRpb249IlRhYmxlIDEuIERlc2NyaXB0aXZlIHN0YXRpc3RpY3Mgb2YgU3RyYXZhIGNsdWJzIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKSAlPiUNCiAgZm9vdG5vdGUoZ2VuZXJhbCA9ICJGb3IgbmV0d29yayBtZWFzdXJlcywgbWVhbiB2YWx1ZXMgb3ZlciB0aW1lIGFyZSBnaXZlbiB3aXRoIHN0YW5kYXJkIGRldmlhdGlvbnMgaW4gcGFyZW50aGVzZXMuIEZvciBiZWhhdmlvcmFsIGF0dHJpYnV0ZXMsIG1lYW5zIGFuZCBzdGFuZGFyZCBkZXZpYXRpb25zIGF0IGJhc2VsaW5lICh0MTogRGVjZW1iZXIpIGFyZSBnaXZlbi4gRGVncmVlcyByZWZsZWN0IGt1ZG9zIHRpZXMsIHdpdGggYXdhcmRpbmcgMSBvciBtb3JlIGt1ZG9zIGNvbnN0aXR1dGluZyB0aGUgcHJlc2VuY2Ugb2YgYSB0aWUuIFRoZSByZWNpcHJvY2l0eSBpbmRleCBpcyB0aGUgcHJvcG9ydGlvbiBvZiBrdWRvcyB0aWVzIHRoYXQgd2VyZSByZWNpcHJvY2F0ZWQ7IHRoZSB0cmFuc2l0aXZpdHkgaW5kZXggaXMgdGhlIG51bWJlciBvZiBjbG9zZWQgdHJpcGxldHMgb3ZlciB0aGUgdG90YWwgbnVtYmVyIG9mIHRyaXBsZXRzIChib3RoIG9wZW4gYW5kIGNsb3NlZCkuIiwNCiAgICAgICAgICAgYWxwaGFiZXQgID0gYygiVGhlIEphY2NhcmQgc2ltaWxhcml0eSBpbmRleCBtZWFzdXJlcyB0aGUgZXh0ZW50IG9mIHRpZSBjaGFuZ2UgYmV0d2VlbiBjb25zZWN1dGl2ZSB3YXZlcyIsICJUaGUgZ2VuZGVyIHNlZ3JlZ2F0aW9uIG1lYXN1cmUgdXNlZCBpcyBDb2xlbWFu4oCZcyBob21vcGhpbHkgaW5kZXguIiwgIlRoZSBuZXR3b3JrIGF1dG9jb3JyZWxhdGlvbiBtZWFzdXJlIHVzZWQgaXMgTW9yYW7igJlzIEkuIFdlIGNhbGN1bGF0ZWQgTW9yYW7igJlzIEkgZm9yIGRpcmVjdCB0aWVzIChpLmUuIHdpdGggdW5kaXJlY3RlZCBwYXRoIGxlbmd0aCAxKSBhbmQgZm9yIGFsbCB0aWVzIHRvIHdob20gZWdvIGlzIChkaXJlY3RseSBvciBpbmRpcmVjdGx5KSB0aWVkLCB1c2luZyBhIGRpc3RhbmNlLWRlY2F5IGZ1bmN0aW9uIGZvciBhc3NpZ25pbmcgd2VpZ2h0cy4gVG8gY29uc3RydWN0IHRoZSB3ZWlnaHQgbWF0cml4LCB3ZSBtZWFzdXJlZCB0aGUgZ2VvZGlzdGFuY2UgKGQpIGZvciBlYWNoIGR5YWQgYXMgdGhlIHNob3J0ZXN0ICh1bmRpcmVjdGVkKSBwYXRoIGxlbmd0aC4gV2UgdGhlbiB1c2VkIHRoZSBuZWdhdGl2ZSBleHBvbmVudGlhbCBkaXN0YW5jZS1kZWNheSBmdW5jdGlvbi4gV2UgZGlkIG5vdCByb3ctc3RhbmRhcmRpemUuIikpDQpgYGANCg0K</div>
<style>
.center {
  text-align: center;
  color: red;
}
</style>

<hr>
<br>
<p class="center">Copyright &copy; 2021 Rob Franken</p>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("destab.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
