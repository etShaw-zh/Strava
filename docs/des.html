<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Descriptive statistics</title>

<script src="site_libs/header-attrs-2.14/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>
<script src="site_libs/kePrint-0.0.1/kePrint.js"></script>
<link href="site_libs/lightable-0.0.1/lightable.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>

<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="prep.html">Preparation</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Descriptives
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="des.html">Procedure</a>
    </li>
    <li>
      <a href="destab.html">Table 1: Descriptives</a>
    </li>
    <li>
      <a href="desfig.html">Figure 5: Development of the mean running</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Model selection
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="explore.html">Club 1</a>
    </li>
    <li>
      <a href="other.html">Clubs 2-5</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Meta-analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="meta.html">Running frequency models</a>
    </li>
    <li>
      <a href="vol_meta.html">Running volume models</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    GOF
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="GOF1.html">Running frequency models</a>
    </li>
    <li>
      <a href="GOF2.html">Running volume</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Influence effects
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="influenceeffects.html">Different influence operationalizations</a>
    </li>
    <li>
      <a href="interaction.html">Interaction effects for influence dynamics</a>
    </li>
    <li>
      <a href="figure3.html">Figure 6: Ego-alter influence plot</a>
    </li>
    <li>
      <a href="RI.html">Figure 7: Relative importance of effects</a>
    </li>
    <li>
      <a href="simulations.html">Empirically calibrated ABMs</a>
    </li>
    <li>
      <a href="moderation.html">Post-hoc probing of moderational effects</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/robfranken/Strava">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Descriptive statistics</h1>
<h4 class="date">Last compiled on september, 2022</h4>

</div>


<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('right', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
<hr />
<p>We will use the RSiena objects of clubs to describe the kudos
networks, constant covariates and behavioral variables.</p>
<p><br></p>
<div id="getting-started" class="section level1">
<h1>Getting started</h1>
<p>Clean the working environment and load in the club data.</p>
<pre class="r test"><code># clean the working environment 
rm (list = ls( ))

# load the RSiena objects
load(&quot;clubdata_rsiena_freq.RData&quot;)
load(&quot;clubdata_rsiena_vol.RData&quot;)

# and the list containing club data-setes
load(&quot;clubdata.RData&quot;)</code></pre>
<p><br></p>
<div id="general-custom-functions" class="section level2">
<h2>general custom functions</h2>
<ul>
<li><code>fpackage.check</code>: Check if packages are installed (and
install if not) in R (<a
href="https://vbaliga.github.io/verify-that-r-packages-are-installed-and-loaded/">source</a>)</li>
<li><code>fload.R</code>: function to load R-objects under new
names.</li>
</ul>
<pre class="r test"><code>fpackage.check &lt;- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

fload.R  &lt;- function(fileName){
  load(fileName)
  get(ls()[ls() != &quot;fileName&quot;])
}</code></pre>
</div>
<div id="necessary-packages" class="section level2">
<h2>necessary packages</h2>
<p>We install and load the packages we need later on:</p>
<ul>
<li><code>RSiena</code>: RSiena models, some descriptives on network
level</li>
<li><code>igraph</code>: Descriptives (dyad/triad census, degrees)</li>
<li><code>tidyverse</code></li>
<li><code>tidyr</code>: for tidy data</li>
<li><code>moments</code>: for calculating statistics (e.g., kurtosis,
standard error)</li>
<li><code>dplyr</code>: for data manipulation</li>
<li><code>ggplot2</code>: for data visualization</li>
<li><code>forcats</code>: for handling categorical variabl</li>
<li><code>knitr</code>: for generating tables</li>
<li><code>kableExtra</code>: for manipulating tables</li>
<li><code>network</code>: for network analysis</li>
<li><code>sna</code>: for network analysis</li>
</ul>
<pre class="r test"><code>packages = c(&quot;RSiena&quot;, &quot;igraph&quot;, &quot;tidyverse&quot;, &quot;tidyr&quot;, &quot;moments&quot;, &quot;dplyr&quot;, &quot;ggplot2&quot;, &quot;forcats&quot;, &quot;knitr&quot;, &quot;kableExtra&quot;, &quot;network&quot;, &quot;sna&quot;)

fpackage.check(packages)</code></pre>
</div>
<div id="additional-functions" class="section level2">
<h2>additional functions</h2>
<p>Now define some additional functions we use later on to describe our
data (see <a
href="https://www.jochemtolsma.nl/courses/complete-networks/socio6/#descriptive-statistics">www.jochemtolsma.nl</a>).</p>
<ul>
<li><code>fdensity</code>: calculate density (exclude NA and structural
zeros)<br />
</li>
<li><code>fdensityintra</code>: calculate density within group (exclude
NA and structural zeros)<br />
</li>
<li><code>fdensityinter</code>: calculate density between groups
(exclude NA and structural zeros)<br />
</li>
<li><code>fhomomat</code>: based on ego/alter characteristics, construct
dyad characteristic whether or not ego/alter are same</li>
<li><code>fndyads</code>: calculate all valid dyads (no NA or structural
zeros)<br />
</li>
<li><code>fscolnet</code>: calculate Coleman’s segregation index on the
network-level<br />
</li>
<li><code>fMoran.i</code>: calculate Moran’s I spatial autocorrelation
statistic (see <a
href="https://www.jochemtolsma.nl/courses/complete-networks/socio7/#morans-autocorrelation-for-outgoing-ties-rsiena-build-in-dataset">here</a>)</li>
</ul>
<pre class="r fold-hide"><code># density: observed relations divided by possible relations
fdensity &lt;- function(x) {
    # x is your nomination network make sure diagonal cells are NA
    diag(x) &lt;- NA
    # take care of RSiena structural zeros, set as missing.
    x[x == 10] &lt;- NA
    sum(x == 1, na.rm = T)/(sum(x == 1 | x == 0, na.rm = T))
}

# calculate intragroup density
fdensityintra &lt;- function(x, A) {
    # A is matrix indicating whether nodes in dyad have same node attributes
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    diag(A) &lt;- NA
    sum(x == 1 &amp; A == 1, na.rm = T)/(sum((x == 1 | x == 0) &amp; A == 1, na.rm = T))
}

# calculate intragroup density
fdensityinter &lt;- function(x, A) {
    # A is matrix indicating whether nodes in dyad have same node attributes
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    diag(A) &lt;- NA
    sum(x == 1 &amp; A != 1, na.rm = T)/(sum((x == 1 | x == 0) &amp; A != 1, na.rm = T))
}

# construct dyad characteristic whether nodes are similar/homogenous
fhomomat &lt;- function(x) {
    # x is a vector of node-covariate
    xmat &lt;- matrix(x, nrow = length(x), ncol = length(x))
    xmatt &lt;- t(xmat)
    xhomo &lt;- xmat == xmatt
    return(xhomo)
}

# a function to calculate all valid dyads.
fndyads &lt;- function(x) {
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    (sum((x == 1 | x == 0), na.rm = T))
}

# a function to calculate all valid intragroupdyads.
fndyads2 &lt;- function(x, A) {
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    diag(A) &lt;- NA
    (sum((x == 1 | x == 0) &amp; A == 1, na.rm = T))
}


fscolnet &lt;- function(network, ccovar) {
    # Calculate coleman on network level:
    # https://reader.elsevier.com/reader/sd/pii/S0378873314000239?token=A42F99FF6E2B750436DD2CB0DB7B1F41BDEC16052A45683C02644DAF88215A3379636B2AA197B65941D6373E9E2EE413
    
    fhomomat &lt;- function(x) {
        xmat &lt;- matrix(x, nrow = length(x), ncol = length(x))
        xmatt &lt;- t(xmat)
        xhomo &lt;- xmat == xmatt
        return(xhomo)
    }
    
    fsumintra &lt;- function(x, A) {
        # A is matrix indicating whether nodes constituting dyad have same characteristics
        diag(x) &lt;- NA
        x[x == 10] &lt;- NA
        diag(A) &lt;- NA
        sum(x == 1 &amp; A == 1, na.rm = T)
    }
    
    # expecation w*=sum_g sum_i (ni((ng-1)/(N-1)))
    network[network == 10] &lt;- NA
    ni &lt;- rowSums(network, na.rm = T)
    ng &lt;- NA
    for (i in 1:length(ccovar)) {
        ng[i] &lt;- table(ccovar)[rownames(table(ccovar)) == ccovar[i]]
    }
    N &lt;- length(ccovar)
    wexp &lt;- sum(ni * ((ng - 1)/(N - 1)), na.rm = T)
    
    # wgg1 how many intragroup ties
    w &lt;- fsumintra(network, fhomomat(ccovar))
    
    Scol_net &lt;- ifelse(w &gt;= wexp, (w - wexp)/(sum(ni, na.rm = T) - wexp), (w - wexp)/wexp)
    return(Scol_net)
}

fMoran.I &lt;- function(x, weight, scaled = FALSE, na.rm = FALSE, alternative = &quot;two.sided&quot;, rowstandardize = TRUE) {
    if (rowstandardize) {
        if (dim(weight)[1] != dim(weight)[2]) 
            stop(&quot;&#39;weight&#39; must be a square matrix&quot;)
        n &lt;- length(x)
        if (dim(weight)[1] != n) 
            stop(&quot;&#39;weight&#39; must have as many rows as observations in &#39;x&#39;&quot;)
        ei &lt;- -1/(n - 1)
        nas &lt;- is.na(x)
        if (any(nas)) {
            if (na.rm) {
                x &lt;- x[!nas]
                n &lt;- length(x)
                weight &lt;- weight[!nas, !nas]
            } else {
                warning(&quot;&#39;x&#39; has missing values: maybe you wanted to set na.rm = TRUE?&quot;)
                return(list(observed = NA, expected = ei, sd = NA, p.value = NA))
            }
        }
        ROWSUM &lt;- rowSums(weight)
        ROWSUM[ROWSUM == 0] &lt;- 1
        weight &lt;- weight/ROWSUM
        s &lt;- sum(weight)
        m &lt;- mean(x)
        y &lt;- x - m
        cv &lt;- sum(weight * y %o% y)
        v &lt;- sum(y^2)
        obs &lt;- (n/s) * (cv/v)
        if (scaled) {
            i.max &lt;- (n/s) * (sd(rowSums(weight) * y)/sqrt(v/(n - 1)))
            obs &lt;- obs/i.max
        }
        S1 &lt;- 0.5 * sum((weight + t(weight))^2)
        S2 &lt;- sum((apply(weight, 1, sum) + apply(weight, 2, sum))^2)
        s.sq &lt;- s^2
        k &lt;- (sum(y^4)/n)/(v/n)^2
        sdi &lt;- sqrt((n * ((n^2 - 3 * n + 3) * S1 - n * S2 + 3 * s.sq) - k * (n * (n - 1) * S1 - 2 * n * 
            S2 + 6 * s.sq))/((n - 1) * (n - 2) * (n - 3) * s.sq) - 1/((n - 1)^2))
        alternative &lt;- match.arg(alternative, c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;))
        pv &lt;- pnorm(obs, mean = ei, sd = sdi)
        if (alternative == &quot;two.sided&quot;) 
            pv &lt;- if (obs &lt;= ei) 
                2 * pv else 2 * (1 - pv)
        if (alternative == &quot;greater&quot;) 
            pv &lt;- 1 - pv
        list(observed = obs, expected = ei, sd = sdi, p.value = pv)
    } else {
        if (dim(weight)[1] != dim(weight)[2]) 
            stop(&quot;&#39;weight&#39; must be a square matrix&quot;)
        n &lt;- length(x)
        if (dim(weight)[1] != n) 
            stop(&quot;&#39;weight&#39; must have as many rows as observations in &#39;x&#39;&quot;)
        ei &lt;- -1/(n - 1)
        nas &lt;- is.na(x)
        if (any(nas)) {
            if (na.rm) {
                x &lt;- x[!nas]
                n &lt;- length(x)
                weight &lt;- weight[!nas, !nas]
            } else {
                warning(&quot;&#39;x&#39; has missing values: maybe you wanted to set na.rm = TRUE?&quot;)
                return(list(observed = NA, expected = ei, sd = NA, p.value = NA))
            }
        }
        # ROWSUM &lt;- rowSums(weight) ROWSUM[ROWSUM == 0] &lt;- 1 weight &lt;- weight/ROWSUM
        s &lt;- sum(weight)
        m &lt;- mean(x)
        y &lt;- x - m
        cv &lt;- sum(weight * y %o% y)
        v &lt;- sum(y^2)
        obs &lt;- (n/s) * (cv/v)
        if (scaled) {
            i.max &lt;- (n/s) * (sd(rowSums(weight) * y)/sqrt(v/(n - 1)))
            obs &lt;- obs/i.max
        }
        S1 &lt;- 0.5 * sum((weight + t(weight))^2)
        S2 &lt;- sum((apply(weight, 1, sum) + apply(weight, 2, sum))^2)
        s.sq &lt;- s^2
        k &lt;- (sum(y^4)/n)/(v/n)^2
        sdi &lt;- sqrt((n * ((n^2 - 3 * n + 3) * S1 - n * S2 + 3 * s.sq) - k * (n * (n - 1) * S1 - 2 * n * 
            S2 + 6 * s.sq))/((n - 1) * (n - 2) * (n - 3) * s.sq) - 1/((n - 1)^2))
        alternative &lt;- match.arg(alternative, c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;))
        pv &lt;- pnorm(obs, mean = ei, sd = sdi)
        if (alternative == &quot;two.sided&quot;) 
            pv &lt;- if (obs &lt;= ei) 
                2 * pv else 2 * (1 - pv)
        if (alternative == &quot;greater&quot;) 
            pv &lt;- 1 - pv
        list(observed = obs, expected = ei, sd = sdi, p.value = pv)
    }
    
    
}</code></pre>
<hr />
<p>We cover the following:</p>
<ul>
<li>club characteristics</li>
<li>network structure in Kudos networks</li>
<li>gender composition / segregation</li>
<li>behavior: activity level (frequency and duration) and
correlation</li>
<li>spatial network autocorrelation: behavioral similarity in
networks</li>
</ul>
<hr />
<p><br></p>
</div>
</div>
<div id="print-report" class="section level1">
<h1>Print report</h1>
<div id="section" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade"></h2>
<p>Make sure to check the output of the ‘print01Report()’ function for
general data descripton (degrees, network size, etc.) and a general
overview of the dataset. Output is printed in a .txt file in the
directory specified.</p>
<div id="club-1" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[1]] # grab club 
print01Report(df, modelname=&quot;files/club1&quot;)</code></pre>
<p><embed src="files/club1.txt" id="id" class="class"
style="width:100.0%" height="200" /></p>
</div>
<div id="club-2" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[2]] # grab club 
print01Report(df, modelname=&quot;files/club2&quot;)</code></pre>
<p><embed src="files/club2.txt" id="id" class="class"
style="width:100.0%" height="200" /></p>
</div>
<div id="club-3" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[3]] # grab club 
print01Report(df, modelname=&quot;files/club3&quot;)</code></pre>
<p><embed src="files/club3.txt" id="id" class="class"
style="width:100.0%" height="200" /></p>
</div>
<div id="club-4" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[4]] # grab club 
print01Report(df, modelname=&quot;files/club4&quot;)</code></pre>
<p><embed src="files/club4.txt" id="id" class="class"
style="width:100.0%" height="200" /></p>
</div>
<div id="club-5" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[5]] # grab club 
print01Report(df, modelname=&quot;files/club5&quot;)</code></pre>
<p><embed src="files/club5.txt" id="id" class="class"
style="width:100.0%" height="200" /></p>
</div>
</div>
<div id="section-1" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<hr />
</div>
</div>
<div id="club-characteristics" class="section level1">
<h1>Club characteristics</h1>
<p>Some club characteristics. We show the size of the network (the
number of actors) for each club and the number of active members
currently (18-1-2021) on Strava, by adding to
<em>www.strava.com/clubs/…</em> the original club id.</p>
<pre class="r test"><code># attrieve from the clubdata the number of actors in each network
netsize &lt;- c( 
  length(clubdata_rsiena_freq[[1]]$nodeSets$Actors), 
  length(clubdata_rsiena_freq[[2]]$nodeSets$Actors), 
  length(clubdata_rsiena_freq[[3]]$nodeSets$Actors), 
  length(clubdata_rsiena_freq[[4]]$nodeSets$Actors), 
  length(clubdata_rsiena_freq[[5]]$nodeSets$Actors)) 

clubsize &lt;- c(66, 127, 373, 15, 169) # find the number of members currently on Strava

df &lt;- data.frame( netsize = netsize, clubsize = clubsize )

print(df)</code></pre>
<pre class="test2"><code>#&gt;   netsize clubsize
#&gt; 1      27       66
#&gt; 2      58      127
#&gt; 3     159      373
#&gt; 4       9       15
#&gt; 5      76      169</code></pre>
<p><br></p>
<hr />
</div>
<div id="kudos-network" class="section level1">
<h1>Kudos network</h1>
<p>Now let’s describe the Kudos network.</p>
<div id="node-level" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade">1. Node-level</h2>
<p>Starting, again, with indegrees and outdegrees: who receives and
gives Kudos? We take from the RSiena object the Kudos network for each
club, subset the first wave, and turn it into an <em>igraph</em>
object.</p>
<div id="club-1-1" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[1]] # grab club 
knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode=&quot;out&quot;), xlab=&quot;outdegree&quot;, main=&quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode=&quot;in&quot;), xlab=&quot;indegree&quot;, main=&quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-10-2.png" width="672" /></p>
</div>
<div id="club-2-1" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[2]] # grab club t
knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode=&quot;out&quot;), xlab=&quot;outdegree&quot;, main=&quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode=&quot;in&quot;), xlab=&quot;indegree&quot;, main=&quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-11-2.png" width="672" /></p>
</div>
<div id="club-3-1" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[3]] # grab club 
knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode=&quot;out&quot;), xlab=&quot;outdegree&quot;, main=&quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode=&quot;in&quot;), xlab=&quot;indegree&quot;, main=&quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-12-2.png" width="672" /></p>
</div>
<div id="club-4-1" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[4]] # grab club 
knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode=&quot;out&quot;), xlab=&quot;outdegree&quot;, main=&quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode=&quot;in&quot;), xlab=&quot;indegree&quot;, main=&quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-13-2.png" width="672" /></p>
</div>
<div id="club-5-1" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[5]] # grab club 
knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode=&quot;out&quot;), xlab=&quot;outdegree&quot;, main=&quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode=&quot;in&quot;), xlab=&quot;indegree&quot;, main=&quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-14-2.png" width="672" /></p>
</div>
</div>
<div id="section-2" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>We can observe a Pareto-like-pattern: some give/receive most of the
Kudos given, while most give/receive few.</p>
<p><br></p>
</div>
<div id="dyad-level" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade">2. Dyad-level</h2>
<p>At the dyad-level: let’s see to what extent Kudos tend to be
reciprocated between actors.</p>
<div id="club-1-2" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena_freq[[1]] # grab club 
knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1)*(vcount(G1)-1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 30
#&gt; 
#&gt; $asym
#&gt; [1] 5
#&gt; 
#&gt; $null
#&gt; [1] 316
#&gt; 
#&gt; $total
#&gt; [1] 351</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for ( i in 1:trial ){
  random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
  recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{hist(recip, main=&quot;number of reciprocated Kudos in random graph&quot;, xlab=&quot;&quot;, )
abline(v=dyadcount$mut, col=&quot;red&quot;, lwd=3)}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
</div>
<div id="club-2-2" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena_freq[[2]] # grab club 
knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1)*(vcount(G1)-1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 231
#&gt; 
#&gt; $asym
#&gt; [1] 99
#&gt; 
#&gt; $null
#&gt; [1] 1323
#&gt; 
#&gt; $total
#&gt; [1] 1653</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for ( i in 1:trial ){
  random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
  recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{hist(recip, main=&quot;number of reciprocated Kudos in random graph&quot;, xlab=&quot;&quot;, )
abline(v=dyadcount$mut, col=&quot;red&quot;, lwd=3)}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
</div>
<div id="club-3-2" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena_freq[[3]] # grab club 
knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1)*(vcount(G1)-1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 91
#&gt; 
#&gt; $asym
#&gt; [1] 104
#&gt; 
#&gt; $null
#&gt; [1] 12366
#&gt; 
#&gt; $total
#&gt; [1] 12561</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for ( i in 1:trial ){
  random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
  recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{hist(recip, main=&quot;number of reciprocated Kudos in random graph&quot;, xlab=&quot;&quot;, )
abline(v=dyadcount$mut, col=&quot;red&quot;, lwd=3)}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
</div>
<div id="club-4-2" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena_freq[[4]] # grab club 
knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1)*(vcount(G1)-1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 7
#&gt; 
#&gt; $asym
#&gt; [1] 2
#&gt; 
#&gt; $null
#&gt; [1] 27
#&gt; 
#&gt; $total
#&gt; [1] 36</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for ( i in 1:trial ){
  random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
  recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{hist(recip, main=&quot;number of reciprocated Kudos in random graph&quot;, xlab=&quot;&quot;, )
abline(v=dyadcount$mut, col=&quot;red&quot;, lwd=3)}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
</div>
<div id="club-5-2" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena_freq[[5]] # grab club 
knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1)*(vcount(G1)-1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 195
#&gt; 
#&gt; $asym
#&gt; [1] 119
#&gt; 
#&gt; $null
#&gt; [1] 2536
#&gt; 
#&gt; $total
#&gt; [1] 2850</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for ( i in 1:trial ){
  random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
  recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{hist(recip, main=&quot;number of reciprocated Kudos in random graph&quot;, xlab=&quot;&quot;, )
abline(v=dyadcount$mut, col=&quot;red&quot;, lwd=3)}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
</div>
</div>
<div id="section-3" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>Conclusion: Kudos tend to be reciprocated!</p>
<hr />
<p><br></p>
</div>
</div>
<div id="gender-composition" class="section level1">
<h1>Gender composition</h1>
<div id="section-4" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade"></h2>
<p>Let’s investigate the gender composition of the club. We must
retrieve gender from the object (note that we use the clubdata object,
not the RSiena object). Then we make a categorical gender variable and
plot it.</p>
<div id="club-1-3" class="section level3">
<h3>Club 1</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[1]] # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender) # missing category

# make dataframe
df &lt;- data.frame(
  gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)),
  n = c(length(gender[gender == &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender == &quot;Missing&quot;])),
  freq = c(round((length(gender[gender==&quot;Male&quot;])/length(gender) *100), digits=1), round((length(gender[gender==&quot;Female&quot;])/length(gender) *100), digits=1), round((length(gender[gender==&quot;Other&quot;])/length(gender)*100), digits=1), round((length(gender[gender==&quot;Missing&quot;])/length(gender)*100), digits=1))
)

# plot
df %&gt;%
  mutate(gender = fct_reorder(gender, -n)) %&gt;%
           ggplot(aes(gender, n, fill=gender)) + 
           geom_bar(stat=&quot;identity&quot;, width=0.8) +
           geom_text(aes(label=paste0(freq,&quot;%&quot;)), vjust=1.5, colour=&quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
</div>
<div id="club-2-3" class="section level3">
<h3>Club 2</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[2]] # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender) # missing category

# make dataframe
df &lt;- data.frame(
  gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)),
  n = c(length(gender[gender == &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender == &quot;Missing&quot;])),
  freq = c(round((length(gender[gender==&quot;Male&quot;])/length(gender) *100), digits=1), round((length(gender[gender==&quot;Female&quot;])/length(gender) *100), digits=1), round((length(gender[gender==&quot;Other&quot;])/length(gender)*100), digits=1), round((length(gender[gender==&quot;Missing&quot;])/length(gender)*100), digits=1))
)

# plot
df %&gt;%
  mutate(gender = fct_reorder(gender, -n)) %&gt;%
           ggplot(aes(gender, n, fill=gender)) + 
           geom_bar(stat=&quot;identity&quot;, width=0.8) +
           geom_text(aes(label=paste0(freq,&quot;%&quot;)), vjust=1.5, colour=&quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
</div>
<div id="club-3-3" class="section level3">
<h3>Club 3</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[3]] # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender) # missing category

# make dataframe
df &lt;- data.frame(
  gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)),
  n = c(length(gender[gender == &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender == &quot;Missing&quot;])),
  freq = c(round((length(gender[gender==&quot;Male&quot;])/length(gender) *100), digits=1), round((length(gender[gender==&quot;Female&quot;])/length(gender) *100), digits=1), round((length(gender[gender==&quot;Other&quot;])/length(gender)*100), digits=1), round((length(gender[gender==&quot;Missing&quot;])/length(gender)*100), digits=1))
)

# plot
df %&gt;%
  mutate(gender = fct_reorder(gender, -n)) %&gt;%
           ggplot(aes(gender, n, fill=gender)) + 
           geom_bar(stat=&quot;identity&quot;, width=0.8) +
           geom_text(aes(label=paste0(freq,&quot;%&quot;)), vjust=1.5, colour=&quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
</div>
<div id="club-4-3" class="section level3">
<h3>Club 4</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[4]] # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender) # missing category

# make dataframe
df &lt;- data.frame(
  gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)),
  n = c(length(gender[gender == &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender == &quot;Missing&quot;])),
  freq = c(round((length(gender[gender==&quot;Male&quot;])/length(gender) *100), digits=1), round((length(gender[gender==&quot;Female&quot;])/length(gender) *100), digits=1), round((length(gender[gender==&quot;Other&quot;])/length(gender)*100), digits=1), round((length(gender[gender==&quot;Missing&quot;])/length(gender)*100), digits=1))
)

# plot
df %&gt;%
  mutate(gender = fct_reorder(gender, -n)) %&gt;%
           ggplot(aes(gender, n, fill=gender)) + 
           geom_bar(stat=&quot;identity&quot;, width=0.8) +
           geom_text(aes(label=paste0(freq,&quot;%&quot;)), vjust=1.5, colour=&quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
</div>
<div id="club-5-3" class="section level3">
<h3>Club 5</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[5]] # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender) # missing category

# make dataframe
df &lt;- data.frame(
  gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)),
  n = c(length(gender[gender == &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender == &quot;Missing&quot;])),
  freq = c(round((length(gender[gender==&quot;Male&quot;])/length(gender) *100), digits=1), round((length(gender[gender==&quot;Female&quot;])/length(gender) *100), digits=1), round((length(gender[gender==&quot;Other&quot;])/length(gender)*100), digits=1), round((length(gender[gender==&quot;Missing&quot;])/length(gender)*100), digits=1))
)

# plot
df %&gt;%
  mutate(gender = fct_reorder(gender, -n)) %&gt;%
           ggplot(aes(gender, n, fill=gender)) + 
           geom_bar(stat=&quot;identity&quot;, width=0.8) +
           geom_text(aes(label=paste0(freq,&quot;%&quot;)), vjust=1.5, colour=&quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
</div>
</div>
<div id="section-5" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>We can see that in all clubs men are the majority.</p>
<hr />
<p><br></p>
</div>
</div>
<div id="gender-segregation" class="section level1">
<h1>Gender segregation</h1>
<p>Let’s now investigate segregation along gender in the kudos
network.</p>
<div id="section-6" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade"></h2>
<p>Let’s start with describing the total density and intra- (same
gender) and intergroup (different gender) densities. We also calculate
the Coleman Homophily index for gender, which reflects gender
segregation while taking into account the relative group size of gender
categories.</p>
<div id="club-1-4" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[1]] # grab club 
df2 &lt;- clubdata[[1]]

knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender) # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)


# make object to store results
desmat &lt;- matrix(NA, nrow=4, ncol=1)

# use functions
desmat[1, 1] &lt;- fdensity(knet1)
desmat[2, 1] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 1] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 1] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;Kudos network&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)



knitr::kable(desmat, digits=3, &quot;html&quot;, caption=&quot;Gender segregation in friendship and kudo network&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Kudos network
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.118
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.151
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.086
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
0.232
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-2-4" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[2]] # grab club 
df2 &lt;- clubdata[[2]]

knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender) # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)


# make object to store results
desmat &lt;- matrix(NA, nrow=4, ncol=1)

# use functions
desmat[1, 1] &lt;- fdensity(knet1)
desmat[2, 1] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 1] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 1] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;Kudos network&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)



knitr::kable(desmat, digits=3, &quot;html&quot;, caption=&quot;Gender segregation in friendship and kudo network&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Kudos network
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.189
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.250
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.103
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
0.343
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-3-4" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[3]] # grab club 
df2 &lt;- clubdata[[3]]

knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender) # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)


# make object to store results
desmat &lt;- matrix(NA, nrow=4, ncol=1)

# use functions
desmat[1, 1] &lt;- fdensity(knet1)
desmat[2, 1] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 1] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 1] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;Kudos network&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)



knitr::kable(desmat, digits=3, &quot;html&quot;, caption=&quot;Gender segregation in friendship and kudo network&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Kudos network
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.017
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.017
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.018
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
0.040
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-4-4" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[4]] # grab club 
df2 &lt;- clubdata[[4]]

knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender) # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)


# make object to store results
desmat &lt;- matrix(NA, nrow=4, ncol=1)

# use functions
desmat[1, 1] &lt;- fdensity(knet1)
desmat[2, 1] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 1] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 1] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;Kudos network&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)



knitr::kable(desmat, digits=3, &quot;html&quot;, caption=&quot;Gender segregation in friendship and kudo network&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Kudos network
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.381
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.286
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.429
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
-0.347
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-5-4" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[5]] # grab club 
df2 &lt;- clubdata[[5]]

knet &lt;- df$depvars$kudonet # take Kudo network
knet1 &lt;- knet[,,1] # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender) # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)


# make object to store results
desmat &lt;- matrix(NA, nrow=4, ncol=1)

# use functions
desmat[1, 1] &lt;- fdensity(knet1)
desmat[2, 1] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 1] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 1] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;Kudos network&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)



knitr::kable(desmat, digits=3, &quot;html&quot;, caption=&quot;Gender segregation in friendship and kudo network&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Kudos network
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.122
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.117
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.129
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
0.025
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="section-7" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>Density in the kudos network is not much higher within-gender than
between-genders, though this ratio differs per club (and in one clubs
between-gender kudos are more common).</p>
<p>Coleman’s Homophily indices vary across clubs. In some clubs there is
slight gender segregation (or same-gender preference) in kudos ties
(values higher than 0, but rather close to 0), though in others members
tend to give kudos to others outside their own gender group (values
lower than 0).</p>
<hr />
<p><br></p>
</div>
</div>
<div id="behavior" class="section level1">
<h1>Behavior</h1>
<p>We plotted the development of the mean of running attributes (Figure
5 of the manuscript). The script to replicate this plot can be found <a
href="https://robfranken.github.io/Strava/desfig.html">here</a>.</p>
</div>
<div id="within-person-change" class="section level1">
<h1>Within-person change</h1>
<div id="section-8" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade"></h2>
<p>Now let’s also check if behavior varied over time within individuals.
Within-person variation is a prerequisite for identifying influence
effects on behavior. Down below we demonstrate how running activity
varies within individuals over time, in absolute scores (i.e. in times
per week).</p>
<div id="club-1-5" class="section level3">
<h3>Club 1</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[1]] # grab club

# check within-person variability of running frequency
# absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[,,]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df  &lt;- df [(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size=9, replace=F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line()+
  facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + 
 ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) +
  xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
</div>
<div id="club-2-5" class="section level3">
<h3>Club 2</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[2]] # grab club

# check within-person variability of running frequency
# absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[,,]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df  &lt;- df [(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size=9, replace=F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line()+
  facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + 
 ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) +
  xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
</div>
<div id="club-3-5" class="section level3">
<h3>Club 3</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[3]] # grab club

# check within-person variability of running frequency
# absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[,,]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df  &lt;- df [(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size=9, replace=F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line()+
  facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + 
   ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) +
  xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-32-1.png" width="672" /></p>
</div>
<div id="club-4-5" class="section level3">
<h3>Club 4</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[4]] # grab club

# check within-person variability of running frequency
# absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[,,]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df  &lt;- df [(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size=9, replace=F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line()+
  facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + 
 ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) +
  xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-33-1.png" width="672" /></p>
</div>
<div id="club-5-5" class="section level3">
<h3>Club 5</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[5]] # grab club

# check within-person variability of running frequency
# absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[,,]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df  &lt;- df [(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size=9, replace=F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line()+
  facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + 
  ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) +
  xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-34-1.png" width="672" /></p>
</div>
</div>
<div id="section-9" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>There seems to be ‘sufficient’ within-person variability in running
behavior, at least in frequency.</p>
<hr />
</div>
</div>
<div id="correlation-between-frequency-and-volume"
class="section level1">
<h1>Correlation between frequency and volume</h1>
<p>Let’s plot the relation between frequency in times per week and
volume in hours per week. We also calculate Kendall’s tau-b, i.e. a
non-parametric measure of correlation on ranks (cf. <span
class="citation">Khamis (2008)</span>).</p>
<div id="section-10" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade"></h2>
<div id="club-1-6" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code>df &lt;- clubdata[[1]] # grab club 
df &lt;- data.frame(x = as.matrix(df$time_run), y = as.matrix(df$freq_run))

c &lt;- cor.test(df$x, df$y, method=&quot;kendall&quot;)

plot(df, type=&quot;b&quot;, 
     main = &quot;Relation between weekly running variables: frequency and (half) hours&quot;,
     sub = &quot;Note: running frequency capped with a maximum of 7, hours with a maximum of 7&quot;,
     xlab = &quot;Hours per week&quot;, ylab = &quot;sessions per week&quot;,
     col=&quot;blue&quot;, lwd=c(1,rep(6,10000))) + 
  text(x = 1.7, y = 5, round(c$estimate, digits=2)) +
  text(x = .7, y = 5, &quot;Kendall&#39;s tau-b =&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-35-1.png" width="672" /></p>
<pre class="test2"><code>#&gt; integer(0)</code></pre>
</div>
<div id="club-2-6" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code>df &lt;- clubdata[[2]] # grab club 
df &lt;- data.frame(x = as.matrix(df$time_run), y = as.matrix(df$freq_run))
c &lt;- cor.test(df$x,df$y,method=&quot;kendall&quot;)

plot(df, type=&quot;b&quot;, 
     main = &quot;Relation between weekly running variables: frequency and hours&quot;,
     sub = &quot;Note: running frequency capped with a maximum of 7, hours with a maximum of 7&quot;,
     xlab = &quot;hours per week&quot;, ylab = &quot;sessions per week&quot;,
     col=&quot;blue&quot;, lwd=c(1,rep(6,10000))) + 
  text(x = 1.7, y = 5, round(c$estimate, digits=2)) +
  text(x = .7, y = 5, &quot;Kendall&#39;s tau-b =&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-36-1.png" width="672" /></p>
<pre class="test2"><code>#&gt; integer(0)</code></pre>
</div>
<div id="club-3-6" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code>df &lt;- clubdata[[3]] # grab club 
df &lt;- data.frame(x = as.matrix(df$time_run), y = as.matrix(df$freq_run))
c &lt;- cor.test(df$x,df$y,method=&quot;kendall&quot;)

plot(df, type=&quot;b&quot;, 
     main = &quot;Relation between weekly running variables: frequency and hours&quot;,
     sub = &quot;Note: running frequency capped with a maximum of 7, hours with a maximum of 7&quot;,
     xlab = &quot;hours per week&quot;, ylab = &quot;sessions per week&quot;,
     col=&quot;blue&quot;, lwd=c(1,rep(6,10000))) + 
  text(x = 1.7, y = 5, round(c$estimate, digits=2)) +
  text(x = .7, y = 5, &quot;Kendall&#39;s tau-b =&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-37-1.png" width="672" /></p>
<pre class="test2"><code>#&gt; integer(0)</code></pre>
</div>
<div id="club-4-6" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code>df &lt;- clubdata[[4]] # grab club 
df &lt;- data.frame(x = as.matrix(df$time_run), y = as.matrix(df$freq_run))
c &lt;- cor.test(df$x,df$y,method=&quot;kendall&quot;)

plot(df, type=&quot;b&quot;, 
     main = &quot;Relation between weekly running variables: frequency and hours&quot;,
     sub = &quot;Note: running frequency capped with a maximum of 7, hours with a maximum of 7&quot;,
     xlab = &quot;hours per week&quot;, ylab = &quot;sessions per week&quot;,
     col=&quot;blue&quot;, lwd=c(1,rep(6,10000))) + 
  text(x = 1.5, y = 5, round(c$estimate, digits=2)) +
  text(x = .7, y = 5, &quot;Kendall&#39;s tau-b =&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-38-1.png" width="672" /></p>
<pre class="test2"><code>#&gt; integer(0)</code></pre>
</div>
<div id="club-5-6" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code>df &lt;- clubdata[[5]] # grab club 
df &lt;- data.frame(x = as.matrix(df$time_run), y = as.matrix(df$freq_run))
c &lt;- cor.test(df$x,df$y,method=&quot;kendall&quot;)

plot(df, type=&quot;b&quot;, 
     main = &quot;Relation between weekly running variables: frequency and hours&quot;,
     sub = &quot;Note: running frequency capped with a maximum of 7, hours with a maximum of 7&quot;,
     xlab = &quot;hours per week&quot;, ylab = &quot;sessions per week&quot;,
     col=&quot;blue&quot;, lwd=c(1,rep(6,10000))) + 
  text(x = 2, y = 7, round(c$estimate, digits=2)) +
  text(x = .7, y = 7, &quot;Kendall&#39;s tau-b =&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-39-1.png" width="672" /></p>
<pre class="test2"><code>#&gt; integer(0)</code></pre>
</div>
</div>
<div id="section-11" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>Although frequency and duration are strongly related, there is some
invariance.</p>
<hr />
<p><br></p>
</div>
</div>
<div id="network-autocorrelation" class="section level1">
<h1>Network autocorrelation</h1>
<div id="section-12" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade"></h2>
<p>We have now covered the sport activity levels of our club-athletes,
and the extent to which kudos-associations are segregated along gender.
Last, we will explore if kudos-ties are also segregated along activity
levels. Or in other words: do people with similar activity levels tend
to socialize to a greater extent - by exchanging kudos - even when
taking into account the opportunity structures for ‘interacting’ with
(dis)similar others?</p>
<p>We use Moran’s I spatial autocorrelation measure for this, which is
the correlation between the behavioral score of actor <em>i</em> and the
(total/mean) behavioral score of alters <em>j</em> to whom <em>i</em> is
connected <strong>directly</strong>. We also calculated Moran’s I by
including the behavioral scores of the actors <em>h</em> to whom
<em>i</em> is indirectly tied, and used the negative exponential
function as described by <span class="citation">Chen (2013)</span> as a
distance-decay function for assigning weights.</p>
<div id="club-1-7" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code>df &lt;- clubdata[[1]] # grab club 

# get behavioral data
# at time t=1
t=1
freq1 &lt;- df$freq_run[,,t] # running frequencies wave 1
vol1 &lt;- df$time_run[,,t] # running volume wave 1

# exclude NAs 
na &lt;- which(is.na(freq1))
freq1 &lt;- freq1[-na]
vol1 &lt;- vol1[-na]

# get kudos net
knet1 &lt;- df$kudo[,,t]
# exclude NAs
knet1 &lt;- knet1[-na,-na]

# as network object
knet1 &lt;- network::as.network(knet1)

# we include geodistances: shortest path lengths from i to j
geodistances &lt;- sna::geodist(knet1, count.paths=T)
geodistances &lt;- geodistances$gdist 

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(geodistances) &lt;- Inf

# first calculate Moran&#39;s i for alters at distance 1.
weights1 &lt;- geodistances == 1

# and use the negative exponential distance-decay function
weights2 &lt;- exp(-geodistances)

# calculate Moran&#39;s I
# for distance-1 and with distance decay, in the kudos network, for frequency and volume  respectively
# we do not row standardize!
Mfreq &lt;- fMoran.I(freq1, scaled = FALSE, weight = weights1, na.rm = TRUE, rowstandardize = FALSE)
Mfreq_distd &lt;- fMoran.I(freq1, scaled = FALSE, weight = weights2, na.rm = TRUE, rowstandardize = FALSE)

Mvol &lt;- fMoran.I(vol1, scaled = FALSE, weight = weights1, na.rm = TRUE, rowstandardize = FALSE)
Mvol_distd &lt;- fMoran.I(vol1, scaled = FALSE, weight = weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results
# 1. frequency
f_mat &lt;- matrix(NA, nrow=2, ncol=4)

f_mat[1,1] &lt;- Mfreq$observed
f_mat[1,2] &lt;- Mfreq$expected
f_mat[1,3] &lt;- Mfreq$sd
f_mat[1,4] &lt;- Mfreq$p.value
f_mat[2,1] &lt;- Mfreq_distd$observed
f_mat[2,2] &lt;- Mfreq_distd$expected
f_mat[2,3] &lt;- Mfreq_distd$sd
f_mat[2,4] &lt;- Mfreq_distd$p.value

# 2. volume
v_mat &lt;- matrix(NA, nrow=2, ncol=4)
v_mat[1,1] &lt;- Mvol$observed
v_mat[1,2] &lt;- Mvol$expected
v_mat[1,3] &lt;- Mvol$sd
v_mat[1,4] &lt;- Mvol$p.value
v_mat[2,1] &lt;- Mvol_distd$observed
v_mat[2,2] &lt;- Mvol_distd$expected
v_mat[2,3] &lt;- Mvol_distd$sd
v_mat[2,4] &lt;- Mvol_distd$p.value

colnames(f_mat) &lt;- colnames(v_mat) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(f_mat) &lt;- rownames(v_mat) &lt;- c(&quot;direct kudos ties&quot;, &quot;direct and indirect kudos ties (distance-decay)&quot;)

knitr::kable(f_mat, digits=2, &quot;html&quot;, caption=&quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
-0.04
</td>
<td style="text-align:right;">
0.13
</td>
<td style="text-align:right;">
0.66
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.00
</td>
<td style="text-align:right;">
-0.04
</td>
<td style="text-align:right;">
0.08
</td>
<td style="text-align:right;">
0.57
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(v_mat, digits=2, &quot;html&quot;, caption=&quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
-0.04
</td>
<td style="text-align:right;">
0.13
</td>
<td style="text-align:right;">
0.80
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
-0.04
</td>
<td style="text-align:right;">
0.08
</td>
<td style="text-align:right;">
0.71
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-2-7" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code>df &lt;- clubdata[[2]] # grab club 

# get behavioral data
# at time t=1
t=1
freq1 &lt;- df$freq_run[,,t] # running frequencies wave 1
vol1 &lt;- df$time_run[,,t] # running volume wave 1

# exclude NAs 
na &lt;- which(is.na(freq1))
freq1 &lt;- freq1[-na]
vol1 &lt;- vol1[-na]

# get kudos net
knet1 &lt;- df$kudo[,,t]
# exclude NAs
knet1 &lt;- knet1[-na,-na]

# as network object
knet1 &lt;- network::as.network(knet1)

# we include geodistances: shortest path lengths from i to j
geodistances &lt;- sna::geodist(knet1, count.paths=T)
geodistances &lt;- geodistances$gdist 

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(geodistances) &lt;- Inf

# first calculate Moran&#39;s i for alters at distance 1.
weights1 &lt;- geodistances == 1

# and use the negative exponential distance-decay function
weights2 &lt;- exp(-geodistances)

# calculate Moran&#39;s I
# for distance-1 and with distance decay, in the kudos network, for frequency and volume  respectively
# we do not row standardize!
Mfreq &lt;- fMoran.I(freq1, scaled = FALSE, weight = weights1, na.rm = TRUE, rowstandardize = FALSE)
Mfreq_distd &lt;- fMoran.I(freq1, scaled = FALSE, weight = weights2, na.rm = TRUE, rowstandardize = FALSE)

Mvol &lt;- fMoran.I(vol1, scaled = FALSE, weight = weights1, na.rm = TRUE, rowstandardize = FALSE)
Mvol_distd &lt;- fMoran.I(vol1, scaled = FALSE, weight = weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results
# 1. frequency
f_mat &lt;- matrix(NA, nrow=2, ncol=4)

f_mat[1,1] &lt;- Mfreq$observed
f_mat[1,2] &lt;- Mfreq$expected
f_mat[1,3] &lt;- Mfreq$sd
f_mat[1,4] &lt;- Mfreq$p.value
f_mat[2,1] &lt;- Mfreq_distd$observed
f_mat[2,2] &lt;- Mfreq_distd$expected
f_mat[2,3] &lt;- Mfreq_distd$sd
f_mat[2,4] &lt;- Mfreq_distd$p.value

# 2. volume
v_mat &lt;- matrix(NA, nrow=2, ncol=4)
v_mat[1,1] &lt;- Mvol$observed
v_mat[1,2] &lt;- Mvol$expected
v_mat[1,3] &lt;- Mvol$sd
v_mat[1,4] &lt;- Mvol$p.value
v_mat[2,1] &lt;- Mvol_distd$observed
v_mat[2,2] &lt;- Mvol_distd$expected
v_mat[2,3] &lt;- Mvol_distd$sd
v_mat[2,4] &lt;- Mvol_distd$p.value

colnames(f_mat) &lt;- colnames(v_mat) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(f_mat) &lt;- rownames(v_mat) &lt;- c(&quot;direct kudos ties&quot;, &quot;direct and indirect kudos ties (distance-decay)&quot;)

knitr::kable(f_mat, digits=2, &quot;html&quot;, caption=&quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.17
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.04
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(v_mat, digits=2, &quot;html&quot;, caption=&quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.21
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.04
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.06
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-3-7" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code>df &lt;- clubdata[[3]] # grab club 

# get behavioral data
# at time t=1
t=1
freq1 &lt;- df$freq_run[,,t] # running frequencies wave 1
vol1 &lt;- df$time_run[,,t] # running volume wave 1

# exclude NAs 
na &lt;- which(is.na(freq1))
freq1 &lt;- freq1[-na]
vol1 &lt;- vol1[-na]

# get kudos net
knet1 &lt;- df$kudo[,,t]
# exclude NAs
knet1 &lt;- knet1[-na,-na]

# as network object
knet1 &lt;- network::as.network(knet1)

# we include geodistances: shortest path lengths from i to j
geodistances &lt;- sna::geodist(knet1, count.paths=T)
geodistances &lt;- geodistances$gdist 

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(geodistances) &lt;- Inf

# first calculate Moran&#39;s i for alters at distance 1.
weights1 &lt;- geodistances == 1

# and use the negative exponential distance-decay function
weights2 &lt;- exp(-geodistances)

# calculate Moran&#39;s I
# for distance-1 and with distance decay, in the kudos network, for frequency and volume  respectively
# we do not row standardize!
Mfreq &lt;- fMoran.I(freq1, scaled = FALSE, weight = weights1, na.rm = TRUE, rowstandardize = FALSE)
Mfreq_distd &lt;- fMoran.I(freq1, scaled = FALSE, weight = weights2, na.rm = TRUE, rowstandardize = FALSE)

Mvol &lt;- fMoran.I(vol1, scaled = FALSE, weight = weights1, na.rm = TRUE, rowstandardize = FALSE)
Mvol_distd &lt;- fMoran.I(vol1, scaled = FALSE, weight = weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results
# 1. frequency
f_mat &lt;- matrix(NA, nrow=2, ncol=4)

f_mat[1,1] &lt;- Mfreq$observed
f_mat[1,2] &lt;- Mfreq$expected
f_mat[1,3] &lt;- Mfreq$sd
f_mat[1,4] &lt;- Mfreq$p.value
f_mat[2,1] &lt;- Mfreq_distd$observed
f_mat[2,2] &lt;- Mfreq_distd$expected
f_mat[2,3] &lt;- Mfreq_distd$sd
f_mat[2,4] &lt;- Mfreq_distd$p.value

# 2. volume
v_mat &lt;- matrix(NA, nrow=2, ncol=4)
v_mat[1,1] &lt;- Mvol$observed
v_mat[1,2] &lt;- Mvol$expected
v_mat[1,3] &lt;- Mvol$sd
v_mat[1,4] &lt;- Mvol$p.value
v_mat[2,1] &lt;- Mvol_distd$observed
v_mat[2,2] &lt;- Mvol_distd$expected
v_mat[2,3] &lt;- Mvol_distd$sd
v_mat[2,4] &lt;- Mvol_distd$p.value

colnames(f_mat) &lt;- colnames(v_mat) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(f_mat) &lt;- rownames(v_mat) &lt;- c(&quot;direct kudos ties&quot;, &quot;direct and indirect kudos ties (distance-decay)&quot;)

knitr::kable(f_mat, digits=2, &quot;html&quot;, caption=&quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.07
</td>
<td style="text-align:right;">
0.63
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.02
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
0.28
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(v_mat, digits=2, &quot;html&quot;, caption=&quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.16
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.07
</td>
<td style="text-align:right;">
0.02
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.07
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
0.01
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-4-7" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code>df &lt;- clubdata[[4]] # grab club 

# get behavioral data
# at time t=1
t=1
freq1 &lt;- df$freq_run[,,t] # running frequencies wave 1
vol1 &lt;- df$time_run[,,t] # running volume wave 1

# exclude NAs 
na &lt;- which(is.na(freq1))
freq1 &lt;- freq1[-na]
vol1 &lt;- vol1[-na]

# get kudos net
knet1 &lt;- df$kudo[,,t]
# exclude NAs
knet1 &lt;- knet1[-na,-na]

# as network object
knet1 &lt;- network::as.network(knet1)

# we include geodistances: shortest path lengths from i to j
geodistances &lt;- sna::geodist(knet1, count.paths=T)
geodistances &lt;- geodistances$gdist 

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(geodistances) &lt;- Inf

# first calculate Moran&#39;s i for alters at distance 1.
weights1 &lt;- geodistances == 1

# and use the negative exponential distance-decay function
weights2 &lt;- exp(-geodistances)

# calculate Moran&#39;s I
# for distance-1 and with distance decay, in the kudos network, for frequency and volume  respectively
# we do not row standardize!
Mfreq &lt;- fMoran.I(freq1, scaled = FALSE, weight = weights1, na.rm = TRUE, rowstandardize = FALSE)
Mfreq_distd &lt;- fMoran.I(freq1, scaled = FALSE, weight = weights2, na.rm = TRUE, rowstandardize = FALSE)

Mvol &lt;- fMoran.I(vol1, scaled = FALSE, weight = weights1, na.rm = TRUE, rowstandardize = FALSE)
Mvol_distd &lt;- fMoran.I(vol1, scaled = FALSE, weight = weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results
# 1. frequency
f_mat &lt;- matrix(NA, nrow=2, ncol=4)

f_mat[1,1] &lt;- Mfreq$observed
f_mat[1,2] &lt;- Mfreq$expected
f_mat[1,3] &lt;- Mfreq$sd
f_mat[1,4] &lt;- Mfreq$p.value
f_mat[2,1] &lt;- Mfreq_distd$observed
f_mat[2,2] &lt;- Mfreq_distd$expected
f_mat[2,3] &lt;- Mfreq_distd$sd
f_mat[2,4] &lt;- Mfreq_distd$p.value

# 2. volume
v_mat &lt;- matrix(NA, nrow=2, ncol=4)
v_mat[1,1] &lt;- Mvol$observed
v_mat[1,2] &lt;- Mvol$expected
v_mat[1,3] &lt;- Mvol$sd
v_mat[1,4] &lt;- Mvol$p.value
v_mat[2,1] &lt;- Mvol_distd$observed
v_mat[2,2] &lt;- Mvol_distd$expected
v_mat[2,3] &lt;- Mvol_distd$sd
v_mat[2,4] &lt;- Mvol_distd$p.value

colnames(f_mat) &lt;- colnames(v_mat) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(f_mat) &lt;- rownames(v_mat) &lt;- c(&quot;direct kudos ties&quot;, &quot;direct and indirect kudos ties (distance-decay)&quot;)

knitr::kable(f_mat, digits=2, &quot;html&quot;, caption=&quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
-0.31
</td>
<td style="text-align:right;">
-0.17
</td>
<td style="text-align:right;">
0.26
</td>
<td style="text-align:right;">
0.57
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
-0.34
</td>
<td style="text-align:right;">
-0.17
</td>
<td style="text-align:right;">
0.25
</td>
<td style="text-align:right;">
0.49
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(v_mat, digits=2, &quot;html&quot;, caption=&quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
-0.28
</td>
<td style="text-align:right;">
-0.17
</td>
<td style="text-align:right;">
0.28
</td>
<td style="text-align:right;">
0.69
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
-0.30
</td>
<td style="text-align:right;">
-0.17
</td>
<td style="text-align:right;">
0.28
</td>
<td style="text-align:right;">
0.63
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-5-7" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code>df &lt;- clubdata[[5]] # grab club 

# get behavioral data
# at time t=1
t=1
freq1 &lt;- df$freq_run[,,t] # running frequencies wave 1
vol1 &lt;- df$time_run[,,t] # running volume wave 1

# exclude NAs 
na &lt;- which(is.na(freq1))
freq1 &lt;- freq1[-na]
vol1 &lt;- vol1[-na]

# get kudos net
knet1 &lt;- df$kudo[,,t]
# exclude NAs
knet1 &lt;- knet1[-na,-na]

# as network object
knet1 &lt;- network::as.network(knet1)

# we include geodistances: shortest path lengths from i to j
geodistances &lt;- sna::geodist(knet1, count.paths=T)
geodistances &lt;- geodistances$gdist 

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(geodistances) &lt;- Inf

# first calculate Moran&#39;s i for alters at distance 1.
weights1 &lt;- geodistances == 1

# and use the negative exponential distance-decay function
weights2 &lt;- exp(-geodistances)

# calculate Moran&#39;s I
# for distance-1 and with distance decay, in the kudos network, for frequency and volume  respectively
# we do not row standardize!
Mfreq &lt;- fMoran.I(freq1, scaled = FALSE, weight = weights1, na.rm = TRUE, rowstandardize = FALSE)
Mfreq_distd &lt;- fMoran.I(freq1, scaled = FALSE, weight = weights2, na.rm = TRUE, rowstandardize = FALSE)

Mvol &lt;- fMoran.I(vol1, scaled = FALSE, weight = weights1, na.rm = TRUE, rowstandardize = FALSE)
Mvol_distd &lt;- fMoran.I(vol1, scaled = FALSE, weight = weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results
# 1. frequency
f_mat &lt;- matrix(NA, nrow=2, ncol=4)

f_mat[1,1] &lt;- Mfreq$observed
f_mat[1,2] &lt;- Mfreq$expected
f_mat[1,3] &lt;- Mfreq$sd
f_mat[1,4] &lt;- Mfreq$p.value
f_mat[2,1] &lt;- Mfreq_distd$observed
f_mat[2,2] &lt;- Mfreq_distd$expected
f_mat[2,3] &lt;- Mfreq_distd$sd
f_mat[2,4] &lt;- Mfreq_distd$p.value

# 2. volume
v_mat &lt;- matrix(NA, nrow=2, ncol=4)
v_mat[1,1] &lt;- Mvol$observed
v_mat[1,2] &lt;- Mvol$expected
v_mat[1,3] &lt;- Mvol$sd
v_mat[1,4] &lt;- Mvol$p.value
v_mat[2,1] &lt;- Mvol_distd$observed
v_mat[2,2] &lt;- Mvol_distd$expected
v_mat[2,3] &lt;- Mvol_distd$sd
v_mat[2,4] &lt;- Mvol_distd$p.value

colnames(f_mat) &lt;- colnames(v_mat) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(f_mat) &lt;- rownames(v_mat) &lt;- c(&quot;direct kudos ties&quot;, &quot;direct and indirect kudos ties (distance-decay)&quot;)

knitr::kable(f_mat, digits=2, &quot;html&quot;, caption=&quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.21
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.09
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.02
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(v_mat, digits=2, &quot;html&quot;, caption=&quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;% 
  kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.25
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.10
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.02
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="section-13" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>Here, the Moran’s I statistic tests whether club members that are
<em>closer to one another</em> (i.e., having a shorter geodesic/path
length), are more a similar with respect to their behavior, under the
null hypothesis that behavior is ‘randomly distributed’ among the club
members.</p>
<p>We observe that, indeed, kudos-ties that are closer to one another
are more alike, with respect to running. Autocorrelation was stronger
without the distance-decay function, which suggests that especially
close alters (with path length one) are similar.</p>
<p><br></p>
<hr />
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-chen2013" class="csl-entry">
Chen, Yanguang. 2013. <span>“New Approaches for Calculating Moran’s
Index of Spatial Autocorrelation.”</span> <em>PLOS ONE</em> 8 (7): –. <a
href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0068336">https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0068336</a>.
</div>
<div id="ref-khamis" class="csl-entry">
Khamis, Harry. 2008. <span>“Measures of Association: How to
Choose?”</span> <em>Journal of Diagnostic Medical Sonography</em> 24
(3): 155–62. <a
href="https://doi:10.1177/8756479308317006">doi:10.1177/8756479308317006</a>.
</div>
</div>
</div>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIkRlc2NyaXB0aXZlIHN0YXRpc3RpY3MiDQpkYXRlOiAiTGFzdCBjb21waWxlZCBvbiBgciBmb3JtYXQoU3lzLnRpbWUoKSwgJyVCLCAlWScpYCINCmJpYmxpb2dyYXBoeTogcmVmZXJlbmNlcy5iaWINCm91dHB1dDoNCiAgaHRtbF9kb2N1bWVudDoNCiAgICBjc3M6IHR3ZWFrcy5jc3MNCiAgICB0b2M6IHRydWUNCiAgICB0b2NfZmxvYXQ6IHRydWUNCiAgICBjb2xsYXBzZWQ6IGZhbHNlDQogICAgbnVtYmVyX3NlY3Rpb25zOiBmYWxzZQ0KICAgIHRvY19kZXB0aDogMQ0KICAgIGNvZGVfZm9sZGluZzogc2hvdw0KICAgIGNvZGVfZG93bmxvYWQ6IHllcw0KLS0tDQoNCg0KYGBge3IsIGdsb2JhbHNldHRpbmdzLCBlY2hvPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQ0KbGlicmFyeShrbml0cikNCmtuaXRyOjpvcHRzX2NodW5rJHNldChlY2hvID0gVFJVRSkNCm9wdHNfY2h1bmskc2V0KHRpZHkub3B0cz1saXN0KHdpZHRoLmN1dG9mZj0xMDApLHRpZHk9VFJVRSwgd2FybmluZyA9IEZBTFNFLCBtZXNzYWdlID0gRkFMU0UsY29tbWVudCA9ICIjPiIsIGNhY2hlPVRSVUUsIGNsYXNzLnNvdXJjZT1jKCJ0ZXN0IiksIGNsYXNzLm91dHB1dD1jKCJ0ZXN0MiIpKQ0Kb3B0aW9ucyh3aWR0aCA9IDEwMCkNCnJnbDo6c2V0dXBLbml0cigpDQoNCg0KDQpjb2xvcml6ZSA8LSBmdW5jdGlvbih4LCBjb2xvcikge3NwcmludGYoIjxzcGFuIHN0eWxlPSdjb2xvcjogJXM7Jz4lczwvc3Bhbj4iLCBjb2xvciwgeCkgfQ0KDQpgYGANCg0KYGBge3Iga2xpcHB5LCBlY2hvPUZBTFNFLCBpbmNsdWRlPVRSVUV9DQprbGlwcHk6OmtsaXBweShwb3NpdGlvbiA9IGMoJ3RvcCcsICdyaWdodCcpKQ0KI2tsaXBweTo6a2xpcHB5KGNvbG9yID0gJ2RhcmtyZWQnKQ0KI2tsaXBweTo6a2xpcHB5KHRvb2x0aXBfbWVzc2FnZSA9ICdDbGljayB0byBjb3B5JywgdG9vbHRpcF9zdWNjZXNzID0gJ0RvbmUnKQ0KYGBgDQoNCg0KDQotLS0NCg0KV2Ugd2lsbCB1c2UgdGhlIFJTaWVuYSBvYmplY3RzIG9mIGNsdWJzIHRvIGRlc2NyaWJlIHRoZSBrdWRvcyBuZXR3b3JrcywgY29uc3RhbnQgY292YXJpYXRlcyBhbmQgYmVoYXZpb3JhbCB2YXJpYWJsZXMuIA0KDQo8YnI+DQoNCiMgR2V0dGluZyBzdGFydGVkDQoNCkNsZWFuIHRoZSB3b3JraW5nIGVudmlyb25tZW50IGFuZCBsb2FkIGluIHRoZSBjbHViIGRhdGEuDQoNCmBgYHtyLCBhdHRyLm91dHB1dD0nc3R5bGU9Im1heC1oZWlnaHQ6IDIwMHB4OyInfQ0KIyBjbGVhbiB0aGUgd29ya2luZyBlbnZpcm9ubWVudCANCnJtIChsaXN0ID0gbHMoICkpDQoNCiMgbG9hZCB0aGUgUlNpZW5hIG9iamVjdHMNCmxvYWQoImNsdWJkYXRhX3JzaWVuYV9mcmVxLlJEYXRhIikNCmxvYWQoImNsdWJkYXRhX3JzaWVuYV92b2wuUkRhdGEiKQ0KDQojIGFuZCB0aGUgbGlzdCBjb250YWluaW5nIGNsdWIgZGF0YS1zZXRlcw0KbG9hZCgiY2x1YmRhdGEuUkRhdGEiKQ0KDQpgYGANCg0KPGJyPg0KDQojIyBnZW5lcmFsIGN1c3RvbSBmdW5jdGlvbnMNCg0KLSBgZnBhY2thZ2UuY2hlY2tgOiBDaGVjayBpZiBwYWNrYWdlcyBhcmUgaW5zdGFsbGVkIChhbmQgaW5zdGFsbCBpZiBub3QpIGluIFIgKFtzb3VyY2VdKGh0dHBzOi8vdmJhbGlnYS5naXRodWIuaW8vdmVyaWZ5LXRoYXQtci1wYWNrYWdlcy1hcmUtaW5zdGFsbGVkLWFuZC1sb2FkZWQvKSkNCi0gYGZsb2FkLlJgOiBmdW5jdGlvbiB0byBsb2FkIFItb2JqZWN0cyB1bmRlciBuZXcgbmFtZXMuDQoNCmBgYHtyLCByZXN1bHRzPSdoaWRlJ30NCg0KZnBhY2thZ2UuY2hlY2sgPC0gZnVuY3Rpb24ocGFja2FnZXMpIHsNCiAgICBsYXBwbHkocGFja2FnZXMsIEZVTiA9IGZ1bmN0aW9uKHgpIHsNCiAgICAgICAgaWYgKCFyZXF1aXJlKHgsIGNoYXJhY3Rlci5vbmx5ID0gVFJVRSkpIHsNCiAgICAgICAgICAgIGluc3RhbGwucGFja2FnZXMoeCwgZGVwZW5kZW5jaWVzID0gVFJVRSkNCiAgICAgICAgICAgIGxpYnJhcnkoeCwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKQ0KICAgICAgICB9DQogICAgfSkNCn0NCg0KZmxvYWQuUiAgPC0gZnVuY3Rpb24oZmlsZU5hbWUpew0KICBsb2FkKGZpbGVOYW1lKQ0KICBnZXQobHMoKVtscygpICE9ICJmaWxlTmFtZSJdKQ0KfQ0KDQpgYGANCg0KDQojIyBuZWNlc3NhcnkgcGFja2FnZXMNCg0KV2UgaW5zdGFsbCBhbmQgbG9hZCB0aGUgcGFja2FnZXMgd2UgbmVlZCBsYXRlciBvbjoNCg0KLSBgUlNpZW5hYDogUlNpZW5hIG1vZGVscywgc29tZSBkZXNjcmlwdGl2ZXMgb24gbmV0d29yayBsZXZlbA0KLSBgaWdyYXBoYDogRGVzY3JpcHRpdmVzIChkeWFkL3RyaWFkIGNlbnN1cywgZGVncmVlcykNCi0gYHRpZHl2ZXJzZWANCi0gYHRpZHlyYDogZm9yIHRpZHkgZGF0YQ0KLSBgbW9tZW50c2A6IGZvciBjYWxjdWxhdGluZyBzdGF0aXN0aWNzIChlLmcuLCBrdXJ0b3Npcywgc3RhbmRhcmQgZXJyb3IpDQotIGBkcGx5cmA6IGZvciBkYXRhIG1hbmlwdWxhdGlvbg0KLSBgZ2dwbG90MmA6IGZvciBkYXRhIHZpc3VhbGl6YXRpb24NCi0gYGZvcmNhdHNgOiBmb3IgaGFuZGxpbmcgY2F0ZWdvcmljYWwgdmFyaWFibA0KLSBga25pdHJgOiBmb3IgZ2VuZXJhdGluZyB0YWJsZXMNCi0gYGthYmxlRXh0cmFgOiBmb3IgbWFuaXB1bGF0aW5nIHRhYmxlcw0KLSBgbmV0d29ya2A6IGZvciBuZXR3b3JrIGFuYWx5c2lzDQotIGBzbmFgOiBmb3IgbmV0d29yayBhbmFseXNpcw0KDQoNCg0KYGBge3IgcGFja2FnZXMsIHJlc3VsdHM9J2hpZGUnfQ0KDQpwYWNrYWdlcyA9IGMoIlJTaWVuYSIsICJpZ3JhcGgiLCAidGlkeXZlcnNlIiwgInRpZHlyIiwgIm1vbWVudHMiLCAiZHBseXIiLCAiZ2dwbG90MiIsICJmb3JjYXRzIiwgImtuaXRyIiwgImthYmxlRXh0cmEiLCAibmV0d29yayIsICJzbmEiKQ0KDQpmcGFja2FnZS5jaGVjayhwYWNrYWdlcykNCmBgYA0KDQoNCiMjIGFkZGl0aW9uYWwgZnVuY3Rpb25zIA0KDQpOb3cgZGVmaW5lIHNvbWUgYWRkaXRpb25hbCBmdW5jdGlvbnMgd2UgdXNlIGxhdGVyIG9uIHRvIGRlc2NyaWJlIG91ciBkYXRhIChzZWUgW3d3dy5qb2NoZW10b2xzbWEubmxdKGh0dHBzOi8vd3d3LmpvY2hlbXRvbHNtYS5ubC9jb3Vyc2VzL2NvbXBsZXRlLW5ldHdvcmtzL3NvY2lvNi8jZGVzY3JpcHRpdmUtc3RhdGlzdGljcykpLiAgDQoNCi0gYGZkZW5zaXR5YDogY2FsY3VsYXRlIGRlbnNpdHkgKGV4Y2x1ZGUgTkEgYW5kIHN0cnVjdHVyYWwgemVyb3MpICANCi0gYGZkZW5zaXR5aW50cmFgOiBjYWxjdWxhdGUgZGVuc2l0eSB3aXRoaW4gZ3JvdXAgKGV4Y2x1ZGUgTkEgYW5kIHN0cnVjdHVyYWwgemVyb3MpICANCi0gYGZkZW5zaXR5aW50ZXJgOiBjYWxjdWxhdGUgZGVuc2l0eSBiZXR3ZWVuIGdyb3VwcyAoZXhjbHVkZSBOQSBhbmQgc3RydWN0dXJhbCB6ZXJvcykgIA0KLSBgZmhvbW9tYXRgOiBiYXNlZCBvbiBlZ28vYWx0ZXIgY2hhcmFjdGVyaXN0aWNzLCBjb25zdHJ1Y3QgZHlhZCBjaGFyYWN0ZXJpc3RpYyB3aGV0aGVyIG9yIG5vdCBlZ28vYWx0ZXIgYXJlIHNhbWUgDQotIGBmbmR5YWRzYDogY2FsY3VsYXRlIGFsbCB2YWxpZCBkeWFkcyAobm8gTkEgb3Igc3RydWN0dXJhbCB6ZXJvcykgIA0KLSBgZnNjb2xuZXRgOiBjYWxjdWxhdGUgQ29sZW1hbidzIHNlZ3JlZ2F0aW9uIGluZGV4IG9uIHRoZSBuZXR3b3JrLWxldmVsICANCi0gYGZNb3Jhbi5pYDogY2FsY3VsYXRlIE1vcmFuJ3MgSSBzcGF0aWFsIGF1dG9jb3JyZWxhdGlvbiBzdGF0aXN0aWMgKHNlZSBbaGVyZV0oaHR0cHM6Ly93d3cuam9jaGVtdG9sc21hLm5sL2NvdXJzZXMvY29tcGxldGUtbmV0d29ya3Mvc29jaW83LyNtb3JhbnMtYXV0b2NvcnJlbGF0aW9uLWZvci1vdXRnb2luZy10aWVzLXJzaWVuYS1idWlsZC1pbi1kYXRhc2V0KSkNCg0KDQoNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KIyBkZW5zaXR5OiBvYnNlcnZlZCByZWxhdGlvbnMgZGl2aWRlZCBieSBwb3NzaWJsZSByZWxhdGlvbnMNCmZkZW5zaXR5IDwtIGZ1bmN0aW9uKHgpIHsNCiAgICAjIHggaXMgeW91ciBub21pbmF0aW9uIG5ldHdvcmsgbWFrZSBzdXJlIGRpYWdvbmFsIGNlbGxzIGFyZSBOQQ0KICAgIGRpYWcoeCkgPC0gTkENCiAgICAjIHRha2UgY2FyZSBvZiBSU2llbmEgc3RydWN0dXJhbCB6ZXJvcywgc2V0IGFzIG1pc3NpbmcuDQogICAgeFt4ID09IDEwXSA8LSBOQQ0KICAgIHN1bSh4ID09IDEsIG5hLnJtID0gVCkvKHN1bSh4ID09IDEgfCB4ID09IDAsIG5hLnJtID0gVCkpDQp9DQoNCiMgY2FsY3VsYXRlIGludHJhZ3JvdXAgZGVuc2l0eQ0KZmRlbnNpdHlpbnRyYSA8LSBmdW5jdGlvbih4LCBBKSB7DQogICAgIyBBIGlzIG1hdHJpeCBpbmRpY2F0aW5nIHdoZXRoZXIgbm9kZXMgaW4gZHlhZCBoYXZlIHNhbWUgbm9kZSBhdHRyaWJ1dGVzDQogICAgZGlhZyh4KSA8LSBOQQ0KICAgIHhbeCA9PSAxMF0gPC0gTkENCiAgICBkaWFnKEEpIDwtIE5BDQogICAgc3VtKHggPT0gMSAmIEEgPT0gMSwgbmEucm0gPSBUKS8oc3VtKCh4ID09IDEgfCB4ID09IDApICYgQSA9PSAxLCBuYS5ybSA9IFQpKQ0KfQ0KDQojIGNhbGN1bGF0ZSBpbnRyYWdyb3VwIGRlbnNpdHkNCmZkZW5zaXR5aW50ZXIgPC0gZnVuY3Rpb24oeCwgQSkgew0KICAgICMgQSBpcyBtYXRyaXggaW5kaWNhdGluZyB3aGV0aGVyIG5vZGVzIGluIGR5YWQgaGF2ZSBzYW1lIG5vZGUgYXR0cmlidXRlcw0KICAgIGRpYWcoeCkgPC0gTkENCiAgICB4W3ggPT0gMTBdIDwtIE5BDQogICAgZGlhZyhBKSA8LSBOQQ0KICAgIHN1bSh4ID09IDEgJiBBICE9IDEsIG5hLnJtID0gVCkvKHN1bSgoeCA9PSAxIHwgeCA9PSAwKSAmIEEgIT0gMSwgbmEucm0gPSBUKSkNCn0NCg0KIyBjb25zdHJ1Y3QgZHlhZCBjaGFyYWN0ZXJpc3RpYyB3aGV0aGVyIG5vZGVzIGFyZSBzaW1pbGFyL2hvbW9nZW5vdXMNCmZob21vbWF0IDwtIGZ1bmN0aW9uKHgpIHsNCiAgICAjIHggaXMgYSB2ZWN0b3Igb2Ygbm9kZS1jb3ZhcmlhdGUNCiAgICB4bWF0IDwtIG1hdHJpeCh4LCBucm93ID0gbGVuZ3RoKHgpLCBuY29sID0gbGVuZ3RoKHgpKQ0KICAgIHhtYXR0IDwtIHQoeG1hdCkNCiAgICB4aG9tbyA8LSB4bWF0ID09IHhtYXR0DQogICAgcmV0dXJuKHhob21vKQ0KfQ0KDQojIGEgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGFsbCB2YWxpZCBkeWFkcy4NCmZuZHlhZHMgPC0gZnVuY3Rpb24oeCkgew0KICAgIGRpYWcoeCkgPC0gTkENCiAgICB4W3ggPT0gMTBdIDwtIE5BDQogICAgKHN1bSgoeCA9PSAxIHwgeCA9PSAwKSwgbmEucm0gPSBUKSkNCn0NCg0KIyBhIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBhbGwgdmFsaWQgaW50cmFncm91cGR5YWRzLg0KZm5keWFkczIgPC0gZnVuY3Rpb24oeCwgQSkgew0KICAgIGRpYWcoeCkgPC0gTkENCiAgICB4W3ggPT0gMTBdIDwtIE5BDQogICAgZGlhZyhBKSA8LSBOQQ0KICAgIChzdW0oKHggPT0gMSB8IHggPT0gMCkgJiBBID09IDEsIG5hLnJtID0gVCkpDQp9DQoNCg0KZnNjb2xuZXQgPC0gZnVuY3Rpb24obmV0d29yaywgY2NvdmFyKSB7DQogICAgIyBDYWxjdWxhdGUgY29sZW1hbiBvbiBuZXR3b3JrIGxldmVsOg0KICAgICMgaHR0cHM6Ly9yZWFkZXIuZWxzZXZpZXIuY29tL3JlYWRlci9zZC9waWkvUzAzNzg4NzMzMTQwMDAyMzk/dG9rZW49QTQyRjk5RkY2RTJCNzUwNDM2REQyQ0IwREI3QjFGNDFCREVDMTYwNTJBNDU2ODNDMDI2NDREQUY4ODIxNUEzMzc5NjM2QjJBQTE5N0I2NTk0MUQ2MzczRTlFMkVFNDEzDQogICAgDQogICAgZmhvbW9tYXQgPC0gZnVuY3Rpb24oeCkgew0KICAgICAgICB4bWF0IDwtIG1hdHJpeCh4LCBucm93ID0gbGVuZ3RoKHgpLCBuY29sID0gbGVuZ3RoKHgpKQ0KICAgICAgICB4bWF0dCA8LSB0KHhtYXQpDQogICAgICAgIHhob21vIDwtIHhtYXQgPT0geG1hdHQNCiAgICAgICAgcmV0dXJuKHhob21vKQ0KICAgIH0NCiAgICANCiAgICBmc3VtaW50cmEgPC0gZnVuY3Rpb24oeCwgQSkgew0KICAgICAgICAjIEEgaXMgbWF0cml4IGluZGljYXRpbmcgd2hldGhlciBub2RlcyBjb25zdGl0dXRpbmcgZHlhZCBoYXZlIHNhbWUgY2hhcmFjdGVyaXN0aWNzDQogICAgICAgIGRpYWcoeCkgPC0gTkENCiAgICAgICAgeFt4ID09IDEwXSA8LSBOQQ0KICAgICAgICBkaWFnKEEpIDwtIE5BDQogICAgICAgIHN1bSh4ID09IDEgJiBBID09IDEsIG5hLnJtID0gVCkNCiAgICB9DQogICAgDQogICAgIyBleHBlY2F0aW9uIHcqPXN1bV9nIHN1bV9pIChuaSgobmctMSkvKE4tMSkpKQ0KICAgIG5ldHdvcmtbbmV0d29yayA9PSAxMF0gPC0gTkENCiAgICBuaSA8LSByb3dTdW1zKG5ldHdvcmssIG5hLnJtID0gVCkNCiAgICBuZyA8LSBOQQ0KICAgIGZvciAoaSBpbiAxOmxlbmd0aChjY292YXIpKSB7DQogICAgICAgIG5nW2ldIDwtIHRhYmxlKGNjb3Zhcilbcm93bmFtZXModGFibGUoY2NvdmFyKSkgPT0gY2NvdmFyW2ldXQ0KICAgIH0NCiAgICBOIDwtIGxlbmd0aChjY292YXIpDQogICAgd2V4cCA8LSBzdW0obmkgKiAoKG5nIC0gMSkvKE4gLSAxKSksIG5hLnJtID0gVCkNCiAgICANCiAgICAjIHdnZzEgaG93IG1hbnkgaW50cmFncm91cCB0aWVzDQogICAgdyA8LSBmc3VtaW50cmEobmV0d29yaywgZmhvbW9tYXQoY2NvdmFyKSkNCiAgICANCiAgICBTY29sX25ldCA8LSBpZmVsc2UodyA+PSB3ZXhwLCAodyAtIHdleHApLyhzdW0obmksIG5hLnJtID0gVCkgLSB3ZXhwKSwgKHcgLSB3ZXhwKS93ZXhwKQ0KICAgIHJldHVybihTY29sX25ldCkNCn0NCg0KZk1vcmFuLkkgPC0gZnVuY3Rpb24oeCwgd2VpZ2h0LCBzY2FsZWQgPSBGQUxTRSwgbmEucm0gPSBGQUxTRSwgYWx0ZXJuYXRpdmUgPSAidHdvLnNpZGVkIiwgcm93c3RhbmRhcmRpemUgPSBUUlVFKSB7DQogICAgaWYgKHJvd3N0YW5kYXJkaXplKSB7DQogICAgICAgIGlmIChkaW0od2VpZ2h0KVsxXSAhPSBkaW0od2VpZ2h0KVsyXSkgDQogICAgICAgICAgICBzdG9wKCInd2VpZ2h0JyBtdXN0IGJlIGEgc3F1YXJlIG1hdHJpeCIpDQogICAgICAgIG4gPC0gbGVuZ3RoKHgpDQogICAgICAgIGlmIChkaW0od2VpZ2h0KVsxXSAhPSBuKSANCiAgICAgICAgICAgIHN0b3AoIid3ZWlnaHQnIG11c3QgaGF2ZSBhcyBtYW55IHJvd3MgYXMgb2JzZXJ2YXRpb25zIGluICd4JyIpDQogICAgICAgIGVpIDwtIC0xLyhuIC0gMSkNCiAgICAgICAgbmFzIDwtIGlzLm5hKHgpDQogICAgICAgIGlmIChhbnkobmFzKSkgew0KICAgICAgICAgICAgaWYgKG5hLnJtKSB7DQogICAgICAgICAgICAgICAgeCA8LSB4WyFuYXNdDQogICAgICAgICAgICAgICAgbiA8LSBsZW5ndGgoeCkNCiAgICAgICAgICAgICAgICB3ZWlnaHQgPC0gd2VpZ2h0WyFuYXMsICFuYXNdDQogICAgICAgICAgICB9IGVsc2Ugew0KICAgICAgICAgICAgICAgIHdhcm5pbmcoIid4JyBoYXMgbWlzc2luZyB2YWx1ZXM6IG1heWJlIHlvdSB3YW50ZWQgdG8gc2V0IG5hLnJtID0gVFJVRT8iKQ0KICAgICAgICAgICAgICAgIHJldHVybihsaXN0KG9ic2VydmVkID0gTkEsIGV4cGVjdGVkID0gZWksIHNkID0gTkEsIHAudmFsdWUgPSBOQSkpDQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgUk9XU1VNIDwtIHJvd1N1bXMod2VpZ2h0KQ0KICAgICAgICBST1dTVU1bUk9XU1VNID09IDBdIDwtIDENCiAgICAgICAgd2VpZ2h0IDwtIHdlaWdodC9ST1dTVU0NCiAgICAgICAgcyA8LSBzdW0od2VpZ2h0KQ0KICAgICAgICBtIDwtIG1lYW4oeCkNCiAgICAgICAgeSA8LSB4IC0gbQ0KICAgICAgICBjdiA8LSBzdW0od2VpZ2h0ICogeSAlbyUgeSkNCiAgICAgICAgdiA8LSBzdW0oeV4yKQ0KICAgICAgICBvYnMgPC0gKG4vcykgKiAoY3YvdikNCiAgICAgICAgaWYgKHNjYWxlZCkgew0KICAgICAgICAgICAgaS5tYXggPC0gKG4vcykgKiAoc2Qocm93U3Vtcyh3ZWlnaHQpICogeSkvc3FydCh2LyhuIC0gMSkpKQ0KICAgICAgICAgICAgb2JzIDwtIG9icy9pLm1heA0KICAgICAgICB9DQogICAgICAgIFMxIDwtIDAuNSAqIHN1bSgod2VpZ2h0ICsgdCh3ZWlnaHQpKV4yKQ0KICAgICAgICBTMiA8LSBzdW0oKGFwcGx5KHdlaWdodCwgMSwgc3VtKSArIGFwcGx5KHdlaWdodCwgMiwgc3VtKSleMikNCiAgICAgICAgcy5zcSA8LSBzXjINCiAgICAgICAgayA8LSAoc3VtKHleNCkvbikvKHYvbileMg0KICAgICAgICBzZGkgPC0gc3FydCgobiAqICgobl4yIC0gMyAqIG4gKyAzKSAqIFMxIC0gbiAqIFMyICsgMyAqIHMuc3EpIC0gayAqIChuICogKG4gLSAxKSAqIFMxIC0gMiAqIG4gKiANCiAgICAgICAgICAgIFMyICsgNiAqIHMuc3EpKS8oKG4gLSAxKSAqIChuIC0gMikgKiAobiAtIDMpICogcy5zcSkgLSAxLygobiAtIDEpXjIpKQ0KICAgICAgICBhbHRlcm5hdGl2ZSA8LSBtYXRjaC5hcmcoYWx0ZXJuYXRpdmUsIGMoInR3by5zaWRlZCIsICJsZXNzIiwgImdyZWF0ZXIiKSkNCiAgICAgICAgcHYgPC0gcG5vcm0ob2JzLCBtZWFuID0gZWksIHNkID0gc2RpKQ0KICAgICAgICBpZiAoYWx0ZXJuYXRpdmUgPT0gInR3by5zaWRlZCIpIA0KICAgICAgICAgICAgcHYgPC0gaWYgKG9icyA8PSBlaSkgDQogICAgICAgICAgICAgICAgMiAqIHB2IGVsc2UgMiAqICgxIC0gcHYpDQogICAgICAgIGlmIChhbHRlcm5hdGl2ZSA9PSAiZ3JlYXRlciIpIA0KICAgICAgICAgICAgcHYgPC0gMSAtIHB2DQogICAgICAgIGxpc3Qob2JzZXJ2ZWQgPSBvYnMsIGV4cGVjdGVkID0gZWksIHNkID0gc2RpLCBwLnZhbHVlID0gcHYpDQogICAgfSBlbHNlIHsNCiAgICAgICAgaWYgKGRpbSh3ZWlnaHQpWzFdICE9IGRpbSh3ZWlnaHQpWzJdKSANCiAgICAgICAgICAgIHN0b3AoIid3ZWlnaHQnIG11c3QgYmUgYSBzcXVhcmUgbWF0cml4IikNCiAgICAgICAgbiA8LSBsZW5ndGgoeCkNCiAgICAgICAgaWYgKGRpbSh3ZWlnaHQpWzFdICE9IG4pIA0KICAgICAgICAgICAgc3RvcCgiJ3dlaWdodCcgbXVzdCBoYXZlIGFzIG1hbnkgcm93cyBhcyBvYnNlcnZhdGlvbnMgaW4gJ3gnIikNCiAgICAgICAgZWkgPC0gLTEvKG4gLSAxKQ0KICAgICAgICBuYXMgPC0gaXMubmEoeCkNCiAgICAgICAgaWYgKGFueShuYXMpKSB7DQogICAgICAgICAgICBpZiAobmEucm0pIHsNCiAgICAgICAgICAgICAgICB4IDwtIHhbIW5hc10NCiAgICAgICAgICAgICAgICBuIDwtIGxlbmd0aCh4KQ0KICAgICAgICAgICAgICAgIHdlaWdodCA8LSB3ZWlnaHRbIW5hcywgIW5hc10NCiAgICAgICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgICAgICAgd2FybmluZygiJ3gnIGhhcyBtaXNzaW5nIHZhbHVlczogbWF5YmUgeW91IHdhbnRlZCB0byBzZXQgbmEucm0gPSBUUlVFPyIpDQogICAgICAgICAgICAgICAgcmV0dXJuKGxpc3Qob2JzZXJ2ZWQgPSBOQSwgZXhwZWN0ZWQgPSBlaSwgc2QgPSBOQSwgcC52YWx1ZSA9IE5BKSkNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAjIFJPV1NVTSA8LSByb3dTdW1zKHdlaWdodCkgUk9XU1VNW1JPV1NVTSA9PSAwXSA8LSAxIHdlaWdodCA8LSB3ZWlnaHQvUk9XU1VNDQogICAgICAgIHMgPC0gc3VtKHdlaWdodCkNCiAgICAgICAgbSA8LSBtZWFuKHgpDQogICAgICAgIHkgPC0geCAtIG0NCiAgICAgICAgY3YgPC0gc3VtKHdlaWdodCAqIHkgJW8lIHkpDQogICAgICAgIHYgPC0gc3VtKHleMikNCiAgICAgICAgb2JzIDwtIChuL3MpICogKGN2L3YpDQogICAgICAgIGlmIChzY2FsZWQpIHsNCiAgICAgICAgICAgIGkubWF4IDwtIChuL3MpICogKHNkKHJvd1N1bXMod2VpZ2h0KSAqIHkpL3NxcnQodi8obiAtIDEpKSkNCiAgICAgICAgICAgIG9icyA8LSBvYnMvaS5tYXgNCiAgICAgICAgfQ0KICAgICAgICBTMSA8LSAwLjUgKiBzdW0oKHdlaWdodCArIHQod2VpZ2h0KSleMikNCiAgICAgICAgUzIgPC0gc3VtKChhcHBseSh3ZWlnaHQsIDEsIHN1bSkgKyBhcHBseSh3ZWlnaHQsIDIsIHN1bSkpXjIpDQogICAgICAgIHMuc3EgPC0gc14yDQogICAgICAgIGsgPC0gKHN1bSh5XjQpL24pLyh2L24pXjINCiAgICAgICAgc2RpIDwtIHNxcnQoKG4gKiAoKG5eMiAtIDMgKiBuICsgMykgKiBTMSAtIG4gKiBTMiArIDMgKiBzLnNxKSAtIGsgKiAobiAqIChuIC0gMSkgKiBTMSAtIDIgKiBuICogDQogICAgICAgICAgICBTMiArIDYgKiBzLnNxKSkvKChuIC0gMSkgKiAobiAtIDIpICogKG4gLSAzKSAqIHMuc3EpIC0gMS8oKG4gLSAxKV4yKSkNCiAgICAgICAgYWx0ZXJuYXRpdmUgPC0gbWF0Y2guYXJnKGFsdGVybmF0aXZlLCBjKCJ0d28uc2lkZWQiLCAibGVzcyIsICJncmVhdGVyIikpDQogICAgICAgIHB2IDwtIHBub3JtKG9icywgbWVhbiA9IGVpLCBzZCA9IHNkaSkNCiAgICAgICAgaWYgKGFsdGVybmF0aXZlID09ICJ0d28uc2lkZWQiKSANCiAgICAgICAgICAgIHB2IDwtIGlmIChvYnMgPD0gZWkpIA0KICAgICAgICAgICAgICAgIDIgKiBwdiBlbHNlIDIgKiAoMSAtIHB2KQ0KICAgICAgICBpZiAoYWx0ZXJuYXRpdmUgPT0gImdyZWF0ZXIiKSANCiAgICAgICAgICAgIHB2IDwtIDEgLSBwdg0KICAgICAgICBsaXN0KG9ic2VydmVkID0gb2JzLCBleHBlY3RlZCA9IGVpLCBzZCA9IHNkaSwgcC52YWx1ZSA9IHB2KQ0KICAgIH0NCiAgICANCiAgICANCn0NCmBgYA0KDQotLS0tDQoNCldlIGNvdmVyIHRoZSBmb2xsb3dpbmc6DQoNCiogY2x1YiBjaGFyYWN0ZXJpc3RpY3MNCiogbmV0d29yayBzdHJ1Y3R1cmUgaW4gS3Vkb3MgbmV0d29ya3MNCiogZ2VuZGVyIGNvbXBvc2l0aW9uIC8gc2VncmVnYXRpb24NCiogYmVoYXZpb3I6IGFjdGl2aXR5IGxldmVsIChmcmVxdWVuY3kgYW5kIGR1cmF0aW9uKSBhbmQgY29ycmVsYXRpb24NCiogc3BhdGlhbCBuZXR3b3JrIGF1dG9jb3JyZWxhdGlvbjogYmVoYXZpb3JhbCBzaW1pbGFyaXR5IGluIG5ldHdvcmtzDQoNCi0tLS0NCg0KPGJyPg0KDQojIFByaW50IHJlcG9ydA0KIyMgey50YWJzZXQgLnRhYnNldC1mYWRlfSANCk1ha2Ugc3VyZSB0byBjaGVjayB0aGUgb3V0cHV0IG9mIHRoZSAncHJpbnQwMVJlcG9ydCgpJyBmdW5jdGlvbiBmb3IgZ2VuZXJhbCBkYXRhIGRlc2NyaXB0b24gKGRlZ3JlZXMsIG5ldHdvcmsgc2l6ZSwgZXRjLikgYW5kIGEgZ2VuZXJhbCBvdmVydmlldyBvZiB0aGUgZGF0YXNldC4gT3V0cHV0IGlzIHByaW50ZWQgaW4gYSAudHh0IGZpbGUgaW4gdGhlIGRpcmVjdG9yeSBzcGVjaWZpZWQuDQoNCg0KIyMjIENsdWIgMQ0KYGBge3IgZXZhbD0gRn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1sxXV0gIyBncmFiIGNsdWIgDQpwcmludDAxUmVwb3J0KGRmLCBtb2RlbG5hbWU9ImZpbGVzL2NsdWIxIikNCmBgYA0KDQohW10oZmlsZXMvY2x1YjEudHh0KXsjaWQgLmNsYXNzIHdpZHRoPTEwMCUgaGVpZ2h0PTIwMHB4fQ0KDQojIyMgQ2x1YiAyDQpgYGB7ciBldmFsPSBGfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzJdXSAjIGdyYWIgY2x1YiANCnByaW50MDFSZXBvcnQoZGYsIG1vZGVsbmFtZT0iZmlsZXMvY2x1YjIiKQ0KYGBgDQoNCiFbXShmaWxlcy9jbHViMi50eHQpeyNpZCAuY2xhc3Mgd2lkdGg9MTAwJSBoZWlnaHQ9MjAwcHh9DQoNCiMjIyBDbHViIDMNCmBgYHtyIGV2YWw9IEZ9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFfZnJlcVtbM11dICMgZ3JhYiBjbHViIA0KcHJpbnQwMVJlcG9ydChkZiwgbW9kZWxuYW1lPSJmaWxlcy9jbHViMyIpDQpgYGANCg0KIVtdKGZpbGVzL2NsdWIzLnR4dCl7I2lkIC5jbGFzcyB3aWR0aD0xMDAlIGhlaWdodD0yMDBweH0NCg0KIyMjIENsdWIgNA0KYGBge3IgZXZhbD0gRn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1s0XV0gIyBncmFiIGNsdWIgDQpwcmludDAxUmVwb3J0KGRmLCBtb2RlbG5hbWU9ImZpbGVzL2NsdWI0IikNCmBgYA0KDQohW10oZmlsZXMvY2x1YjQudHh0KXsjaWQgLmNsYXNzIHdpZHRoPTEwMCUgaGVpZ2h0PTIwMHB4fQ0KDQojIyMgQ2x1YiA1DQpgYGB7ciBldmFsPSBGfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzVdXSAjIGdyYWIgY2x1YiANCnByaW50MDFSZXBvcnQoZGYsIG1vZGVsbmFtZT0iZmlsZXMvY2x1YjUiKQ0KYGBgDQoNCiFbXShmaWxlcy9jbHViNS50eHQpeyNpZCAuY2xhc3Mgd2lkdGg9MTAwJSBoZWlnaHQ9MjAwcHh9DQoNCiMjIHstfQ0KDQotLS0tDQoNCiMgQ2x1YiBjaGFyYWN0ZXJpc3RpY3MNCg0KU29tZSBjbHViIGNoYXJhY3RlcmlzdGljcy4gV2Ugc2hvdyB0aGUgc2l6ZSBvZiB0aGUgbmV0d29yayAodGhlIG51bWJlciBvZiBhY3RvcnMpIGZvciBlYWNoIGNsdWIgYW5kIHRoZSBudW1iZXIgb2YgYWN0aXZlIG1lbWJlcnMgY3VycmVudGx5ICgxOC0xLTIwMjEpIG9uIFN0cmF2YSwgYnkgYWRkaW5nIHRvICp3d3cuc3RyYXZhLmNvbS9jbHVicy8uLi4qIHRoZSBvcmlnaW5hbCBjbHViIGlkLiANCg0KYGBge3J9DQojIGF0dHJpZXZlIGZyb20gdGhlIGNsdWJkYXRhIHRoZSBudW1iZXIgb2YgYWN0b3JzIGluIGVhY2ggbmV0d29yaw0KbmV0c2l6ZSA8LSBjKCANCiAgbGVuZ3RoKGNsdWJkYXRhX3JzaWVuYV9mcmVxW1sxXV0kbm9kZVNldHMkQWN0b3JzKSwgDQogIGxlbmd0aChjbHViZGF0YV9yc2llbmFfZnJlcVtbMl1dJG5vZGVTZXRzJEFjdG9ycyksIA0KICBsZW5ndGgoY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzNdXSRub2RlU2V0cyRBY3RvcnMpLCANCiAgbGVuZ3RoKGNsdWJkYXRhX3JzaWVuYV9mcmVxW1s0XV0kbm9kZVNldHMkQWN0b3JzKSwgDQogIGxlbmd0aChjbHViZGF0YV9yc2llbmFfZnJlcVtbNV1dJG5vZGVTZXRzJEFjdG9ycykpIA0KDQpjbHVic2l6ZSA8LSBjKDY2LCAxMjcsIDM3MywgMTUsIDE2OSkgIyBmaW5kIHRoZSBudW1iZXIgb2YgbWVtYmVycyBjdXJyZW50bHkgb24gU3RyYXZhDQoNCmRmIDwtIGRhdGEuZnJhbWUoIG5ldHNpemUgPSBuZXRzaXplLCBjbHVic2l6ZSA9IGNsdWJzaXplICkNCg0KcHJpbnQoZGYpDQpgYGANCg0KPGJyPg0KDQotLS0tDQoNCg0KDQojIEt1ZG9zIG5ldHdvcmsNCg0KTm93IGxldCdzIGRlc2NyaWJlIHRoZSBLdWRvcyBuZXR3b3JrLg0KDQojIyAxLiBOb2RlLWxldmVsIHsudGFic2V0IC50YWJzZXQtZmFkZX0NCg0KU3RhcnRpbmcsIGFnYWluLCB3aXRoIGluZGVncmVlcyBhbmQgb3V0ZGVncmVlczogd2hvIHJlY2VpdmVzIGFuZCBnaXZlcyBLdWRvcz8gV2UgdGFrZSBmcm9tIHRoZSBSU2llbmEgb2JqZWN0IHRoZSBLdWRvcyBuZXR3b3JrIGZvciBlYWNoIGNsdWIsIHN1YnNldCB0aGUgZmlyc3Qgd2F2ZSwgYW5kIHR1cm4gaXQgaW50byBhbiAqaWdyYXBoKiBvYmplY3QuIA0KDQojIyMgQ2x1YiAxDQpgYGB7cn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1sxXV0gIyBncmFiIGNsdWIgDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgZmluZCBpbi0gYW5kIG91dGRlZ3JlZSBmb3IgZWFjaCBub2RlDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJvdXQiKSwgeGxhYj0ib3V0ZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIEt1ZG8gb3V0ZGVncmVlIikNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9ImluIiksIHhsYWI9ImluZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIEt1ZG8gaW5kZWdyZWUiKQ0KYGBgDQoNCiMjIyBDbHViIDINCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzJdXSAjIGdyYWIgY2x1YiB0DQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgZmluZCBpbi0gYW5kIG91dGRlZ3JlZSBmb3IgZWFjaCBub2RlDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJvdXQiKSwgeGxhYj0ib3V0ZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIEt1ZG8gb3V0ZGVncmVlIikNCg0KaGlzdChpZ3JhcGg6OmRlZ3JlZShHMSwgbW9kZT0iaW4iKSwgeGxhYj0iaW5kZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2YgS3VkbyBpbmRlZ3JlZSIpDQpgYGANCg0KIyMjIENsdWIgMw0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFfZnJlcVtbM11dICMgZ3JhYiBjbHViIA0Ka25ldCA8LSBkZiRkZXB2YXJzJGt1ZG9uZXQgIyB0YWtlIEt1ZG8gbmV0d29yaw0Ka25ldDEgPC0ga25ldFssLDFdICMgdGFrZSB3YXZlIDEgb25seSBmb3Igbm93DQoNCiMgbWFrZSBhbiAnaWdyYXBoIG9iamVjdCcNCkcxIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGtuZXQxLCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGZpbmQgaW4tIGFuZCBvdXRkZWdyZWUgZm9yIGVhY2ggbm9kZQ0KaGlzdChpZ3JhcGg6OmRlZ3JlZShHMSwgbW9kZT0ib3V0IiksIHhsYWI9Im91dGRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBLdWRvIG91dGRlZ3JlZSIpDQoNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9ImluIiksIHhsYWI9ImluZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIEt1ZG8gaW5kZWdyZWUiKQ0KYGBgDQoNCiMjIyBDbHViIDQNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzRdXSAjIGdyYWIgY2x1YiANCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIG1ha2UgYW4gJ2lncmFwaCBvYmplY3QnDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChrbmV0MSwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBmaW5kIGluLSBhbmQgb3V0ZGVncmVlIGZvciBlYWNoIG5vZGUNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9Im91dCIpLCB4bGFiPSJvdXRkZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2YgS3VkbyBvdXRkZWdyZWUiKQ0KDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJpbiIpLCB4bGFiPSJpbmRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBLdWRvIGluZGVncmVlIikNCmBgYA0KDQojIyMgQ2x1YiA1DQpgYGB7cn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1s1XV0gIyBncmFiIGNsdWIgDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgZmluZCBpbi0gYW5kIG91dGRlZ3JlZSBmb3IgZWFjaCBub2RlDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJvdXQiKSwgeGxhYj0ib3V0ZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIEt1ZG8gb3V0ZGVncmVlIikNCg0KaGlzdChpZ3JhcGg6OmRlZ3JlZShHMSwgbW9kZT0iaW4iKSwgeGxhYj0iaW5kZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2YgS3VkbyBpbmRlZ3JlZSIpDQpgYGANCg0KIyMgey19DQoNCldlIGNhbiBvYnNlcnZlIGEgUGFyZXRvLWxpa2UtcGF0dGVybjogc29tZSBnaXZlL3JlY2VpdmUgbW9zdCBvZiB0aGUgS3Vkb3MgZ2l2ZW4sIHdoaWxlIG1vc3QgZ2l2ZS9yZWNlaXZlIGZldy4NCg0KPGJyPg0KDQojIyAyLiBEeWFkLWxldmVsIHsudGFic2V0IC50YWJzZXQtZmFkZX0NCg0KQXQgdGhlIGR5YWQtbGV2ZWw6IGxldCdzIHNlZSB0byB3aGF0IGV4dGVudCBLdWRvcyB0ZW5kIHRvIGJlIHJlY2lwcm9jYXRlZCBiZXR3ZWVuIGFjdG9ycy4NCg0KIyMjIENsdWIgMQ0KYGBge3IgfQ0KIyBtYWtlIGlncmFwaCBvYmplY3QgZm9yIHRoZSBjbHViLCBhdCB3YXZlIDENCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1sxXV0gIyBncmFiIGNsdWIgDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgZHlhZHMNCmR5YWRjb3VudCA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKEcxKQ0KDQojIGFkZCB0aGUgdG90YWwgbnVtYmVyIG9mIGR5YWRzIHRvIHRoZSBncmFwaA0KZHlhZGNvdW50JHRvdGFsIDwtICh2Y291bnQoRzEpKih2Y291bnQoRzEpLTEpKS8yDQpkeWFkY291bnQNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKHJhbmRvbV9ncmFwaCkkbXV0DQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJudW1iZXIgb2YgcmVjaXByb2NhdGVkIEt1ZG9zIGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIsICkNCmFibGluZSh2PWR5YWRjb3VudCRtdXQsIGNvbD0icmVkIiwgbHdkPTMpfQ0KYGBgDQoNCiMjIyBDbHViIDINCmBgYHtyIH0NCiMgbWFrZSBpZ3JhcGggb2JqZWN0IGZvciB0aGUgY2x1YiwgYXQgd2F2ZSAxDQpkZiA8LSBjbHViZGF0YV9yc2llbmFfZnJlcVtbMl1dICMgZ3JhYiBjbHViIA0Ka25ldCA8LSBkZiRkZXB2YXJzJGt1ZG9uZXQgIyB0YWtlIEt1ZG8gbmV0d29yaw0Ka25ldDEgPC0ga25ldFssLDFdICMgdGFrZSB3YXZlIDEgb25seSBmb3Igbm93DQoNCiMgbWFrZSBhbiAnaWdyYXBoIG9iamVjdCcNCkcxIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGtuZXQxLCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGNsYXNzaWZ5IGR5YWRzDQpkeWFkY291bnQgPC0gaWdyYXBoOjpkeWFkLmNlbnN1cyhHMSkNCg0KIyBhZGQgdGhlIHRvdGFsIG51bWJlciBvZiBkeWFkcyB0byB0aGUgZ3JhcGgNCmR5YWRjb3VudCR0b3RhbCA8LSAodmNvdW50KEcxKSoodmNvdW50KEcxKS0xKSkvMg0KZHlhZGNvdW50DQoNCiMgY29tcGFyZSB2YWx1ZXMgd2l0aCBhIHJhbmRvbSBncmFwaCBvZiB0aGUgc2FtZSBzaXplIHdpdGggdGhlIHNhbWUgZGVuc2l0eQ0KZGVucyA8LSBpZ3JhcGg6OmdyYXBoLmRlbnNpdHkoRzEpDQpzaXplIDwtIGlncmFwaDo6dmNvdW50KEcxKQ0KdHJpYWwgPC0gMTAwMA0KcmVjaXAgPC0gcmVwKE5BLCB0cmlhbCkNCg0KZm9yICggaSBpbiAxOnRyaWFsICl7DQogIHJhbmRvbV9ncmFwaCA8LSBpZ3JhcGg6OmVyZG9zLnJlbnlpLmdhbWUobiA9IHNpemUsIHAub3IubSA9IGRlbnMsIGRpcmVjdGVkID0gVFJVRSkNCiAgcmVjaXBbaV0gPC0gaWdyYXBoOjpkeWFkLmNlbnN1cyhyYW5kb21fZ3JhcGgpJG11dA0KfQ0KDQp7aGlzdChyZWNpcCwgbWFpbj0ibnVtYmVyIG9mIHJlY2lwcm9jYXRlZCBLdWRvcyBpbiByYW5kb20gZ3JhcGgiLCB4bGFiPSIiLCApDQphYmxpbmUodj1keWFkY291bnQkbXV0LCBjb2w9InJlZCIsIGx3ZD0zKX0NCmBgYA0KDQojIyMgQ2x1YiAzDQpgYGB7ciB9DQojIG1ha2UgaWdyYXBoIG9iamVjdCBmb3IgdGhlIGNsdWIsIGF0IHdhdmUgMQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzNdXSAjIGdyYWIgY2x1YiANCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIG1ha2UgYW4gJ2lncmFwaCBvYmplY3QnDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChrbmV0MSwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBjbGFzc2lmeSBkeWFkcw0KZHlhZGNvdW50IDwtIGlncmFwaDo6ZHlhZC5jZW5zdXMoRzEpDQoNCiMgYWRkIHRoZSB0b3RhbCBudW1iZXIgb2YgZHlhZHMgdG8gdGhlIGdyYXBoDQpkeWFkY291bnQkdG90YWwgPC0gKHZjb3VudChHMSkqKHZjb3VudChHMSktMSkpLzINCmR5YWRjb3VudA0KDQojIGNvbXBhcmUgdmFsdWVzIHdpdGggYSByYW5kb20gZ3JhcGggb2YgdGhlIHNhbWUgc2l6ZSB3aXRoIHRoZSBzYW1lIGRlbnNpdHkNCmRlbnMgPC0gaWdyYXBoOjpncmFwaC5kZW5zaXR5KEcxKQ0Kc2l6ZSA8LSBpZ3JhcGg6OnZjb3VudChHMSkNCnRyaWFsIDwtIDEwMDANCnJlY2lwIDwtIHJlcChOQSwgdHJpYWwpDQoNCmZvciAoIGkgaW4gMTp0cmlhbCApew0KICByYW5kb21fZ3JhcGggPC0gaWdyYXBoOjplcmRvcy5yZW55aS5nYW1lKG4gPSBzaXplLCBwLm9yLm0gPSBkZW5zLCBkaXJlY3RlZCA9IFRSVUUpDQogIHJlY2lwW2ldIDwtIGlncmFwaDo6ZHlhZC5jZW5zdXMocmFuZG9tX2dyYXBoKSRtdXQNCn0NCg0Ke2hpc3QocmVjaXAsIG1haW49Im51bWJlciBvZiByZWNpcHJvY2F0ZWQgS3Vkb3MgaW4gcmFuZG9tIGdyYXBoIiwgeGxhYj0iIiwgKQ0KYWJsaW5lKHY9ZHlhZGNvdW50JG11dCwgY29sPSJyZWQiLCBsd2Q9Myl9DQpgYGANCg0KIyMjIENsdWIgNA0KYGBge3IgfQ0KIyBtYWtlIGlncmFwaCBvYmplY3QgZm9yIHRoZSBjbHViLCBhdCB3YXZlIDENCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1s0XV0gIyBncmFiIGNsdWIgDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgZHlhZHMNCmR5YWRjb3VudCA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKEcxKQ0KDQojIGFkZCB0aGUgdG90YWwgbnVtYmVyIG9mIGR5YWRzIHRvIHRoZSBncmFwaA0KZHlhZGNvdW50JHRvdGFsIDwtICh2Y291bnQoRzEpKih2Y291bnQoRzEpLTEpKS8yDQpkeWFkY291bnQNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKHJhbmRvbV9ncmFwaCkkbXV0DQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJudW1iZXIgb2YgcmVjaXByb2NhdGVkIEt1ZG9zIGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIsICkNCmFibGluZSh2PWR5YWRjb3VudCRtdXQsIGNvbD0icmVkIiwgbHdkPTMpfQ0KYGBgDQoNCiMjIyBDbHViIDUNCmBgYHtyfQ0KIyBtYWtlIGlncmFwaCBvYmplY3QgZm9yIHRoZSBjbHViLCBhdCB3YXZlIDENCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1s1XV0gIyBncmFiIGNsdWIgDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgZHlhZHMNCmR5YWRjb3VudCA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKEcxKQ0KDQojIGFkZCB0aGUgdG90YWwgbnVtYmVyIG9mIGR5YWRzIHRvIHRoZSBncmFwaA0KZHlhZGNvdW50JHRvdGFsIDwtICh2Y291bnQoRzEpKih2Y291bnQoRzEpLTEpKS8yDQpkeWFkY291bnQNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKHJhbmRvbV9ncmFwaCkkbXV0DQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJudW1iZXIgb2YgcmVjaXByb2NhdGVkIEt1ZG9zIGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIsICkNCmFibGluZSh2PWR5YWRjb3VudCRtdXQsIGNvbD0icmVkIiwgbHdkPTMpfQ0KYGBgDQoNCiMjIHstfQ0KDQpDb25jbHVzaW9uOiBLdWRvcyB0ZW5kIHRvIGJlIHJlY2lwcm9jYXRlZCENCg0KLS0tLQ0KDQoNCjxicj4NCg0KIyBHZW5kZXIgY29tcG9zaXRpb24gDQoNCiMjIHsudGFic2V0IC50YWJzZXQtZmFkZX0NCg0KTGV0J3MgaW52ZXN0aWdhdGUgdGhlIGdlbmRlciBjb21wb3NpdGlvbiBvZiB0aGUgY2x1Yi4NCldlIG11c3QgcmV0cmlldmUgZ2VuZGVyIGZyb20gdGhlIG9iamVjdCAobm90ZSB0aGF0IHdlIHVzZSB0aGUgY2x1YmRhdGEgb2JqZWN0LCBub3QgdGhlIFJTaWVuYSBvYmplY3QpLiBUaGVuIHdlIG1ha2UgYSBjYXRlZ29yaWNhbCBnZW5kZXIgdmFyaWFibGUgYW5kIHBsb3QgaXQuDQoNCiMjIyBDbHViIDENCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KDQpkZiA8LSBjbHViZGF0YVtbMV1dICMgZ3JhYiBjbHViIA0KDQojIHJldHJpZXZlIG5vZGUtYXR0cmlidXRlIGdlbmRlciBmcm9tIG9iamVjdA0KbWFsZSA8LSBkZiRtYWxlDQpmZW1hbGUgPC0gZGYkZmVtYWxlDQpvdGhlciA8LSBkZiRvdGhlcg0KDQojIGFzIGZhY3Rvcg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBtYWtlIGRhdGFmcmFtZQ0KZGYgPC0gZGF0YS5mcmFtZSgNCiAgZ2VuZGVyID0gYXMuZmFjdG9yKGMoIk1hbGUiLCAiRmVtYWxlIiwgIk90aGVyIiwgIk1pc3NpbmciKSksDQogIG4gPSBjKGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJNYWxlIl0pLCBsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiRmVtYWxlIl0pLCBsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiT3RoZXIiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJNaXNzaW5nIl0pKSwNCiAgZnJlcSA9IGMocm91bmQoKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iTWFsZSJdKS9sZW5ndGgoZ2VuZGVyKSAqMTAwKSwgZGlnaXRzPTEpLCByb3VuZCgobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJGZW1hbGUiXSkvbGVuZ3RoKGdlbmRlcikgKjEwMCksIGRpZ2l0cz0xKSwgcm91bmQoKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iT3RoZXIiXSkvbGVuZ3RoKGdlbmRlcikqMTAwKSwgZGlnaXRzPTEpLCByb3VuZCgobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJNaXNzaW5nIl0pL2xlbmd0aChnZW5kZXIpKjEwMCksIGRpZ2l0cz0xKSkNCikNCg0KIyBwbG90DQpkZiAlPiUNCiAgbXV0YXRlKGdlbmRlciA9IGZjdF9yZW9yZGVyKGdlbmRlciwgLW4pKSAlPiUNCiAgICAgICAgICAgZ2dwbG90KGFlcyhnZW5kZXIsIG4sIGZpbGw9Z2VuZGVyKSkgKyANCiAgICAgICAgICAgZ2VvbV9iYXIoc3RhdD0iaWRlbnRpdHkiLCB3aWR0aD0wLjgpICsNCiAgICAgICAgICAgZ2VvbV90ZXh0KGFlcyhsYWJlbD1wYXN0ZTAoZnJlcSwiJSIpKSwgdmp1c3Q9MS41LCBjb2xvdXI9IndoaXRlIikNCg0KYGBgDQoNCiMjIyBDbHViIDINCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFbWzJdXSAjIGdyYWIgY2x1YiANCg0KIyByZXRyaWV2ZSBub2RlLWF0dHJpYnV0ZSBnZW5kZXIgZnJvbSBvYmplY3QNCm1hbGUgPC0gZGYkbWFsZQ0KZmVtYWxlIDwtIGRmJGZlbWFsZQ0Kb3RoZXIgPC0gZGYkb3RoZXINCg0KIyBhcyBmYWN0b3INCmdlbmRlciA8LSBOQQ0KZ2VuZGVyIDwtIGlmZWxzZShtYWxlID09IDEsICJNYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShmZW1hbGUgPT0gMSwgIkZlbWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2Uob3RoZXIgPT0gMSwgIk90aGVyIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShpcy5uYShnZW5kZXIpLCAiTWlzc2luZyIsIGdlbmRlcikgIyBtaXNzaW5nIGNhdGVnb3J5DQoNCiMgbWFrZSBkYXRhZnJhbWUNCmRmIDwtIGRhdGEuZnJhbWUoDQogIGdlbmRlciA9IGFzLmZhY3RvcihjKCJNYWxlIiwgIkZlbWFsZSIsICJPdGhlciIsICJNaXNzaW5nIikpLA0KICBuID0gYyhsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiTWFsZSJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIkZlbWFsZSJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk90aGVyIl0pLCBsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiTWlzc2luZyJdKSksDQogIGZyZXEgPSBjKHJvdW5kKChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik1hbGUiXSkvbGVuZ3RoKGdlbmRlcikgKjEwMCksIGRpZ2l0cz0xKSwgcm91bmQoKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iRmVtYWxlIl0pL2xlbmd0aChnZW5kZXIpICoxMDApLCBkaWdpdHM9MSksIHJvdW5kKChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik90aGVyIl0pL2xlbmd0aChnZW5kZXIpKjEwMCksIGRpZ2l0cz0xKSwgcm91bmQoKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iTWlzc2luZyJdKS9sZW5ndGgoZ2VuZGVyKSoxMDApLCBkaWdpdHM9MSkpDQopDQoNCiMgcGxvdA0KZGYgJT4lDQogIG11dGF0ZShnZW5kZXIgPSBmY3RfcmVvcmRlcihnZW5kZXIsIC1uKSkgJT4lDQogICAgICAgICAgIGdncGxvdChhZXMoZ2VuZGVyLCBuLCBmaWxsPWdlbmRlcikpICsgDQogICAgICAgICAgIGdlb21fYmFyKHN0YXQ9ImlkZW50aXR5Iiwgd2lkdGg9MC44KSArDQogICAgICAgICAgIGdlb21fdGV4dChhZXMobGFiZWw9cGFzdGUwKGZyZXEsIiUiKSksIHZqdXN0PTEuNSwgY29sb3VyPSJ3aGl0ZSIpDQpgYGANCg0KIyMjIENsdWIgMw0KYGBge3IgY2xhc3Muc291cmNlID0gJ2ZvbGQtaGlkZSd9DQpkZiA8LSBjbHViZGF0YVtbM11dICMgZ3JhYiBjbHViIA0KDQojIHJldHJpZXZlIG5vZGUtYXR0cmlidXRlIGdlbmRlciBmcm9tIG9iamVjdA0KbWFsZSA8LSBkZiRtYWxlDQpmZW1hbGUgPC0gZGYkZmVtYWxlDQpvdGhlciA8LSBkZiRvdGhlcg0KDQojIGFzIGZhY3Rvcg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBtYWtlIGRhdGFmcmFtZQ0KZGYgPC0gZGF0YS5mcmFtZSgNCiAgZ2VuZGVyID0gYXMuZmFjdG9yKGMoIk1hbGUiLCAiRmVtYWxlIiwgIk90aGVyIiwgIk1pc3NpbmciKSksDQogIG4gPSBjKGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJNYWxlIl0pLCBsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiRmVtYWxlIl0pLCBsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiT3RoZXIiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJNaXNzaW5nIl0pKSwNCiAgZnJlcSA9IGMocm91bmQoKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iTWFsZSJdKS9sZW5ndGgoZ2VuZGVyKSAqMTAwKSwgZGlnaXRzPTEpLCByb3VuZCgobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJGZW1hbGUiXSkvbGVuZ3RoKGdlbmRlcikgKjEwMCksIGRpZ2l0cz0xKSwgcm91bmQoKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iT3RoZXIiXSkvbGVuZ3RoKGdlbmRlcikqMTAwKSwgZGlnaXRzPTEpLCByb3VuZCgobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJNaXNzaW5nIl0pL2xlbmd0aChnZW5kZXIpKjEwMCksIGRpZ2l0cz0xKSkNCikNCg0KIyBwbG90DQpkZiAlPiUNCiAgbXV0YXRlKGdlbmRlciA9IGZjdF9yZW9yZGVyKGdlbmRlciwgLW4pKSAlPiUNCiAgICAgICAgICAgZ2dwbG90KGFlcyhnZW5kZXIsIG4sIGZpbGw9Z2VuZGVyKSkgKyANCiAgICAgICAgICAgZ2VvbV9iYXIoc3RhdD0iaWRlbnRpdHkiLCB3aWR0aD0wLjgpICsNCiAgICAgICAgICAgZ2VvbV90ZXh0KGFlcyhsYWJlbD1wYXN0ZTAoZnJlcSwiJSIpKSwgdmp1c3Q9MS41LCBjb2xvdXI9IndoaXRlIikNCmBgYA0KDQojIyMgQ2x1YiA0DQpgYGB7ciBjbGFzcy5zb3VyY2UgPSAnZm9sZC1oaWRlJ30NCmRmIDwtIGNsdWJkYXRhW1s0XV0gIyBncmFiIGNsdWIgDQoNCiMgcmV0cmlldmUgbm9kZS1hdHRyaWJ1dGUgZ2VuZGVyIGZyb20gb2JqZWN0DQptYWxlIDwtIGRmJG1hbGUNCmZlbWFsZSA8LSBkZiRmZW1hbGUNCm90aGVyIDwtIGRmJG90aGVyDQoNCiMgYXMgZmFjdG9yDQpnZW5kZXIgPC0gTkENCmdlbmRlciA8LSBpZmVsc2UobWFsZSA9PSAxLCAiTWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoZmVtYWxlID09IDEsICJGZW1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKG90aGVyID09IDEsICJPdGhlciIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoaXMubmEoZ2VuZGVyKSwgIk1pc3NpbmciLCBnZW5kZXIpICMgbWlzc2luZyBjYXRlZ29yeQ0KDQojIG1ha2UgZGF0YWZyYW1lDQpkZiA8LSBkYXRhLmZyYW1lKA0KICBnZW5kZXIgPSBhcy5mYWN0b3IoYygiTWFsZSIsICJGZW1hbGUiLCAiT3RoZXIiLCAiTWlzc2luZyIpKSwNCiAgbiA9IGMobGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk1hbGUiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJGZW1hbGUiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJPdGhlciJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk1pc3NpbmciXSkpLA0KICBmcmVxID0gYyhyb3VuZCgobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJNYWxlIl0pL2xlbmd0aChnZW5kZXIpICoxMDApLCBkaWdpdHM9MSksIHJvdW5kKChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09IkZlbWFsZSJdKS9sZW5ndGgoZ2VuZGVyKSAqMTAwKSwgZGlnaXRzPTEpLCByb3VuZCgobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJPdGhlciJdKS9sZW5ndGgoZ2VuZGVyKSoxMDApLCBkaWdpdHM9MSksIHJvdW5kKChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik1pc3NpbmciXSkvbGVuZ3RoKGdlbmRlcikqMTAwKSwgZGlnaXRzPTEpKQ0KKQ0KDQojIHBsb3QNCmRmICU+JQ0KICBtdXRhdGUoZ2VuZGVyID0gZmN0X3Jlb3JkZXIoZ2VuZGVyLCAtbikpICU+JQ0KICAgICAgICAgICBnZ3Bsb3QoYWVzKGdlbmRlciwgbiwgZmlsbD1nZW5kZXIpKSArIA0KICAgICAgICAgICBnZW9tX2JhcihzdGF0PSJpZGVudGl0eSIsIHdpZHRoPTAuOCkgKw0KICAgICAgICAgICBnZW9tX3RleHQoYWVzKGxhYmVsPXBhc3RlMChmcmVxLCIlIikpLCB2anVzdD0xLjUsIGNvbG91cj0id2hpdGUiKQ0KYGBgDQoNCiMjIyBDbHViIDUNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFbWzVdXSAjIGdyYWIgY2x1YiANCg0KIyByZXRyaWV2ZSBub2RlLWF0dHJpYnV0ZSBnZW5kZXIgZnJvbSBvYmplY3QNCm1hbGUgPC0gZGYkbWFsZQ0KZmVtYWxlIDwtIGRmJGZlbWFsZQ0Kb3RoZXIgPC0gZGYkb3RoZXINCg0KIyBhcyBmYWN0b3INCmdlbmRlciA8LSBOQQ0KZ2VuZGVyIDwtIGlmZWxzZShtYWxlID09IDEsICJNYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShmZW1hbGUgPT0gMSwgIkZlbWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2Uob3RoZXIgPT0gMSwgIk90aGVyIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShpcy5uYShnZW5kZXIpLCAiTWlzc2luZyIsIGdlbmRlcikgIyBtaXNzaW5nIGNhdGVnb3J5DQoNCiMgbWFrZSBkYXRhZnJhbWUNCmRmIDwtIGRhdGEuZnJhbWUoDQogIGdlbmRlciA9IGFzLmZhY3RvcihjKCJNYWxlIiwgIkZlbWFsZSIsICJPdGhlciIsICJNaXNzaW5nIikpLA0KICBuID0gYyhsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiTWFsZSJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIkZlbWFsZSJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk90aGVyIl0pLCBsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiTWlzc2luZyJdKSksDQogIGZyZXEgPSBjKHJvdW5kKChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik1hbGUiXSkvbGVuZ3RoKGdlbmRlcikgKjEwMCksIGRpZ2l0cz0xKSwgcm91bmQoKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iRmVtYWxlIl0pL2xlbmd0aChnZW5kZXIpICoxMDApLCBkaWdpdHM9MSksIHJvdW5kKChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik90aGVyIl0pL2xlbmd0aChnZW5kZXIpKjEwMCksIGRpZ2l0cz0xKSwgcm91bmQoKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iTWlzc2luZyJdKS9sZW5ndGgoZ2VuZGVyKSoxMDApLCBkaWdpdHM9MSkpDQopDQoNCiMgcGxvdA0KZGYgJT4lDQogIG11dGF0ZShnZW5kZXIgPSBmY3RfcmVvcmRlcihnZW5kZXIsIC1uKSkgJT4lDQogICAgICAgICAgIGdncGxvdChhZXMoZ2VuZGVyLCBuLCBmaWxsPWdlbmRlcikpICsgDQogICAgICAgICAgIGdlb21fYmFyKHN0YXQ9ImlkZW50aXR5Iiwgd2lkdGg9MC44KSArDQogICAgICAgICAgIGdlb21fdGV4dChhZXMobGFiZWw9cGFzdGUwKGZyZXEsIiUiKSksIHZqdXN0PTEuNSwgY29sb3VyPSJ3aGl0ZSIpDQpgYGANCg0KIyMgey19DQoNCldlIGNhbiBzZWUgdGhhdCBpbiBhbGwgY2x1YnMgbWVuIGFyZSB0aGUgbWFqb3JpdHkuIA0KDQotLS0tDQoNCjxicj4NCg0KIyBHZW5kZXIgc2VncmVnYXRpb24NCg0KTGV0J3Mgbm93IGludmVzdGlnYXRlIHNlZ3JlZ2F0aW9uIGFsb25nIGdlbmRlciBpbiB0aGUga3Vkb3MgbmV0d29yay4NCg0KDQojIyB7LnRhYnNldCAudGFic2V0LWZhZGV9DQoNCkxldCdzIHN0YXJ0IHdpdGggZGVzY3JpYmluZyB0aGUgdG90YWwgZGVuc2l0eSBhbmQgaW50cmEtIChzYW1lIGdlbmRlcikgYW5kIGludGVyZ3JvdXAgKGRpZmZlcmVudCBnZW5kZXIpIGRlbnNpdGllcy4gV2UgYWxzbyBjYWxjdWxhdGUgdGhlIENvbGVtYW4gSG9tb3BoaWx5IGluZGV4IGZvciBnZW5kZXIsIHdoaWNoIHJlZmxlY3RzIGdlbmRlciBzZWdyZWdhdGlvbiB3aGlsZSB0YWtpbmcgaW50byBhY2NvdW50IHRoZSByZWxhdGl2ZSBncm91cCBzaXplIG9mIGdlbmRlciBjYXRlZ29yaWVzLiANCg0KIyMjIENsdWIgMQ0KYGBge3IgfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzFdXSAjIGdyYWIgY2x1YiANCmRmMiA8LSBjbHViZGF0YVtbMV1dDQoNCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIGZvciBzb21lIHJlYXNvbiBjb25zdHJ1Y3RpbmcgdGhlIGR5YWQtc2ltaWxhcml0eSBtYXRyaXggZm9yIGdlbmRlciB3aXRoIHRoZSByc2llbmEgb2JqZWN0IGRpZCBub3Qgd29yaywgc28gd2UgdXNlIHRoZSBjbHViZGF0YS5SRGF0YS4NCm1hbGUgPC0gZGYyJG1hbGUNCmZlbWFsZSA8LSBkZjIkZmVtYWxlDQpvdGhlciA8LSBkZjIkb3RoZXINCg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBjb25zdHJ1Y3QgZHlhZCBzaW1pbGFyaXR5IG1hdHJpeA0KZ2VuZGVyX20gPC0gZmhvbW9tYXQoZ2VuZGVyKQ0KDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KZGVzbWF0IDwtIG1hdHJpeChOQSwgbnJvdz00LCBuY29sPTEpDQoNCiMgdXNlIGZ1bmN0aW9ucw0KZGVzbWF0WzEsIDFdIDwtIGZkZW5zaXR5KGtuZXQxKQ0KZGVzbWF0WzIsIDFdIDwtIGZkZW5zaXR5aW50cmEoa25ldDEsIGdlbmRlcl9tKQ0KZGVzbWF0WzMsIDFdIDwtIGZkZW5zaXR5aW50ZXIoa25ldDEsIGdlbmRlcl9tKQ0KZGVzbWF0WzQsIDFdIDwtIGZzY29sbmV0KGtuZXQxLCBnZW5kZXIpDQoNCmNvbG5hbWVzKGRlc21hdCkgPC0gYygiS3Vkb3MgbmV0d29yayIpDQpyb3duYW1lcyhkZXNtYXQpIDwtIGMoInRvdGFsIGRlbnNpdHkiLCAic2FtZSBnZW5kZXIgZGVuc2l0eSIsICJkaWZmZXJlbnQgZ2VuZGVyIGRlbnNpdHkiLCAiQ29sZW1hbidzIGhvbW9waGlseSBpbmRleCIpDQoNCg0KDQprbml0cjo6a2FibGUoZGVzbWF0LCBkaWdpdHM9MywgImh0bWwiLCBjYXB0aW9uPSJHZW5kZXIgc2VncmVnYXRpb24gaW4gZnJpZW5kc2hpcCBhbmQga3VkbyBuZXR3b3JrIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCiMjIyBDbHViIDINCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzJdXSAjIGdyYWIgY2x1YiANCmRmMiA8LSBjbHViZGF0YVtbMl1dDQoNCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIGZvciBzb21lIHJlYXNvbiBjb25zdHJ1Y3RpbmcgdGhlIGR5YWQtc2ltaWxhcml0eSBtYXRyaXggZm9yIGdlbmRlciB3aXRoIHRoZSByc2llbmEgb2JqZWN0IGRpZCBub3Qgd29yaywgc28gd2UgdXNlIHRoZSBjbHViZGF0YS5SRGF0YS4NCm1hbGUgPC0gZGYyJG1hbGUNCmZlbWFsZSA8LSBkZjIkZmVtYWxlDQpvdGhlciA8LSBkZjIkb3RoZXINCg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBjb25zdHJ1Y3QgZHlhZCBzaW1pbGFyaXR5IG1hdHJpeA0KZ2VuZGVyX20gPC0gZmhvbW9tYXQoZ2VuZGVyKQ0KDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KZGVzbWF0IDwtIG1hdHJpeChOQSwgbnJvdz00LCBuY29sPTEpDQoNCiMgdXNlIGZ1bmN0aW9ucw0KZGVzbWF0WzEsIDFdIDwtIGZkZW5zaXR5KGtuZXQxKQ0KZGVzbWF0WzIsIDFdIDwtIGZkZW5zaXR5aW50cmEoa25ldDEsIGdlbmRlcl9tKQ0KZGVzbWF0WzMsIDFdIDwtIGZkZW5zaXR5aW50ZXIoa25ldDEsIGdlbmRlcl9tKQ0KZGVzbWF0WzQsIDFdIDwtIGZzY29sbmV0KGtuZXQxLCBnZW5kZXIpDQoNCmNvbG5hbWVzKGRlc21hdCkgPC0gYygiS3Vkb3MgbmV0d29yayIpDQpyb3duYW1lcyhkZXNtYXQpIDwtIGMoInRvdGFsIGRlbnNpdHkiLCAic2FtZSBnZW5kZXIgZGVuc2l0eSIsICJkaWZmZXJlbnQgZ2VuZGVyIGRlbnNpdHkiLCAiQ29sZW1hbidzIGhvbW9waGlseSBpbmRleCIpDQoNCg0KDQprbml0cjo6a2FibGUoZGVzbWF0LCBkaWdpdHM9MywgImh0bWwiLCBjYXB0aW9uPSJHZW5kZXIgc2VncmVnYXRpb24gaW4gZnJpZW5kc2hpcCBhbmQga3VkbyBuZXR3b3JrIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCiMjIyBDbHViIDMNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzNdXSAjIGdyYWIgY2x1YiANCmRmMiA8LSBjbHViZGF0YVtbM11dDQoNCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIGZvciBzb21lIHJlYXNvbiBjb25zdHJ1Y3RpbmcgdGhlIGR5YWQtc2ltaWxhcml0eSBtYXRyaXggZm9yIGdlbmRlciB3aXRoIHRoZSByc2llbmEgb2JqZWN0IGRpZCBub3Qgd29yaywgc28gd2UgdXNlIHRoZSBjbHViZGF0YS5SRGF0YS4NCm1hbGUgPC0gZGYyJG1hbGUNCmZlbWFsZSA8LSBkZjIkZmVtYWxlDQpvdGhlciA8LSBkZjIkb3RoZXINCg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBjb25zdHJ1Y3QgZHlhZCBzaW1pbGFyaXR5IG1hdHJpeA0KZ2VuZGVyX20gPC0gZmhvbW9tYXQoZ2VuZGVyKQ0KDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KZGVzbWF0IDwtIG1hdHJpeChOQSwgbnJvdz00LCBuY29sPTEpDQoNCiMgdXNlIGZ1bmN0aW9ucw0KZGVzbWF0WzEsIDFdIDwtIGZkZW5zaXR5KGtuZXQxKQ0KZGVzbWF0WzIsIDFdIDwtIGZkZW5zaXR5aW50cmEoa25ldDEsIGdlbmRlcl9tKQ0KZGVzbWF0WzMsIDFdIDwtIGZkZW5zaXR5aW50ZXIoa25ldDEsIGdlbmRlcl9tKQ0KZGVzbWF0WzQsIDFdIDwtIGZzY29sbmV0KGtuZXQxLCBnZW5kZXIpDQoNCmNvbG5hbWVzKGRlc21hdCkgPC0gYygiS3Vkb3MgbmV0d29yayIpDQpyb3duYW1lcyhkZXNtYXQpIDwtIGMoInRvdGFsIGRlbnNpdHkiLCAic2FtZSBnZW5kZXIgZGVuc2l0eSIsICJkaWZmZXJlbnQgZ2VuZGVyIGRlbnNpdHkiLCAiQ29sZW1hbidzIGhvbW9waGlseSBpbmRleCIpDQoNCg0KDQprbml0cjo6a2FibGUoZGVzbWF0LCBkaWdpdHM9MywgImh0bWwiLCBjYXB0aW9uPSJHZW5kZXIgc2VncmVnYXRpb24gaW4gZnJpZW5kc2hpcCBhbmQga3VkbyBuZXR3b3JrIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCiMjIyBDbHViIDQNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzRdXSAjIGdyYWIgY2x1YiANCmRmMiA8LSBjbHViZGF0YVtbNF1dDQoNCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIGZvciBzb21lIHJlYXNvbiBjb25zdHJ1Y3RpbmcgdGhlIGR5YWQtc2ltaWxhcml0eSBtYXRyaXggZm9yIGdlbmRlciB3aXRoIHRoZSByc2llbmEgb2JqZWN0IGRpZCBub3Qgd29yaywgc28gd2UgdXNlIHRoZSBjbHViZGF0YS5SRGF0YS4NCm1hbGUgPC0gZGYyJG1hbGUNCmZlbWFsZSA8LSBkZjIkZmVtYWxlDQpvdGhlciA8LSBkZjIkb3RoZXINCg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBjb25zdHJ1Y3QgZHlhZCBzaW1pbGFyaXR5IG1hdHJpeA0KZ2VuZGVyX20gPC0gZmhvbW9tYXQoZ2VuZGVyKQ0KDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KZGVzbWF0IDwtIG1hdHJpeChOQSwgbnJvdz00LCBuY29sPTEpDQoNCiMgdXNlIGZ1bmN0aW9ucw0KZGVzbWF0WzEsIDFdIDwtIGZkZW5zaXR5KGtuZXQxKQ0KZGVzbWF0WzIsIDFdIDwtIGZkZW5zaXR5aW50cmEoa25ldDEsIGdlbmRlcl9tKQ0KZGVzbWF0WzMsIDFdIDwtIGZkZW5zaXR5aW50ZXIoa25ldDEsIGdlbmRlcl9tKQ0KZGVzbWF0WzQsIDFdIDwtIGZzY29sbmV0KGtuZXQxLCBnZW5kZXIpDQoNCmNvbG5hbWVzKGRlc21hdCkgPC0gYygiS3Vkb3MgbmV0d29yayIpDQpyb3duYW1lcyhkZXNtYXQpIDwtIGMoInRvdGFsIGRlbnNpdHkiLCAic2FtZSBnZW5kZXIgZGVuc2l0eSIsICJkaWZmZXJlbnQgZ2VuZGVyIGRlbnNpdHkiLCAiQ29sZW1hbidzIGhvbW9waGlseSBpbmRleCIpDQoNCg0KDQprbml0cjo6a2FibGUoZGVzbWF0LCBkaWdpdHM9MywgImh0bWwiLCBjYXB0aW9uPSJHZW5kZXIgc2VncmVnYXRpb24gaW4gZnJpZW5kc2hpcCBhbmQga3VkbyBuZXR3b3JrIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCiMjIyBDbHViIDUNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzVdXSAjIGdyYWIgY2x1YiANCmRmMiA8LSBjbHViZGF0YVtbNV1dDQoNCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIGZvciBzb21lIHJlYXNvbiBjb25zdHJ1Y3RpbmcgdGhlIGR5YWQtc2ltaWxhcml0eSBtYXRyaXggZm9yIGdlbmRlciB3aXRoIHRoZSByc2llbmEgb2JqZWN0IGRpZCBub3Qgd29yaywgc28gd2UgdXNlIHRoZSBjbHViZGF0YS5SRGF0YS4NCm1hbGUgPC0gZGYyJG1hbGUNCmZlbWFsZSA8LSBkZjIkZmVtYWxlDQpvdGhlciA8LSBkZjIkb3RoZXINCg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBjb25zdHJ1Y3QgZHlhZCBzaW1pbGFyaXR5IG1hdHJpeA0KZ2VuZGVyX20gPC0gZmhvbW9tYXQoZ2VuZGVyKQ0KDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KZGVzbWF0IDwtIG1hdHJpeChOQSwgbnJvdz00LCBuY29sPTEpDQoNCiMgdXNlIGZ1bmN0aW9ucw0KZGVzbWF0WzEsIDFdIDwtIGZkZW5zaXR5KGtuZXQxKQ0KZGVzbWF0WzIsIDFdIDwtIGZkZW5zaXR5aW50cmEoa25ldDEsIGdlbmRlcl9tKQ0KZGVzbWF0WzMsIDFdIDwtIGZkZW5zaXR5aW50ZXIoa25ldDEsIGdlbmRlcl9tKQ0KZGVzbWF0WzQsIDFdIDwtIGZzY29sbmV0KGtuZXQxLCBnZW5kZXIpDQoNCmNvbG5hbWVzKGRlc21hdCkgPC0gYygiS3Vkb3MgbmV0d29yayIpDQpyb3duYW1lcyhkZXNtYXQpIDwtIGMoInRvdGFsIGRlbnNpdHkiLCAic2FtZSBnZW5kZXIgZGVuc2l0eSIsICJkaWZmZXJlbnQgZ2VuZGVyIGRlbnNpdHkiLCAiQ29sZW1hbidzIGhvbW9waGlseSBpbmRleCIpDQoNCg0KDQprbml0cjo6a2FibGUoZGVzbWF0LCBkaWdpdHM9MywgImh0bWwiLCBjYXB0aW9uPSJHZW5kZXIgc2VncmVnYXRpb24gaW4gZnJpZW5kc2hpcCBhbmQga3VkbyBuZXR3b3JrIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCiMjIHstfQ0KDQpEZW5zaXR5IGluIHRoZSBrdWRvcyBuZXR3b3JrIGlzIG5vdCBtdWNoIGhpZ2hlciB3aXRoaW4tZ2VuZGVyIHRoYW4gYmV0d2Vlbi1nZW5kZXJzLCB0aG91Z2ggdGhpcyByYXRpbyBkaWZmZXJzIHBlciBjbHViIChhbmQgaW4gb25lIGNsdWJzIGJldHdlZW4tZ2VuZGVyIGt1ZG9zIGFyZSBtb3JlIGNvbW1vbikuIA0KDQpDb2xlbWFuJ3MgSG9tb3BoaWx5IGluZGljZXMgdmFyeSBhY3Jvc3MgY2x1YnMuIEluIHNvbWUgY2x1YnMgdGhlcmUgaXMgc2xpZ2h0IGdlbmRlciBzZWdyZWdhdGlvbiAob3Igc2FtZS1nZW5kZXIgcHJlZmVyZW5jZSkgaW4ga3Vkb3MgdGllcyAodmFsdWVzIGhpZ2hlciB0aGFuIDAsIGJ1dCByYXRoZXIgY2xvc2UgdG8gMCksIHRob3VnaCBpbiBvdGhlcnMgbWVtYmVycyB0ZW5kIHRvIGdpdmUga3Vkb3MgdG8gb3RoZXJzIG91dHNpZGUgdGhlaXIgb3duIGdlbmRlciBncm91cCAodmFsdWVzIGxvd2VyIHRoYW4gMCkuIA0KDQotLS0tDQoNCjxicj4NCg0KIyBCZWhhdmlvcg0KDQoNCldlIHBsb3R0ZWQgdGhlIGRldmVsb3BtZW50IG9mIHRoZSBtZWFuIG9mIHJ1bm5pbmcgYXR0cmlidXRlcyAoRmlndXJlIDUgb2YgdGhlIG1hbnVzY3JpcHQpLiBUaGUgc2NyaXB0IHRvIHJlcGxpY2F0ZSB0aGlzIHBsb3QgY2FuIGJlIGZvdW5kIFtoZXJlXShodHRwczovL3JvYmZyYW5rZW4uZ2l0aHViLmlvL1N0cmF2YS9kZXNmaWcuaHRtbCkuDQoNCg0KDQojIFdpdGhpbi1wZXJzb24gY2hhbmdlDQoNCiMjIHsudGFic2V0IC50YWJzZXQtZmFkZX0NCk5vdyBsZXQncyBhbHNvIGNoZWNrIGlmIGJlaGF2aW9yIHZhcmllZCBvdmVyIHRpbWUgd2l0aGluIGluZGl2aWR1YWxzLiBXaXRoaW4tcGVyc29uIHZhcmlhdGlvbiBpcyBhIHByZXJlcXVpc2l0ZSBmb3IgaWRlbnRpZnlpbmcgaW5mbHVlbmNlIGVmZmVjdHMgb24gYmVoYXZpb3IuIERvd24gYmVsb3cgd2UgZGVtb25zdHJhdGUgaG93IHJ1bm5pbmcgYWN0aXZpdHkgdmFyaWVzIHdpdGhpbiBpbmRpdmlkdWFscyBvdmVyIHRpbWUsIGluIGFic29sdXRlIHNjb3JlcyAoaS5lLiBpbiB0aW1lcyBwZXIgd2VlaykuDQoNCiMjIyBDbHViIDENCg0KYGBge3IgY2xhc3Muc291cmNlID0gJ2ZvbGQtaGlkZSd9DQpkZiA8LSBjbHViZGF0YVtbMV1dICMgZ3JhYiBjbHViDQoNCiMgY2hlY2sgd2l0aGluLXBlcnNvbiB2YXJpYWJpbGl0eSBvZiBydW5uaW5nIGZyZXF1ZW5jeQ0KIyBhYnNvbHV0ZSBzY29yZXMNCnNpemUgPC0gZGYkbmV0c2l6ZQ0KeSA8LSBhcnJheShjKGRmJGZyZXFfcnVuWywsXSkpDQp4IDwtIHJlcCgxOjEyLCBzaXplKQ0KZGYgPC0gZGF0YS5mcmFtZSh5LCB4KQ0KZGYgIDwtIGRmIFsob3JkZXIoZGYkeCkpLCBdDQpkZiRpZCA8LSByZXAoMTpzaXplLCAxMikNCg0KIyBnZXQgcmFuZG9tIHNhbXBsZSBvZiA5IHBlcnNvbnMNCnNhbXBsZSA8LSBzYW1wbGUoYygxOnNpemUpLCBzaXplPTksIHJlcGxhY2U9RikNCmRmX25ldyA8LSBkcGx5cjo6ZmlsdGVyKGRmLCBpZCAlaW4lIHNhbXBsZSkNCg0KIyBwbG90IGdyb3d0aCB0cmFqZWN0b3JpZXMgb2YgcmFuZG9tIHNhbXBsZSBvZiA5IG9mIGFsbCBjbHViIG1lbWJlcnMNCnAgPC0gZ2dwbG90KGRhdGEgPSBkZl9uZXcsIGFlcyh4LCB5KSkgKyBnZW9tX2xpbmUoKSsNCiAgZmFjZXRfd3JhcCh+aWQpDQpwICsgc2NhbGVfeF9jb250aW51b3VzKGJyZWFrcyA9IHNlcSgxLCAxMiwgMSkpICsgc2NhbGVfeV9jb250aW51b3VzKGJyZWFrcyA9IHNlcSgwLCA4LCAxKSkgKyANCiBnZ3RpdGxlKCJHcm93dGggdHJhamVjdG9yaWVzIGluIHJ1bm5pbmcgZnJlcXVlbmN5IG92ZXIgdGltZSBvZiBhIHJhbmRvbSBzYW1wbGUgb2YgOSBhY3RvcnMiKSArDQogIHhsYWIoIlRpbWUgaW4gbW9udGhzIikgKyB5bGFiKCJSdW5uaW5nIGZyZXF1ZW5jeSBpbiB0aW1lcyBwZXIgd2VlayIpDQoNCmBgYA0KDQojIyMgQ2x1YiAyDQoNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFbWzJdXSAjIGdyYWIgY2x1Yg0KDQojIGNoZWNrIHdpdGhpbi1wZXJzb24gdmFyaWFiaWxpdHkgb2YgcnVubmluZyBmcmVxdWVuY3kNCiMgYWJzb2x1dGUgc2NvcmVzDQpzaXplIDwtIGRmJG5ldHNpemUNCnkgPC0gYXJyYXkoYyhkZiRmcmVxX3J1blssLF0pKQ0KeCA8LSByZXAoMToxMiwgc2l6ZSkNCmRmIDwtIGRhdGEuZnJhbWUoeSwgeCkNCmRmICA8LSBkZiBbKG9yZGVyKGRmJHgpKSwgXQ0KZGYkaWQgPC0gcmVwKDE6c2l6ZSwgMTIpDQoNCiMgZ2V0IHJhbmRvbSBzYW1wbGUgb2YgOSBwZXJzb25zDQpzYW1wbGUgPC0gc2FtcGxlKGMoMTpzaXplKSwgc2l6ZT05LCByZXBsYWNlPUYpDQpkZl9uZXcgPC0gZHBseXI6OmZpbHRlcihkZiwgaWQgJWluJSBzYW1wbGUpDQoNCiMgcGxvdCBncm93dGggdHJhamVjdG9yaWVzIG9mIHJhbmRvbSBzYW1wbGUgb2YgOSBvZiBhbGwgY2x1YiBtZW1iZXJzDQpwIDwtIGdncGxvdChkYXRhID0gZGZfbmV3LCBhZXMoeCwgeSkpICsgZ2VvbV9saW5lKCkrDQogIGZhY2V0X3dyYXAofmlkKQ0KcCArIHNjYWxlX3hfY29udGludW91cyhicmVha3MgPSBzZXEoMSwgMTIsIDEpKSArIHNjYWxlX3lfY29udGludW91cyhicmVha3MgPSBzZXEoMCwgOCwgMSkpICsgDQogZ2d0aXRsZSgiR3Jvd3RoIHRyYWplY3RvcmllcyBpbiBydW5uaW5nIGZyZXF1ZW5jeSBvdmVyIHRpbWUgb2YgYSByYW5kb20gc2FtcGxlIG9mIDkgYWN0b3JzIikgKw0KICB4bGFiKCJUaW1lIGluIG1vbnRocyIpICsgeWxhYigiUnVubmluZyBmcmVxdWVuY3kgaW4gdGltZXMgcGVyIHdlZWsiKQ0KDQpgYGANCg0KDQojIyMgQ2x1YiAzDQoNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFbWzNdXSAjIGdyYWIgY2x1Yg0KDQojIGNoZWNrIHdpdGhpbi1wZXJzb24gdmFyaWFiaWxpdHkgb2YgcnVubmluZyBmcmVxdWVuY3kNCiMgYWJzb2x1dGUgc2NvcmVzDQpzaXplIDwtIGRmJG5ldHNpemUNCnkgPC0gYXJyYXkoYyhkZiRmcmVxX3J1blssLF0pKQ0KeCA8LSByZXAoMToxMiwgc2l6ZSkNCmRmIDwtIGRhdGEuZnJhbWUoeSwgeCkNCmRmICA8LSBkZiBbKG9yZGVyKGRmJHgpKSwgXQ0KZGYkaWQgPC0gcmVwKDE6c2l6ZSwgMTIpDQoNCiMgZ2V0IHJhbmRvbSBzYW1wbGUgb2YgOSBwZXJzb25zDQpzYW1wbGUgPC0gc2FtcGxlKGMoMTpzaXplKSwgc2l6ZT05LCByZXBsYWNlPUYpDQpkZl9uZXcgPC0gZHBseXI6OmZpbHRlcihkZiwgaWQgJWluJSBzYW1wbGUpDQoNCiMgcGxvdCBncm93dGggdHJhamVjdG9yaWVzIG9mIHJhbmRvbSBzYW1wbGUgb2YgOSBvZiBhbGwgY2x1YiBtZW1iZXJzDQpwIDwtIGdncGxvdChkYXRhID0gZGZfbmV3LCBhZXMoeCwgeSkpICsgZ2VvbV9saW5lKCkrDQogIGZhY2V0X3dyYXAofmlkKQ0KcCArIHNjYWxlX3hfY29udGludW91cyhicmVha3MgPSBzZXEoMSwgMTIsIDEpKSArIHNjYWxlX3lfY29udGludW91cyhicmVha3MgPSBzZXEoMCwgOCwgMSkpICsgDQogICBnZ3RpdGxlKCJHcm93dGggdHJhamVjdG9yaWVzIGluIHJ1bm5pbmcgZnJlcXVlbmN5IG92ZXIgdGltZSBvZiBhIHJhbmRvbSBzYW1wbGUgb2YgOSBhY3RvcnMiKSArDQogIHhsYWIoIlRpbWUgaW4gbW9udGhzIikgKyB5bGFiKCJSdW5uaW5nIGZyZXF1ZW5jeSBpbiB0aW1lcyBwZXIgd2VlayIpDQoNCmBgYA0KDQojIyMgQ2x1YiA0DQoNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFbWzRdXSAjIGdyYWIgY2x1Yg0KDQojIGNoZWNrIHdpdGhpbi1wZXJzb24gdmFyaWFiaWxpdHkgb2YgcnVubmluZyBmcmVxdWVuY3kNCiMgYWJzb2x1dGUgc2NvcmVzDQpzaXplIDwtIGRmJG5ldHNpemUNCnkgPC0gYXJyYXkoYyhkZiRmcmVxX3J1blssLF0pKQ0KeCA8LSByZXAoMToxMiwgc2l6ZSkNCmRmIDwtIGRhdGEuZnJhbWUoeSwgeCkNCmRmICA8LSBkZiBbKG9yZGVyKGRmJHgpKSwgXQ0KZGYkaWQgPC0gcmVwKDE6c2l6ZSwgMTIpDQoNCiMgZ2V0IHJhbmRvbSBzYW1wbGUgb2YgOSBwZXJzb25zDQpzYW1wbGUgPC0gc2FtcGxlKGMoMTpzaXplKSwgc2l6ZT05LCByZXBsYWNlPUYpDQpkZl9uZXcgPC0gZHBseXI6OmZpbHRlcihkZiwgaWQgJWluJSBzYW1wbGUpDQoNCiMgcGxvdCBncm93dGggdHJhamVjdG9yaWVzIG9mIHJhbmRvbSBzYW1wbGUgb2YgOSBvZiBhbGwgY2x1YiBtZW1iZXJzDQpwIDwtIGdncGxvdChkYXRhID0gZGZfbmV3LCBhZXMoeCwgeSkpICsgZ2VvbV9saW5lKCkrDQogIGZhY2V0X3dyYXAofmlkKQ0KcCArIHNjYWxlX3hfY29udGludW91cyhicmVha3MgPSBzZXEoMSwgMTIsIDEpKSArIHNjYWxlX3lfY29udGludW91cyhicmVha3MgPSBzZXEoMCwgOCwgMSkpICsgDQogZ2d0aXRsZSgiR3Jvd3RoIHRyYWplY3RvcmllcyBpbiBydW5uaW5nIGZyZXF1ZW5jeSBvdmVyIHRpbWUgb2YgYSByYW5kb20gc2FtcGxlIG9mIDkgYWN0b3JzIikgKw0KICB4bGFiKCJUaW1lIGluIG1vbnRocyIpICsgeWxhYigiUnVubmluZyBmcmVxdWVuY3kgaW4gdGltZXMgcGVyIHdlZWsiKQ0KDQpgYGANCg0KDQojIyMgQ2x1YiA1DQoNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFbWzVdXSAjIGdyYWIgY2x1Yg0KDQojIGNoZWNrIHdpdGhpbi1wZXJzb24gdmFyaWFiaWxpdHkgb2YgcnVubmluZyBmcmVxdWVuY3kNCiMgYWJzb2x1dGUgc2NvcmVzDQpzaXplIDwtIGRmJG5ldHNpemUNCnkgPC0gYXJyYXkoYyhkZiRmcmVxX3J1blssLF0pKQ0KeCA8LSByZXAoMToxMiwgc2l6ZSkNCmRmIDwtIGRhdGEuZnJhbWUoeSwgeCkNCmRmICA8LSBkZiBbKG9yZGVyKGRmJHgpKSwgXQ0KZGYkaWQgPC0gcmVwKDE6c2l6ZSwgMTIpDQoNCiMgZ2V0IHJhbmRvbSBzYW1wbGUgb2YgOSBwZXJzb25zDQpzYW1wbGUgPC0gc2FtcGxlKGMoMTpzaXplKSwgc2l6ZT05LCByZXBsYWNlPUYpDQpkZl9uZXcgPC0gZHBseXI6OmZpbHRlcihkZiwgaWQgJWluJSBzYW1wbGUpDQoNCiMgcGxvdCBncm93dGggdHJhamVjdG9yaWVzIG9mIHJhbmRvbSBzYW1wbGUgb2YgOSBvZiBhbGwgY2x1YiBtZW1iZXJzDQpwIDwtIGdncGxvdChkYXRhID0gZGZfbmV3LCBhZXMoeCwgeSkpICsgZ2VvbV9saW5lKCkrDQogIGZhY2V0X3dyYXAofmlkKQ0KcCArIHNjYWxlX3hfY29udGludW91cyhicmVha3MgPSBzZXEoMSwgMTIsIDEpKSArIHNjYWxlX3lfY29udGludW91cyhicmVha3MgPSBzZXEoMCwgOCwgMSkpICsgDQogIGdndGl0bGUoIkdyb3d0aCB0cmFqZWN0b3JpZXMgaW4gcnVubmluZyBmcmVxdWVuY3kgb3ZlciB0aW1lIG9mIGEgcmFuZG9tIHNhbXBsZSBvZiA5IGFjdG9ycyIpICsNCiAgeGxhYigiVGltZSBpbiBtb250aHMiKSArIHlsYWIoIlJ1bm5pbmcgZnJlcXVlbmN5IGluIHRpbWVzIHBlciB3ZWVrIikNCg0KYGBgDQoNCiMjIHstfQ0KDQpUaGVyZSBzZWVtcyB0byBiZSAnc3VmZmljaWVudCcgd2l0aGluLXBlcnNvbiB2YXJpYWJpbGl0eSBpbiBydW5uaW5nIGJlaGF2aW9yLCBhdCBsZWFzdCBpbiBmcmVxdWVuY3kuDQoNCi0tLS0NCg0KIyBDb3JyZWxhdGlvbiBiZXR3ZWVuIGZyZXF1ZW5jeSBhbmQgdm9sdW1lDQoNCkxldCdzIHBsb3QgdGhlIHJlbGF0aW9uIGJldHdlZW4gZnJlcXVlbmN5IGluIHRpbWVzIHBlciB3ZWVrIGFuZCB2b2x1bWUgaW4gaG91cnMgcGVyIHdlZWsuIFdlIGFsc28gY2FsY3VsYXRlIEtlbmRhbGwncyB0YXUtYiwgaS5lLiBhIG5vbi1wYXJhbWV0cmljIG1lYXN1cmUgb2YgY29ycmVsYXRpb24gb24gcmFua3MgKGNmLiBAa2hhbWlzKS4NCg0KIyMgey50YWJzZXQgLnRhYnNldC1mYWRlfQ0KDQojIyMgQ2x1YiAxDQoNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFbWzFdXSAjIGdyYWIgY2x1YiANCmRmIDwtIGRhdGEuZnJhbWUoeCA9IGFzLm1hdHJpeChkZiR0aW1lX3J1biksIHkgPSBhcy5tYXRyaXgoZGYkZnJlcV9ydW4pKQ0KDQpjIDwtIGNvci50ZXN0KGRmJHgsIGRmJHksIG1ldGhvZD0ia2VuZGFsbCIpDQoNCnBsb3QoZGYsIHR5cGU9ImIiLCANCiAgICAgbWFpbiA9ICJSZWxhdGlvbiBiZXR3ZWVuIHdlZWtseSBydW5uaW5nIHZhcmlhYmxlczogZnJlcXVlbmN5IGFuZCAoaGFsZikgaG91cnMiLA0KICAgICBzdWIgPSAiTm90ZTogcnVubmluZyBmcmVxdWVuY3kgY2FwcGVkIHdpdGggYSBtYXhpbXVtIG9mIDcsIGhvdXJzIHdpdGggYSBtYXhpbXVtIG9mIDciLA0KICAgICB4bGFiID0gIkhvdXJzIHBlciB3ZWVrIiwgeWxhYiA9ICJzZXNzaW9ucyBwZXIgd2VlayIsDQogICAgIGNvbD0iYmx1ZSIsIGx3ZD1jKDEscmVwKDYsMTAwMDApKSkgKyANCiAgdGV4dCh4ID0gMS43LCB5ID0gNSwgcm91bmQoYyRlc3RpbWF0ZSwgZGlnaXRzPTIpKSArDQogIHRleHQoeCA9IC43LCB5ID0gNSwgIktlbmRhbGwncyB0YXUtYiA9IikNCg0KYGBgDQoNCiMjIyBDbHViIDINCg0KYGBge3J9DQpkZiA8LSBjbHViZGF0YVtbMl1dICMgZ3JhYiBjbHViIA0KZGYgPC0gZGF0YS5mcmFtZSh4ID0gYXMubWF0cml4KGRmJHRpbWVfcnVuKSwgeSA9IGFzLm1hdHJpeChkZiRmcmVxX3J1bikpDQpjIDwtIGNvci50ZXN0KGRmJHgsZGYkeSxtZXRob2Q9ImtlbmRhbGwiKQ0KDQpwbG90KGRmLCB0eXBlPSJiIiwgDQogICAgIG1haW4gPSAiUmVsYXRpb24gYmV0d2VlbiB3ZWVrbHkgcnVubmluZyB2YXJpYWJsZXM6IGZyZXF1ZW5jeSBhbmQgaG91cnMiLA0KICAgICBzdWIgPSAiTm90ZTogcnVubmluZyBmcmVxdWVuY3kgY2FwcGVkIHdpdGggYSBtYXhpbXVtIG9mIDcsIGhvdXJzIHdpdGggYSBtYXhpbXVtIG9mIDciLA0KICAgICB4bGFiID0gImhvdXJzIHBlciB3ZWVrIiwgeWxhYiA9ICJzZXNzaW9ucyBwZXIgd2VlayIsDQogICAgIGNvbD0iYmx1ZSIsIGx3ZD1jKDEscmVwKDYsMTAwMDApKSkgKyANCiAgdGV4dCh4ID0gMS43LCB5ID0gNSwgcm91bmQoYyRlc3RpbWF0ZSwgZGlnaXRzPTIpKSArDQogIHRleHQoeCA9IC43LCB5ID0gNSwgIktlbmRhbGwncyB0YXUtYiA9IikNCmBgYA0KDQojIyMgQ2x1YiAzDQoNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFbWzNdXSAjIGdyYWIgY2x1YiANCmRmIDwtIGRhdGEuZnJhbWUoeCA9IGFzLm1hdHJpeChkZiR0aW1lX3J1biksIHkgPSBhcy5tYXRyaXgoZGYkZnJlcV9ydW4pKQ0KYyA8LSBjb3IudGVzdChkZiR4LGRmJHksbWV0aG9kPSJrZW5kYWxsIikNCg0KcGxvdChkZiwgdHlwZT0iYiIsIA0KICAgICBtYWluID0gIlJlbGF0aW9uIGJldHdlZW4gd2Vla2x5IHJ1bm5pbmcgdmFyaWFibGVzOiBmcmVxdWVuY3kgYW5kIGhvdXJzIiwNCiAgICAgc3ViID0gIk5vdGU6IHJ1bm5pbmcgZnJlcXVlbmN5IGNhcHBlZCB3aXRoIGEgbWF4aW11bSBvZiA3LCBob3VycyB3aXRoIGEgbWF4aW11bSBvZiA3IiwNCiAgICAgeGxhYiA9ICJob3VycyBwZXIgd2VlayIsIHlsYWIgPSAic2Vzc2lvbnMgcGVyIHdlZWsiLA0KICAgICBjb2w9ImJsdWUiLCBsd2Q9YygxLHJlcCg2LDEwMDAwKSkpICsgDQogIHRleHQoeCA9IDEuNywgeSA9IDUsIHJvdW5kKGMkZXN0aW1hdGUsIGRpZ2l0cz0yKSkgKw0KICB0ZXh0KHggPSAuNywgeSA9IDUsICJLZW5kYWxsJ3MgdGF1LWIgPSIpDQpgYGANCg0KIyMjIENsdWIgNA0KDQpgYGB7cn0NCmRmIDwtIGNsdWJkYXRhW1s0XV0gIyBncmFiIGNsdWIgDQpkZiA8LSBkYXRhLmZyYW1lKHggPSBhcy5tYXRyaXgoZGYkdGltZV9ydW4pLCB5ID0gYXMubWF0cml4KGRmJGZyZXFfcnVuKSkNCmMgPC0gY29yLnRlc3QoZGYkeCxkZiR5LG1ldGhvZD0ia2VuZGFsbCIpDQoNCnBsb3QoZGYsIHR5cGU9ImIiLCANCiAgICAgbWFpbiA9ICJSZWxhdGlvbiBiZXR3ZWVuIHdlZWtseSBydW5uaW5nIHZhcmlhYmxlczogZnJlcXVlbmN5IGFuZCBob3VycyIsDQogICAgIHN1YiA9ICJOb3RlOiBydW5uaW5nIGZyZXF1ZW5jeSBjYXBwZWQgd2l0aCBhIG1heGltdW0gb2YgNywgaG91cnMgd2l0aCBhIG1heGltdW0gb2YgNyIsDQogICAgIHhsYWIgPSAiaG91cnMgcGVyIHdlZWsiLCB5bGFiID0gInNlc3Npb25zIHBlciB3ZWVrIiwNCiAgICAgY29sPSJibHVlIiwgbHdkPWMoMSxyZXAoNiwxMDAwMCkpKSArIA0KICB0ZXh0KHggPSAxLjUsIHkgPSA1LCByb3VuZChjJGVzdGltYXRlLCBkaWdpdHM9MikpICsNCiAgdGV4dCh4ID0gLjcsIHkgPSA1LCAiS2VuZGFsbCdzIHRhdS1iID0iKQ0KYGBgDQoNCiMjIyBDbHViIDUNCg0KYGBge3J9DQpkZiA8LSBjbHViZGF0YVtbNV1dICMgZ3JhYiBjbHViIA0KZGYgPC0gZGF0YS5mcmFtZSh4ID0gYXMubWF0cml4KGRmJHRpbWVfcnVuKSwgeSA9IGFzLm1hdHJpeChkZiRmcmVxX3J1bikpDQpjIDwtIGNvci50ZXN0KGRmJHgsZGYkeSxtZXRob2Q9ImtlbmRhbGwiKQ0KDQpwbG90KGRmLCB0eXBlPSJiIiwgDQogICAgIG1haW4gPSAiUmVsYXRpb24gYmV0d2VlbiB3ZWVrbHkgcnVubmluZyB2YXJpYWJsZXM6IGZyZXF1ZW5jeSBhbmQgaG91cnMiLA0KICAgICBzdWIgPSAiTm90ZTogcnVubmluZyBmcmVxdWVuY3kgY2FwcGVkIHdpdGggYSBtYXhpbXVtIG9mIDcsIGhvdXJzIHdpdGggYSBtYXhpbXVtIG9mIDciLA0KICAgICB4bGFiID0gImhvdXJzIHBlciB3ZWVrIiwgeWxhYiA9ICJzZXNzaW9ucyBwZXIgd2VlayIsDQogICAgIGNvbD0iYmx1ZSIsIGx3ZD1jKDEscmVwKDYsMTAwMDApKSkgKyANCiAgdGV4dCh4ID0gMiwgeSA9IDcsIHJvdW5kKGMkZXN0aW1hdGUsIGRpZ2l0cz0yKSkgKw0KICB0ZXh0KHggPSAuNywgeSA9IDcsICJLZW5kYWxsJ3MgdGF1LWIgPSIpDQpgYGANCg0KIyMgey19DQoNCkFsdGhvdWdoIGZyZXF1ZW5jeSBhbmQgZHVyYXRpb24gYXJlIHN0cm9uZ2x5IHJlbGF0ZWQsIHRoZXJlIGlzIHNvbWUgaW52YXJpYW5jZS4gDQoNCi0tLS0NCg0KPGJyPg0KDQoNCg0KIyBOZXR3b3JrIGF1dG9jb3JyZWxhdGlvbg0KDQojIyB7LnRhYnNldCAudGFic2V0LWZhZGV9DQpXZSBoYXZlIG5vdyBjb3ZlcmVkIHRoZSBzcG9ydCBhY3Rpdml0eSBsZXZlbHMgb2Ygb3VyIGNsdWItYXRobGV0ZXMsIGFuZCB0aGUgZXh0ZW50IHRvIHdoaWNoIGt1ZG9zLWFzc29jaWF0aW9ucyBhcmUgc2VncmVnYXRlZCBhbG9uZyBnZW5kZXIuIExhc3QsIHdlIHdpbGwgZXhwbG9yZSBpZiBrdWRvcy10aWVzIGFyZSBhbHNvIHNlZ3JlZ2F0ZWQgYWxvbmcgYWN0aXZpdHkgbGV2ZWxzLiBPciBpbiBvdGhlciB3b3JkczogZG8gcGVvcGxlIHdpdGggc2ltaWxhciBhY3Rpdml0eSBsZXZlbHMgdGVuZCB0byBzb2NpYWxpemUgdG8gYSBncmVhdGVyIGV4dGVudCAtIGJ5IGV4Y2hhbmdpbmcga3Vkb3MgLSBldmVuIHdoZW4gdGFraW5nIGludG8gYWNjb3VudCB0aGUgb3Bwb3J0dW5pdHkgc3RydWN0dXJlcyBmb3IgJ2ludGVyYWN0aW5nJyB3aXRoIChkaXMpc2ltaWxhciBvdGhlcnM/IA0KDQpXZSB1c2UgTW9yYW4ncyBJIHNwYXRpYWwgYXV0b2NvcnJlbGF0aW9uIG1lYXN1cmUgZm9yIHRoaXMsIHdoaWNoIGlzIHRoZSBjb3JyZWxhdGlvbiBiZXR3ZWVuIHRoZSBiZWhhdmlvcmFsIHNjb3JlIG9mIGFjdG9yICppKiBhbmQgdGhlICh0b3RhbC9tZWFuKSBiZWhhdmlvcmFsIHNjb3JlIG9mIGFsdGVycyAqaiogdG8gd2hvbSAqaSogaXMgY29ubmVjdGVkICoqZGlyZWN0bHkqKi4gV2UgYWxzbyBjYWxjdWxhdGVkIE1vcmFuJ3MgSSBieSBpbmNsdWRpbmcgdGhlIGJlaGF2aW9yYWwgc2NvcmVzIG9mIHRoZSBhY3RvcnMgKmgqIHRvIHdob20gKmkqIGlzIGluZGlyZWN0bHkgdGllZCwgYW5kIHVzZWQgdGhlIG5lZ2F0aXZlIGV4cG9uZW50aWFsIGZ1bmN0aW9uIGFzIGRlc2NyaWJlZCBieSBAY2hlbjIwMTMgYXMgYSBkaXN0YW5jZS1kZWNheSBmdW5jdGlvbiBmb3IgYXNzaWduaW5nIHdlaWdodHMuDQoNCiMjIyBDbHViIDENCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFbWzFdXSAjIGdyYWIgY2x1YiANCg0KIyBnZXQgYmVoYXZpb3JhbCBkYXRhDQojIGF0IHRpbWUgdD0xDQp0PTENCmZyZXExIDwtIGRmJGZyZXFfcnVuWywsdF0gIyBydW5uaW5nIGZyZXF1ZW5jaWVzIHdhdmUgMQ0Kdm9sMSA8LSBkZiR0aW1lX3J1blssLHRdICMgcnVubmluZyB2b2x1bWUgd2F2ZSAxDQoNCiMgZXhjbHVkZSBOQXMgDQpuYSA8LSB3aGljaChpcy5uYShmcmVxMSkpDQpmcmVxMSA8LSBmcmVxMVstbmFdDQp2b2wxIDwtIHZvbDFbLW5hXQ0KDQojIGdldCBrdWRvcyBuZXQNCmtuZXQxIDwtIGRmJGt1ZG9bLCx0XQ0KIyBleGNsdWRlIE5Bcw0Ka25ldDEgPC0ga25ldDFbLW5hLC1uYV0NCg0KIyBhcyBuZXR3b3JrIG9iamVjdA0Ka25ldDEgPC0gbmV0d29yazo6YXMubmV0d29yayhrbmV0MSkNCg0KIyB3ZSBpbmNsdWRlIGdlb2Rpc3RhbmNlczogc2hvcnRlc3QgcGF0aCBsZW5ndGhzIGZyb20gaSB0byBqDQpnZW9kaXN0YW5jZXMgPC0gc25hOjpnZW9kaXN0KGtuZXQxLCBjb3VudC5wYXRocz1UKQ0KZ2VvZGlzdGFuY2VzIDwtIGdlb2Rpc3RhbmNlcyRnZGlzdCANCg0KIyBzZXQgdGhlIGRpc3RhbmNlICd0byB5b3Vyc2VsZicgdG8gJ0luZicNCmRpYWcoZ2VvZGlzdGFuY2VzKSA8LSBJbmYNCg0KIyBmaXJzdCBjYWxjdWxhdGUgTW9yYW4ncyBpIGZvciBhbHRlcnMgYXQgZGlzdGFuY2UgMS4NCndlaWdodHMxIDwtIGdlb2Rpc3RhbmNlcyA9PSAxDQoNCiMgYW5kIHVzZSB0aGUgbmVnYXRpdmUgZXhwb25lbnRpYWwgZGlzdGFuY2UtZGVjYXkgZnVuY3Rpb24NCndlaWdodHMyIDwtIGV4cCgtZ2VvZGlzdGFuY2VzKQ0KDQojIGNhbGN1bGF0ZSBNb3JhbidzIEkNCiMgZm9yIGRpc3RhbmNlLTEgYW5kIHdpdGggZGlzdGFuY2UgZGVjYXksIGluIHRoZSBrdWRvcyBuZXR3b3JrLCBmb3IgZnJlcXVlbmN5IGFuZCB2b2x1bWUgIHJlc3BlY3RpdmVseQ0KIyB3ZSBkbyBub3Qgcm93IHN0YW5kYXJkaXplIQ0KTWZyZXEgPC0gZk1vcmFuLkkoZnJlcTEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSB3ZWlnaHRzMSwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KTWZyZXFfZGlzdGQgPC0gZk1vcmFuLkkoZnJlcTEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSB3ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KDQpNdm9sIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSB3ZWlnaHRzMSwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KTXZvbF9kaXN0ZCA8LSBmTW9yYW4uSSh2b2wxLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCg0KIyBtYWtlIG9iamVjdCB0byBzdG9yZSByZXN1bHRzDQojIDEuIGZyZXF1ZW5jeQ0KZl9tYXQgPC0gbWF0cml4KE5BLCBucm93PTIsIG5jb2w9NCkNCg0KZl9tYXRbMSwxXSA8LSBNZnJlcSRvYnNlcnZlZA0KZl9tYXRbMSwyXSA8LSBNZnJlcSRleHBlY3RlZA0KZl9tYXRbMSwzXSA8LSBNZnJlcSRzZA0KZl9tYXRbMSw0XSA8LSBNZnJlcSRwLnZhbHVlDQpmX21hdFsyLDFdIDwtIE1mcmVxX2Rpc3RkJG9ic2VydmVkDQpmX21hdFsyLDJdIDwtIE1mcmVxX2Rpc3RkJGV4cGVjdGVkDQpmX21hdFsyLDNdIDwtIE1mcmVxX2Rpc3RkJHNkDQpmX21hdFsyLDRdIDwtIE1mcmVxX2Rpc3RkJHAudmFsdWUNCg0KIyAyLiB2b2x1bWUNCnZfbWF0IDwtIG1hdHJpeChOQSwgbnJvdz0yLCBuY29sPTQpDQp2X21hdFsxLDFdIDwtIE12b2wkb2JzZXJ2ZWQNCnZfbWF0WzEsMl0gPC0gTXZvbCRleHBlY3RlZA0Kdl9tYXRbMSwzXSA8LSBNdm9sJHNkDQp2X21hdFsxLDRdIDwtIE12b2wkcC52YWx1ZQ0Kdl9tYXRbMiwxXSA8LSBNdm9sX2Rpc3RkJG9ic2VydmVkDQp2X21hdFsyLDJdIDwtIE12b2xfZGlzdGQkZXhwZWN0ZWQNCnZfbWF0WzIsM10gPC0gTXZvbF9kaXN0ZCRzZA0Kdl9tYXRbMiw0XSA8LSBNdm9sX2Rpc3RkJHAudmFsdWUNCg0KY29sbmFtZXMoZl9tYXQpIDwtIGNvbG5hbWVzKHZfbWF0KSA8LSBjKCJvYnNlcnZlZCIsICJleHBlY3RlZCIsICJzZCIsICJwLXZhbHVlIikNCnJvd25hbWVzKGZfbWF0KSA8LSByb3duYW1lcyh2X21hdCkgPC0gYygiZGlyZWN0IGt1ZG9zIHRpZXMiLCAiZGlyZWN0IGFuZCBpbmRpcmVjdCBrdWRvcyB0aWVzIChkaXN0YW5jZS1kZWNheSkiKQ0KDQprbml0cjo6a2FibGUoZl9tYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249Ik1vcmFuJ3MgSSBzdGF0aXN0aWMgZm9yIHNwYXRpYWwgYXV0b2NvcnJlbGF0aW9uIGJhc2VkIG9uIGdlb2Rpc3RhbmNlcyBhbmQgd2Vla2x5IHJ1bm5pbmcgZnJlcXVlbmN5IikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KDQprbml0cjo6a2FibGUodl9tYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249Ik1vcmFuJ3MgSSBzdGF0aXN0aWMgZm9yIHNwYXRpYWwgYXV0b2NvcnJlbGF0aW9uIGJhc2VkIG9uIGdlb2Rpc3RhbmNlcyBhbmQgbW9udGhseSBydW5uaW5nIHZvbHVtZSIpICU+JSANCiAga2FibGVFeHRyYTo6a2FibGVfc3R5bGluZyhib290c3RyYXBfb3B0aW9ucyA9IGMoInN0cmlwZWQiLCAiaG92ZXIiKSkNCmBgYA0KDQojIyMgQ2x1YiAyDQpgYGB7cn0NCmRmIDwtIGNsdWJkYXRhW1syXV0gIyBncmFiIGNsdWIgDQoNCiMgZ2V0IGJlaGF2aW9yYWwgZGF0YQ0KIyBhdCB0aW1lIHQ9MQ0KdD0xDQpmcmVxMSA8LSBkZiRmcmVxX3J1blssLHRdICMgcnVubmluZyBmcmVxdWVuY2llcyB3YXZlIDENCnZvbDEgPC0gZGYkdGltZV9ydW5bLCx0XSAjIHJ1bm5pbmcgdm9sdW1lIHdhdmUgMQ0KDQojIGV4Y2x1ZGUgTkFzIA0KbmEgPC0gd2hpY2goaXMubmEoZnJlcTEpKQ0KZnJlcTEgPC0gZnJlcTFbLW5hXQ0Kdm9sMSA8LSB2b2wxWy1uYV0NCg0KIyBnZXQga3Vkb3MgbmV0DQprbmV0MSA8LSBkZiRrdWRvWywsdF0NCiMgZXhjbHVkZSBOQXMNCmtuZXQxIDwtIGtuZXQxWy1uYSwtbmFdDQoNCiMgYXMgbmV0d29yayBvYmplY3QNCmtuZXQxIDwtIG5ldHdvcms6OmFzLm5ldHdvcmsoa25ldDEpDQoNCiMgd2UgaW5jbHVkZSBnZW9kaXN0YW5jZXM6IHNob3J0ZXN0IHBhdGggbGVuZ3RocyBmcm9tIGkgdG8gag0KZ2VvZGlzdGFuY2VzIDwtIHNuYTo6Z2VvZGlzdChrbmV0MSwgY291bnQucGF0aHM9VCkNCmdlb2Rpc3RhbmNlcyA8LSBnZW9kaXN0YW5jZXMkZ2Rpc3QgDQoNCiMgc2V0IHRoZSBkaXN0YW5jZSAndG8geW91cnNlbGYnIHRvICdJbmYnDQpkaWFnKGdlb2Rpc3RhbmNlcykgPC0gSW5mDQoNCiMgZmlyc3QgY2FsY3VsYXRlIE1vcmFuJ3MgaSBmb3IgYWx0ZXJzIGF0IGRpc3RhbmNlIDEuDQp3ZWlnaHRzMSA8LSBnZW9kaXN0YW5jZXMgPT0gMQ0KDQojIGFuZCB1c2UgdGhlIG5lZ2F0aXZlIGV4cG9uZW50aWFsIGRpc3RhbmNlLWRlY2F5IGZ1bmN0aW9uDQp3ZWlnaHRzMiA8LSBleHAoLWdlb2Rpc3RhbmNlcykNCg0KIyBjYWxjdWxhdGUgTW9yYW4ncyBJDQojIGZvciBkaXN0YW5jZS0xIGFuZCB3aXRoIGRpc3RhbmNlIGRlY2F5LCBpbiB0aGUga3Vkb3MgbmV0d29yaywgZm9yIGZyZXF1ZW5jeSBhbmQgdm9sdW1lICByZXNwZWN0aXZlbHkNCiMgd2UgZG8gbm90IHJvdyBzdGFuZGFyZGl6ZSENCk1mcmVxIDwtIGZNb3Jhbi5JKGZyZXExLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gd2VpZ2h0czEsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCk1mcmVxX2Rpc3RkIDwtIGZNb3Jhbi5JKGZyZXExLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCg0KTXZvbCA8LSBmTW9yYW4uSSh2b2wxLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gd2VpZ2h0czEsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCk12b2xfZGlzdGQgPC0gZk1vcmFuLkkodm9sMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IHdlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KIyAxLiBmcmVxdWVuY3kNCmZfbWF0IDwtIG1hdHJpeChOQSwgbnJvdz0yLCBuY29sPTQpDQoNCmZfbWF0WzEsMV0gPC0gTWZyZXEkb2JzZXJ2ZWQNCmZfbWF0WzEsMl0gPC0gTWZyZXEkZXhwZWN0ZWQNCmZfbWF0WzEsM10gPC0gTWZyZXEkc2QNCmZfbWF0WzEsNF0gPC0gTWZyZXEkcC52YWx1ZQ0KZl9tYXRbMiwxXSA8LSBNZnJlcV9kaXN0ZCRvYnNlcnZlZA0KZl9tYXRbMiwyXSA8LSBNZnJlcV9kaXN0ZCRleHBlY3RlZA0KZl9tYXRbMiwzXSA8LSBNZnJlcV9kaXN0ZCRzZA0KZl9tYXRbMiw0XSA8LSBNZnJlcV9kaXN0ZCRwLnZhbHVlDQoNCiMgMi4gdm9sdW1lDQp2X21hdCA8LSBtYXRyaXgoTkEsIG5yb3c9MiwgbmNvbD00KQ0Kdl9tYXRbMSwxXSA8LSBNdm9sJG9ic2VydmVkDQp2X21hdFsxLDJdIDwtIE12b2wkZXhwZWN0ZWQNCnZfbWF0WzEsM10gPC0gTXZvbCRzZA0Kdl9tYXRbMSw0XSA8LSBNdm9sJHAudmFsdWUNCnZfbWF0WzIsMV0gPC0gTXZvbF9kaXN0ZCRvYnNlcnZlZA0Kdl9tYXRbMiwyXSA8LSBNdm9sX2Rpc3RkJGV4cGVjdGVkDQp2X21hdFsyLDNdIDwtIE12b2xfZGlzdGQkc2QNCnZfbWF0WzIsNF0gPC0gTXZvbF9kaXN0ZCRwLnZhbHVlDQoNCmNvbG5hbWVzKGZfbWF0KSA8LSBjb2xuYW1lcyh2X21hdCkgPC0gYygib2JzZXJ2ZWQiLCAiZXhwZWN0ZWQiLCAic2QiLCAicC12YWx1ZSIpDQpyb3duYW1lcyhmX21hdCkgPC0gcm93bmFtZXModl9tYXQpIDwtIGMoImRpcmVjdCBrdWRvcyB0aWVzIiwgImRpcmVjdCBhbmQgaW5kaXJlY3Qga3Vkb3MgdGllcyAoZGlzdGFuY2UtZGVjYXkpIikNCg0Ka25pdHI6OmthYmxlKGZfbWF0LCBkaWdpdHM9MiwgImh0bWwiLCBjYXB0aW9uPSJNb3JhbidzIEkgc3RhdGlzdGljIGZvciBzcGF0aWFsIGF1dG9jb3JyZWxhdGlvbiBiYXNlZCBvbiBnZW9kaXN0YW5jZXMgYW5kIHdlZWtseSBydW5uaW5nIGZyZXF1ZW5jeSIpICU+JSANCiAga2FibGVFeHRyYTo6a2FibGVfc3R5bGluZyhib290c3RyYXBfb3B0aW9ucyA9IGMoInN0cmlwZWQiLCAiaG92ZXIiKSkNCg0Ka25pdHI6OmthYmxlKHZfbWF0LCBkaWdpdHM9MiwgImh0bWwiLCBjYXB0aW9uPSJNb3JhbidzIEkgc3RhdGlzdGljIGZvciBzcGF0aWFsIGF1dG9jb3JyZWxhdGlvbiBiYXNlZCBvbiBnZW9kaXN0YW5jZXMgYW5kIG1vbnRobHkgcnVubmluZyB2b2x1bWUiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQpgYGANCg0KIyMjIENsdWIgMw0KYGBge3J9DQpkZiA8LSBjbHViZGF0YVtbM11dICMgZ3JhYiBjbHViIA0KDQojIGdldCBiZWhhdmlvcmFsIGRhdGENCiMgYXQgdGltZSB0PTENCnQ9MQ0KZnJlcTEgPC0gZGYkZnJlcV9ydW5bLCx0XSAjIHJ1bm5pbmcgZnJlcXVlbmNpZXMgd2F2ZSAxDQp2b2wxIDwtIGRmJHRpbWVfcnVuWywsdF0gIyBydW5uaW5nIHZvbHVtZSB3YXZlIDENCg0KIyBleGNsdWRlIE5BcyANCm5hIDwtIHdoaWNoKGlzLm5hKGZyZXExKSkNCmZyZXExIDwtIGZyZXExWy1uYV0NCnZvbDEgPC0gdm9sMVstbmFdDQoNCiMgZ2V0IGt1ZG9zIG5ldA0Ka25ldDEgPC0gZGYka3Vkb1ssLHRdDQojIGV4Y2x1ZGUgTkFzDQprbmV0MSA8LSBrbmV0MVstbmEsLW5hXQ0KDQojIGFzIG5ldHdvcmsgb2JqZWN0DQprbmV0MSA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGtuZXQxKQ0KDQojIHdlIGluY2x1ZGUgZ2VvZGlzdGFuY2VzOiBzaG9ydGVzdCBwYXRoIGxlbmd0aHMgZnJvbSBpIHRvIGoNCmdlb2Rpc3RhbmNlcyA8LSBzbmE6Omdlb2Rpc3Qoa25ldDEsIGNvdW50LnBhdGhzPVQpDQpnZW9kaXN0YW5jZXMgPC0gZ2VvZGlzdGFuY2VzJGdkaXN0IA0KDQojIHNldCB0aGUgZGlzdGFuY2UgJ3RvIHlvdXJzZWxmJyB0byAnSW5mJw0KZGlhZyhnZW9kaXN0YW5jZXMpIDwtIEluZg0KDQojIGZpcnN0IGNhbGN1bGF0ZSBNb3JhbidzIGkgZm9yIGFsdGVycyBhdCBkaXN0YW5jZSAxLg0Kd2VpZ2h0czEgPC0gZ2VvZGlzdGFuY2VzID09IDENCg0KIyBhbmQgdXNlIHRoZSBuZWdhdGl2ZSBleHBvbmVudGlhbCBkaXN0YW5jZS1kZWNheSBmdW5jdGlvbg0Kd2VpZ2h0czIgPC0gZXhwKC1nZW9kaXN0YW5jZXMpDQoNCiMgY2FsY3VsYXRlIE1vcmFuJ3MgSQ0KIyBmb3IgZGlzdGFuY2UtMSBhbmQgd2l0aCBkaXN0YW5jZSBkZWNheSwgaW4gdGhlIGt1ZG9zIG5ldHdvcmssIGZvciBmcmVxdWVuY3kgYW5kIHZvbHVtZSAgcmVzcGVjdGl2ZWx5DQojIHdlIGRvIG5vdCByb3cgc3RhbmRhcmRpemUhDQpNZnJlcSA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IHdlaWdodHMxLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQpNZnJlcV9kaXN0ZCA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IHdlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQoNCk12b2wgPC0gZk1vcmFuLkkodm9sMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IHdlaWdodHMxLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQpNdm9sX2Rpc3RkIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSB3ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KDQojIG1ha2Ugb2JqZWN0IHRvIHN0b3JlIHJlc3VsdHMNCiMgMS4gZnJlcXVlbmN5DQpmX21hdCA8LSBtYXRyaXgoTkEsIG5yb3c9MiwgbmNvbD00KQ0KDQpmX21hdFsxLDFdIDwtIE1mcmVxJG9ic2VydmVkDQpmX21hdFsxLDJdIDwtIE1mcmVxJGV4cGVjdGVkDQpmX21hdFsxLDNdIDwtIE1mcmVxJHNkDQpmX21hdFsxLDRdIDwtIE1mcmVxJHAudmFsdWUNCmZfbWF0WzIsMV0gPC0gTWZyZXFfZGlzdGQkb2JzZXJ2ZWQNCmZfbWF0WzIsMl0gPC0gTWZyZXFfZGlzdGQkZXhwZWN0ZWQNCmZfbWF0WzIsM10gPC0gTWZyZXFfZGlzdGQkc2QNCmZfbWF0WzIsNF0gPC0gTWZyZXFfZGlzdGQkcC52YWx1ZQ0KDQojIDIuIHZvbHVtZQ0Kdl9tYXQgPC0gbWF0cml4KE5BLCBucm93PTIsIG5jb2w9NCkNCnZfbWF0WzEsMV0gPC0gTXZvbCRvYnNlcnZlZA0Kdl9tYXRbMSwyXSA8LSBNdm9sJGV4cGVjdGVkDQp2X21hdFsxLDNdIDwtIE12b2wkc2QNCnZfbWF0WzEsNF0gPC0gTXZvbCRwLnZhbHVlDQp2X21hdFsyLDFdIDwtIE12b2xfZGlzdGQkb2JzZXJ2ZWQNCnZfbWF0WzIsMl0gPC0gTXZvbF9kaXN0ZCRleHBlY3RlZA0Kdl9tYXRbMiwzXSA8LSBNdm9sX2Rpc3RkJHNkDQp2X21hdFsyLDRdIDwtIE12b2xfZGlzdGQkcC52YWx1ZQ0KDQpjb2xuYW1lcyhmX21hdCkgPC0gY29sbmFtZXModl9tYXQpIDwtIGMoIm9ic2VydmVkIiwgImV4cGVjdGVkIiwgInNkIiwgInAtdmFsdWUiKQ0Kcm93bmFtZXMoZl9tYXQpIDwtIHJvd25hbWVzKHZfbWF0KSA8LSBjKCJkaXJlY3Qga3Vkb3MgdGllcyIsICJkaXJlY3QgYW5kIGluZGlyZWN0IGt1ZG9zIHRpZXMgKGRpc3RhbmNlLWRlY2F5KSIpDQoNCmtuaXRyOjprYWJsZShmX21hdCwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iTW9yYW4ncyBJIHN0YXRpc3RpYyBmb3Igc3BhdGlhbCBhdXRvY29ycmVsYXRpb24gYmFzZWQgb24gZ2VvZGlzdGFuY2VzIGFuZCB3ZWVrbHkgcnVubmluZyBmcmVxdWVuY3kiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQoNCmtuaXRyOjprYWJsZSh2X21hdCwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iTW9yYW4ncyBJIHN0YXRpc3RpYyBmb3Igc3BhdGlhbCBhdXRvY29ycmVsYXRpb24gYmFzZWQgb24gZ2VvZGlzdGFuY2VzIGFuZCBtb250aGx5IHJ1bm5pbmcgdm9sdW1lIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCg0KIyMjIENsdWIgNA0KYGBge3J9DQpkZiA8LSBjbHViZGF0YVtbNF1dICMgZ3JhYiBjbHViIA0KDQojIGdldCBiZWhhdmlvcmFsIGRhdGENCiMgYXQgdGltZSB0PTENCnQ9MQ0KZnJlcTEgPC0gZGYkZnJlcV9ydW5bLCx0XSAjIHJ1bm5pbmcgZnJlcXVlbmNpZXMgd2F2ZSAxDQp2b2wxIDwtIGRmJHRpbWVfcnVuWywsdF0gIyBydW5uaW5nIHZvbHVtZSB3YXZlIDENCg0KIyBleGNsdWRlIE5BcyANCm5hIDwtIHdoaWNoKGlzLm5hKGZyZXExKSkNCmZyZXExIDwtIGZyZXExWy1uYV0NCnZvbDEgPC0gdm9sMVstbmFdDQoNCiMgZ2V0IGt1ZG9zIG5ldA0Ka25ldDEgPC0gZGYka3Vkb1ssLHRdDQojIGV4Y2x1ZGUgTkFzDQprbmV0MSA8LSBrbmV0MVstbmEsLW5hXQ0KDQojIGFzIG5ldHdvcmsgb2JqZWN0DQprbmV0MSA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGtuZXQxKQ0KDQojIHdlIGluY2x1ZGUgZ2VvZGlzdGFuY2VzOiBzaG9ydGVzdCBwYXRoIGxlbmd0aHMgZnJvbSBpIHRvIGoNCmdlb2Rpc3RhbmNlcyA8LSBzbmE6Omdlb2Rpc3Qoa25ldDEsIGNvdW50LnBhdGhzPVQpDQpnZW9kaXN0YW5jZXMgPC0gZ2VvZGlzdGFuY2VzJGdkaXN0IA0KDQojIHNldCB0aGUgZGlzdGFuY2UgJ3RvIHlvdXJzZWxmJyB0byAnSW5mJw0KZGlhZyhnZW9kaXN0YW5jZXMpIDwtIEluZg0KDQojIGZpcnN0IGNhbGN1bGF0ZSBNb3JhbidzIGkgZm9yIGFsdGVycyBhdCBkaXN0YW5jZSAxLg0Kd2VpZ2h0czEgPC0gZ2VvZGlzdGFuY2VzID09IDENCg0KIyBhbmQgdXNlIHRoZSBuZWdhdGl2ZSBleHBvbmVudGlhbCBkaXN0YW5jZS1kZWNheSBmdW5jdGlvbg0Kd2VpZ2h0czIgPC0gZXhwKC1nZW9kaXN0YW5jZXMpDQoNCiMgY2FsY3VsYXRlIE1vcmFuJ3MgSQ0KIyBmb3IgZGlzdGFuY2UtMSBhbmQgd2l0aCBkaXN0YW5jZSBkZWNheSwgaW4gdGhlIGt1ZG9zIG5ldHdvcmssIGZvciBmcmVxdWVuY3kgYW5kIHZvbHVtZSAgcmVzcGVjdGl2ZWx5DQojIHdlIGRvIG5vdCByb3cgc3RhbmRhcmRpemUhDQpNZnJlcSA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IHdlaWdodHMxLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQpNZnJlcV9kaXN0ZCA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IHdlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQoNCk12b2wgPC0gZk1vcmFuLkkodm9sMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IHdlaWdodHMxLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQpNdm9sX2Rpc3RkIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSB3ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KDQojIG1ha2Ugb2JqZWN0IHRvIHN0b3JlIHJlc3VsdHMNCiMgMS4gZnJlcXVlbmN5DQpmX21hdCA8LSBtYXRyaXgoTkEsIG5yb3c9MiwgbmNvbD00KQ0KDQpmX21hdFsxLDFdIDwtIE1mcmVxJG9ic2VydmVkDQpmX21hdFsxLDJdIDwtIE1mcmVxJGV4cGVjdGVkDQpmX21hdFsxLDNdIDwtIE1mcmVxJHNkDQpmX21hdFsxLDRdIDwtIE1mcmVxJHAudmFsdWUNCmZfbWF0WzIsMV0gPC0gTWZyZXFfZGlzdGQkb2JzZXJ2ZWQNCmZfbWF0WzIsMl0gPC0gTWZyZXFfZGlzdGQkZXhwZWN0ZWQNCmZfbWF0WzIsM10gPC0gTWZyZXFfZGlzdGQkc2QNCmZfbWF0WzIsNF0gPC0gTWZyZXFfZGlzdGQkcC52YWx1ZQ0KDQojIDIuIHZvbHVtZQ0Kdl9tYXQgPC0gbWF0cml4KE5BLCBucm93PTIsIG5jb2w9NCkNCnZfbWF0WzEsMV0gPC0gTXZvbCRvYnNlcnZlZA0Kdl9tYXRbMSwyXSA8LSBNdm9sJGV4cGVjdGVkDQp2X21hdFsxLDNdIDwtIE12b2wkc2QNCnZfbWF0WzEsNF0gPC0gTXZvbCRwLnZhbHVlDQp2X21hdFsyLDFdIDwtIE12b2xfZGlzdGQkb2JzZXJ2ZWQNCnZfbWF0WzIsMl0gPC0gTXZvbF9kaXN0ZCRleHBlY3RlZA0Kdl9tYXRbMiwzXSA8LSBNdm9sX2Rpc3RkJHNkDQp2X21hdFsyLDRdIDwtIE12b2xfZGlzdGQkcC52YWx1ZQ0KDQpjb2xuYW1lcyhmX21hdCkgPC0gY29sbmFtZXModl9tYXQpIDwtIGMoIm9ic2VydmVkIiwgImV4cGVjdGVkIiwgInNkIiwgInAtdmFsdWUiKQ0Kcm93bmFtZXMoZl9tYXQpIDwtIHJvd25hbWVzKHZfbWF0KSA8LSBjKCJkaXJlY3Qga3Vkb3MgdGllcyIsICJkaXJlY3QgYW5kIGluZGlyZWN0IGt1ZG9zIHRpZXMgKGRpc3RhbmNlLWRlY2F5KSIpDQoNCmtuaXRyOjprYWJsZShmX21hdCwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iTW9yYW4ncyBJIHN0YXRpc3RpYyBmb3Igc3BhdGlhbCBhdXRvY29ycmVsYXRpb24gYmFzZWQgb24gZ2VvZGlzdGFuY2VzIGFuZCB3ZWVrbHkgcnVubmluZyBmcmVxdWVuY3kiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQoNCmtuaXRyOjprYWJsZSh2X21hdCwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iTW9yYW4ncyBJIHN0YXRpc3RpYyBmb3Igc3BhdGlhbCBhdXRvY29ycmVsYXRpb24gYmFzZWQgb24gZ2VvZGlzdGFuY2VzIGFuZCBtb250aGx5IHJ1bm5pbmcgdm9sdW1lIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCg0KIyMjIENsdWIgNQ0KYGBge3J9DQpkZiA8LSBjbHViZGF0YVtbNV1dICMgZ3JhYiBjbHViIA0KDQojIGdldCBiZWhhdmlvcmFsIGRhdGENCiMgYXQgdGltZSB0PTENCnQ9MQ0KZnJlcTEgPC0gZGYkZnJlcV9ydW5bLCx0XSAjIHJ1bm5pbmcgZnJlcXVlbmNpZXMgd2F2ZSAxDQp2b2wxIDwtIGRmJHRpbWVfcnVuWywsdF0gIyBydW5uaW5nIHZvbHVtZSB3YXZlIDENCg0KIyBleGNsdWRlIE5BcyANCm5hIDwtIHdoaWNoKGlzLm5hKGZyZXExKSkNCmZyZXExIDwtIGZyZXExWy1uYV0NCnZvbDEgPC0gdm9sMVstbmFdDQoNCiMgZ2V0IGt1ZG9zIG5ldA0Ka25ldDEgPC0gZGYka3Vkb1ssLHRdDQojIGV4Y2x1ZGUgTkFzDQprbmV0MSA8LSBrbmV0MVstbmEsLW5hXQ0KDQojIGFzIG5ldHdvcmsgb2JqZWN0DQprbmV0MSA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGtuZXQxKQ0KDQojIHdlIGluY2x1ZGUgZ2VvZGlzdGFuY2VzOiBzaG9ydGVzdCBwYXRoIGxlbmd0aHMgZnJvbSBpIHRvIGoNCmdlb2Rpc3RhbmNlcyA8LSBzbmE6Omdlb2Rpc3Qoa25ldDEsIGNvdW50LnBhdGhzPVQpDQpnZW9kaXN0YW5jZXMgPC0gZ2VvZGlzdGFuY2VzJGdkaXN0IA0KDQojIHNldCB0aGUgZGlzdGFuY2UgJ3RvIHlvdXJzZWxmJyB0byAnSW5mJw0KZGlhZyhnZW9kaXN0YW5jZXMpIDwtIEluZg0KDQojIGZpcnN0IGNhbGN1bGF0ZSBNb3JhbidzIGkgZm9yIGFsdGVycyBhdCBkaXN0YW5jZSAxLg0Kd2VpZ2h0czEgPC0gZ2VvZGlzdGFuY2VzID09IDENCg0KIyBhbmQgdXNlIHRoZSBuZWdhdGl2ZSBleHBvbmVudGlhbCBkaXN0YW5jZS1kZWNheSBmdW5jdGlvbg0Kd2VpZ2h0czIgPC0gZXhwKC1nZW9kaXN0YW5jZXMpDQoNCiMgY2FsY3VsYXRlIE1vcmFuJ3MgSQ0KIyBmb3IgZGlzdGFuY2UtMSBhbmQgd2l0aCBkaXN0YW5jZSBkZWNheSwgaW4gdGhlIGt1ZG9zIG5ldHdvcmssIGZvciBmcmVxdWVuY3kgYW5kIHZvbHVtZSAgcmVzcGVjdGl2ZWx5DQojIHdlIGRvIG5vdCByb3cgc3RhbmRhcmRpemUhDQpNZnJlcSA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IHdlaWdodHMxLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQpNZnJlcV9kaXN0ZCA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IHdlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQoNCk12b2wgPC0gZk1vcmFuLkkodm9sMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IHdlaWdodHMxLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQpNdm9sX2Rpc3RkIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSB3ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KDQojIG1ha2Ugb2JqZWN0IHRvIHN0b3JlIHJlc3VsdHMNCiMgMS4gZnJlcXVlbmN5DQpmX21hdCA8LSBtYXRyaXgoTkEsIG5yb3c9MiwgbmNvbD00KQ0KDQpmX21hdFsxLDFdIDwtIE1mcmVxJG9ic2VydmVkDQpmX21hdFsxLDJdIDwtIE1mcmVxJGV4cGVjdGVkDQpmX21hdFsxLDNdIDwtIE1mcmVxJHNkDQpmX21hdFsxLDRdIDwtIE1mcmVxJHAudmFsdWUNCmZfbWF0WzIsMV0gPC0gTWZyZXFfZGlzdGQkb2JzZXJ2ZWQNCmZfbWF0WzIsMl0gPC0gTWZyZXFfZGlzdGQkZXhwZWN0ZWQNCmZfbWF0WzIsM10gPC0gTWZyZXFfZGlzdGQkc2QNCmZfbWF0WzIsNF0gPC0gTWZyZXFfZGlzdGQkcC52YWx1ZQ0KDQojIDIuIHZvbHVtZQ0Kdl9tYXQgPC0gbWF0cml4KE5BLCBucm93PTIsIG5jb2w9NCkNCnZfbWF0WzEsMV0gPC0gTXZvbCRvYnNlcnZlZA0Kdl9tYXRbMSwyXSA8LSBNdm9sJGV4cGVjdGVkDQp2X21hdFsxLDNdIDwtIE12b2wkc2QNCnZfbWF0WzEsNF0gPC0gTXZvbCRwLnZhbHVlDQp2X21hdFsyLDFdIDwtIE12b2xfZGlzdGQkb2JzZXJ2ZWQNCnZfbWF0WzIsMl0gPC0gTXZvbF9kaXN0ZCRleHBlY3RlZA0Kdl9tYXRbMiwzXSA8LSBNdm9sX2Rpc3RkJHNkDQp2X21hdFsyLDRdIDwtIE12b2xfZGlzdGQkcC52YWx1ZQ0KDQpjb2xuYW1lcyhmX21hdCkgPC0gY29sbmFtZXModl9tYXQpIDwtIGMoIm9ic2VydmVkIiwgImV4cGVjdGVkIiwgInNkIiwgInAtdmFsdWUiKQ0Kcm93bmFtZXMoZl9tYXQpIDwtIHJvd25hbWVzKHZfbWF0KSA8LSBjKCJkaXJlY3Qga3Vkb3MgdGllcyIsICJkaXJlY3QgYW5kIGluZGlyZWN0IGt1ZG9zIHRpZXMgKGRpc3RhbmNlLWRlY2F5KSIpDQoNCmtuaXRyOjprYWJsZShmX21hdCwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iTW9yYW4ncyBJIHN0YXRpc3RpYyBmb3Igc3BhdGlhbCBhdXRvY29ycmVsYXRpb24gYmFzZWQgb24gZ2VvZGlzdGFuY2VzIGFuZCB3ZWVrbHkgcnVubmluZyBmcmVxdWVuY3kiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQoNCmtuaXRyOjprYWJsZSh2X21hdCwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iTW9yYW4ncyBJIHN0YXRpc3RpYyBmb3Igc3BhdGlhbCBhdXRvY29ycmVsYXRpb24gYmFzZWQgb24gZ2VvZGlzdGFuY2VzIGFuZCBtb250aGx5IHJ1bm5pbmcgdm9sdW1lIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCg0KIyMgey19DQoNCkhlcmUsIHRoZSBNb3JhbidzIEkgc3RhdGlzdGljIHRlc3RzIHdoZXRoZXIgY2x1YiBtZW1iZXJzIHRoYXQgYXJlICpjbG9zZXIgdG8gb25lIGFub3RoZXIqIChpLmUuLCBoYXZpbmcgYSBzaG9ydGVyIGdlb2Rlc2ljL3BhdGggbGVuZ3RoKSwgYXJlIG1vcmUgYSBzaW1pbGFyIHdpdGggcmVzcGVjdCB0byB0aGVpciBiZWhhdmlvciwgdW5kZXIgdGhlIG51bGwgaHlwb3RoZXNpcyB0aGF0IGJlaGF2aW9yIGlzICdyYW5kb21seSBkaXN0cmlidXRlZCcgYW1vbmcgdGhlIGNsdWIgbWVtYmVycy4NCg0KV2Ugb2JzZXJ2ZSB0aGF0LCBpbmRlZWQsIGt1ZG9zLXRpZXMgdGhhdCBhcmUgY2xvc2VyIHRvIG9uZSBhbm90aGVyIGFyZSBtb3JlIGFsaWtlLCB3aXRoIHJlc3BlY3QgdG8gcnVubmluZy4gQXV0b2NvcnJlbGF0aW9uIHdhcyBzdHJvbmdlciB3aXRob3V0IHRoZSBkaXN0YW5jZS1kZWNheSBmdW5jdGlvbiwgd2hpY2ggc3VnZ2VzdHMgdGhhdCBlc3BlY2lhbGx5IGNsb3NlIGFsdGVycyAod2l0aCBwYXRoIGxlbmd0aCBvbmUpIGFyZSBzaW1pbGFyLiANCg0KPGJyPg0KDQoNCg0KLS0tLQ0KIyMgUmVmZXJlbmNlcw==</div>
<style>
.center {
  text-align: center;
  color: red;
}
</style>

<hr>
<br>
<p class="center">Copyright &copy; 2021 Rob Franken</p>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("des.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
