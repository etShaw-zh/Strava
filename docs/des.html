<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Descriptive statistics</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>
<script src="site_libs/kePrint-0.0.1/kePrint.js"></script>
<link href="site_libs/lightable-0.0.1/lightable.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 60px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h2 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h3 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h4 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h5 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h6 {
  padding-top: 65px;
  margin-top: -65px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Strava Journal</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="prep.html">Preparation</a>
</li>
<li>
  <a href="des.html">Descriptives</a>
</li>
<li>
  <a href="expl.html">Exploring RSiena</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/robfranken/Strava">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Descriptive statistics</h1>
<h4 class="date">Last compiled on april, 2021</h4>

</div>


<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('right', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
<hr />
<p>We will use the RSiena object to describe the friendship and kudo networks, constant covariates and behavioral variables. We will do this seperately for the <a href="#clubs">clubs</a> and <a href="#egos">egos</a>.</p>
<p><br></p>
<div id="preparation" class="section level1">
<h1>Preparation</h1>
<p>Clean the working environment and load in the club and ego data.</p>
<pre class="r test"><code># clean the working environment
rm(list = ls())

# load the object
load(&quot;clubdata_rsiena.RData&quot;)
load(&quot;clubdata.RData&quot;)
load(&quot;egodata1.5.RData&quot;)
load(&quot;egodata2.5.RData&quot;)</code></pre>
<p>We install and load the packages we need later on.</p>
<pre class="r test"><code># install if necessary
if (!require(&quot;RSiena&quot;, character.only = TRUE)) {
    install.packages(&quot;RSiena&quot;, dependencies = TRUE)
}
if (!require(&quot;igraph&quot;, character.only = TRUE)) {
    install.packages(&quot;igraph&quot;, dependencies = TRUE)
}
if (!require(&quot;tidyverse&quot;, character.only = TRUE)) {
    install.packages(&quot;tidyverse&quot;, dependencies = TRUE)
}
if (!require(&quot;tidyr&quot;, character.only = TRUE)) {
    install.packages(&quot;tidyr&quot;, dependencies = TRUE)
}
if (!require(&quot;moments&quot;, character.only = TRUE)) {
    install.packages(&quot;moments&quot;, dependencies = TRUE)
}
if (!require(&quot;dplyr&quot;, character.only = TRUE)) {
    install.packages(&quot;dplyr&quot;, dependencies = TRUE)
}
if (!require(&quot;ggplot2&quot;, character.only = TRUE)) {
    install.packages(&quot;ggplot2&quot;, dependencies = TRUE)
}
if (!require(&quot;forcats&quot;, character.only = TRUE)) {
    install.packages(&quot;forcats&quot;, dependencies = TRUE)
}
if (!require(&quot;knitr&quot;, character.only = TRUE)) {
    install.packages(&quot;knitr&quot;, dependencies = TRUE)
}
if (!require(&quot;kableExtra&quot;, character.only = TRUE)) {
    install.packages(&quot;kableExtra&quot;, dependencies = TRUE)
}
if (!require(&quot;network&quot;, character.only = TRUE)) {
    install.packages(&quot;network&quot;, dependencies = TRUE)
}
if (!require(&quot;sna&quot;, character.only = TRUE)) {
    install.packages(&quot;sna&quot;, dependencies = TRUE)
}

# load packages.
library(RSiena)  #RSiena models, some descriptives on network level
library(igraph)  #Descriptives: dyad/triad census, degree
library(tidyverse)
library(tidyr)  #for tidy data
library(moments)  #for calculating statistics (e.g., kurtosis, standard error)
library(dplyr)  #for data manipulation
library(ggplot2)  #for data visualisation
library(forcats)  #for handling categorical variables
library(knitr)  #for generating tables
library(kableExtra)  #for manipulating tables
library(network)  #for network analysis
library(sna)  #for network analysis</code></pre>
<hr />
<p>Now define some functions we use later on to describe our data (see <a href="https://www.jochemtolsma.nl/courses/complete-networks/socio6/#descriptive-statistics">www.jochemtolsma.nl</a>).</p>
<ul>
<li>fdensity: calculate density (exclude NA and structural zeros)<br />
</li>
<li>fdensityintra: calculate density within group (exclude NA and structural zeros)<br />
</li>
<li>fdensityinter: calculate density between groups (exclude NA and structural zeros)<br />
</li>
<li>fhomomat: based on ego/alter characteristics, construct dyad characteristic whether or not ego/alter are same</li>
<li>fndyads: calculate all valid dyads (no NA or structural zeros)<br />
</li>
<li>fscolnet: calculate Coleman’s segregation index on the network-level<br />
</li>
<li>fMoran.i: calculate Moran’s I spatial autocorrelation statistic (see <a href="https://www.jochemtolsma.nl/courses/complete-networks/socio7/#morans-autocorrelation-for-outgoing-ties-rsiena-build-in-dataset">here</a>)</li>
</ul>
<pre class="r fold-hide"><code># density: observed relations divided by possible relations
fdensity &lt;- function(x) {
    # x is your nomination network make sure diagonal cells are NA
    diag(x) &lt;- NA
    # take care of RSiena structural zeros, set as missing.
    x[x == 10] &lt;- NA
    sum(x == 1, na.rm = T)/(sum(x == 1 | x == 0, na.rm = T))
}

# calculate intragroup density
fdensityintra &lt;- function(x, A) {
    # A is matrix indicating whether nodes in dyad have same node attributes
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    diag(A) &lt;- NA
    sum(x == 1 &amp; A == 1, na.rm = T)/(sum((x == 1 | x == 0) &amp; A == 1, na.rm = T))
}

# calculate intragroup density
fdensityinter &lt;- function(x, A) {
    # A is matrix indicating whether nodes in dyad have same node attributes
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    diag(A) &lt;- NA
    sum(x == 1 &amp; A != 1, na.rm = T)/(sum((x == 1 | x == 0) &amp; A != 1, na.rm = T))
}

# construct dyad characteristic whether nodes are similar/homogenous
fhomomat &lt;- function(x) {
    # x is a vector of node-covariate
    xmat &lt;- matrix(x, nrow = length(x), ncol = length(x))
    xmatt &lt;- t(xmat)
    xhomo &lt;- xmat == xmatt
    return(xhomo)
}

# a function to calculate all valid dyads.
fndyads &lt;- function(x) {
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    (sum((x == 1 | x == 0), na.rm = T))
}

# a function to calculate all valid intragroupdyads.
fndyads2 &lt;- function(x, A) {
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    diag(A) &lt;- NA
    (sum((x == 1 | x == 0) &amp; A == 1, na.rm = T))
}


fscolnet &lt;- function(network, ccovar) {
    # Calculate coleman on network level:
    # https://reader.elsevier.com/reader/sd/pii/S0378873314000239?token=A42F99FF6E2B750436DD2CB0DB7B1F41BDEC16052A45683C02644DAF88215A3379636B2AA197B65941D6373E9E2EE413
    
    fhomomat &lt;- function(x) {
        xmat &lt;- matrix(x, nrow = length(x), ncol = length(x))
        xmatt &lt;- t(xmat)
        xhomo &lt;- xmat == xmatt
        return(xhomo)
    }
    
    fsumintra &lt;- function(x, A) {
        # A is matrix indicating whether nodes constituting dyad have same characteristics
        diag(x) &lt;- NA
        x[x == 10] &lt;- NA
        diag(A) &lt;- NA
        sum(x == 1 &amp; A == 1, na.rm = T)
    }
    
    # expecation w*=sum_g sum_i (ni((ng-1)/(N-1)))
    network[network == 10] &lt;- NA
    ni &lt;- rowSums(network, na.rm = T)
    ng &lt;- NA
    for (i in 1:length(ccovar)) {
        ng[i] &lt;- table(ccovar)[rownames(table(ccovar)) == ccovar[i]]
    }
    N &lt;- length(ccovar)
    wexp &lt;- sum(ni * ((ng - 1)/(N - 1)), na.rm = T)
    
    # wgg1 how many intragroup ties
    w &lt;- fsumintra(network, fhomomat(ccovar))
    
    Scol_net &lt;- ifelse(w &gt;= wexp, (w - wexp)/(sum(ni, na.rm = T) - wexp), (w - wexp)/wexp)
    return(Scol_net)
}

fMoran.I &lt;- function(x, weight, scaled = FALSE, na.rm = FALSE, alternative = &quot;two.sided&quot;, rowstandardize = TRUE) {
    if (rowstandardize) {
        if (dim(weight)[1] != dim(weight)[2]) 
            stop(&quot;&#39;weight&#39; must be a square matrix&quot;)
        n &lt;- length(x)
        if (dim(weight)[1] != n) 
            stop(&quot;&#39;weight&#39; must have as many rows as observations in &#39;x&#39;&quot;)
        ei &lt;- -1/(n - 1)
        nas &lt;- is.na(x)
        if (any(nas)) {
            if (na.rm) {
                x &lt;- x[!nas]
                n &lt;- length(x)
                weight &lt;- weight[!nas, !nas]
            } else {
                warning(&quot;&#39;x&#39; has missing values: maybe you wanted to set na.rm = TRUE?&quot;)
                return(list(observed = NA, expected = ei, sd = NA, p.value = NA))
            }
        }
        ROWSUM &lt;- rowSums(weight)
        ROWSUM[ROWSUM == 0] &lt;- 1
        weight &lt;- weight/ROWSUM
        s &lt;- sum(weight)
        m &lt;- mean(x)
        y &lt;- x - m
        cv &lt;- sum(weight * y %o% y)
        v &lt;- sum(y^2)
        obs &lt;- (n/s) * (cv/v)
        if (scaled) {
            i.max &lt;- (n/s) * (sd(rowSums(weight) * y)/sqrt(v/(n - 1)))
            obs &lt;- obs/i.max
        }
        S1 &lt;- 0.5 * sum((weight + t(weight))^2)
        S2 &lt;- sum((apply(weight, 1, sum) + apply(weight, 2, sum))^2)
        s.sq &lt;- s^2
        k &lt;- (sum(y^4)/n)/(v/n)^2
        sdi &lt;- sqrt((n * ((n^2 - 3 * n + 3) * S1 - n * S2 + 3 * s.sq) - k * (n * (n - 1) * S1 - 2 * n * 
            S2 + 6 * s.sq))/((n - 1) * (n - 2) * (n - 3) * s.sq) - 1/((n - 1)^2))
        alternative &lt;- match.arg(alternative, c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;))
        pv &lt;- pnorm(obs, mean = ei, sd = sdi)
        if (alternative == &quot;two.sided&quot;) 
            pv &lt;- if (obs &lt;= ei) 
                2 * pv else 2 * (1 - pv)
        if (alternative == &quot;greater&quot;) 
            pv &lt;- 1 - pv
        list(observed = obs, expected = ei, sd = sdi, p.value = pv)
    } else {
        if (dim(weight)[1] != dim(weight)[2]) 
            stop(&quot;&#39;weight&#39; must be a square matrix&quot;)
        n &lt;- length(x)
        if (dim(weight)[1] != n) 
            stop(&quot;&#39;weight&#39; must have as many rows as observations in &#39;x&#39;&quot;)
        ei &lt;- -1/(n - 1)
        nas &lt;- is.na(x)
        if (any(nas)) {
            if (na.rm) {
                x &lt;- x[!nas]
                n &lt;- length(x)
                weight &lt;- weight[!nas, !nas]
            } else {
                warning(&quot;&#39;x&#39; has missing values: maybe you wanted to set na.rm = TRUE?&quot;)
                return(list(observed = NA, expected = ei, sd = NA, p.value = NA))
            }
        }
        # ROWSUM &lt;- rowSums(weight) ROWSUM[ROWSUM == 0] &lt;- 1 weight &lt;- weight/ROWSUM
        s &lt;- sum(weight)
        m &lt;- mean(x)
        y &lt;- x - m
        cv &lt;- sum(weight * y %o% y)
        v &lt;- sum(y^2)
        obs &lt;- (n/s) * (cv/v)
        if (scaled) {
            i.max &lt;- (n/s) * (sd(rowSums(weight) * y)/sqrt(v/(n - 1)))
            obs &lt;- obs/i.max
        }
        S1 &lt;- 0.5 * sum((weight + t(weight))^2)
        S2 &lt;- sum((apply(weight, 1, sum) + apply(weight, 2, sum))^2)
        s.sq &lt;- s^2
        k &lt;- (sum(y^4)/n)/(v/n)^2
        sdi &lt;- sqrt((n * ((n^2 - 3 * n + 3) * S1 - n * S2 + 3 * s.sq) - k * (n * (n - 1) * S1 - 2 * n * 
            S2 + 6 * s.sq))/((n - 1) * (n - 2) * (n - 3) * s.sq) - 1/((n - 1)^2))
        alternative &lt;- match.arg(alternative, c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;))
        pv &lt;- pnorm(obs, mean = ei, sd = sdi)
        if (alternative == &quot;two.sided&quot;) 
            pv &lt;- if (obs &lt;= ei) 
                2 * pv else 2 * (1 - pv)
        if (alternative == &quot;greater&quot;) 
            pv &lt;- 1 - pv
        list(observed = obs, expected = ei, sd = sdi, p.value = pv)
    }
    
    
}</code></pre>
<hr />
</div>
<div id="clubs" class="section level1">
<h1>Clubs</h1>
<p>We cover the following:</p>
<ul>
<li>club characteristics</li>
<li>network structure in Friendship and Kudo networks</li>
<li>gender composition / segregation</li>
<li>behavior: activity level (frequency and volume)</li>
<li>spatial network autocorrelation: behavioral similarity in networks</li>
</ul>
<hr />
<p><br></p>
<div id="print-report" class="section level2">
<h2>Print report</h2>
<div id="section" class="section level3 tabset tabset-fade">
<h3></h3>
<p>Make sure to check the output of the ‘print01Report()’ function for general data descripton (degrees, network size, etc.) and a general overview of the dataset. Output is printed in a .txt file in the directory specified.</p>
<div id="club-1" class="section level4">
<h4>Club 1</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[1]]  # grab club 
print01Report(df, modelname = &quot;files/club1&quot;)</code></pre>
<p><embed src="files/club1.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
<div id="club-2" class="section level4">
<h4>Club 2</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[2]]  # grab club 
print01Report(df, modelname = &quot;files/club2&quot;)</code></pre>
<p><embed src="files/club2.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
<div id="club-3" class="section level4">
<h4>Club 3</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[3]]  # grab club 
print01Report(df, modelname = &quot;files/club3&quot;)</code></pre>
<p><embed src="files/club3.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
<div id="club-4" class="section level4">
<h4>Club 4</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[4]]  # grab club 
print01Report(df, modelname = &quot;files/club4&quot;)</code></pre>
<p><embed src="files/club4.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
<div id="club-5" class="section level4">
<h4>Club 5</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[5]]  # grab club 
print01Report(df, modelname = &quot;files/club5&quot;)</code></pre>
<p><embed src="files/club5.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
</div>
<div id="section-1" class="section level3 unnumbered">
<h3></h3>
<hr />
</div>
</div>
<div id="club-characteristics" class="section level2">
<h2>Club characteristics</h2>
<p>Some club characteristics. We show the size of the network (the number of actors) for each club and the number of active members currently (18-1-2021) on Strava, by adding to <em>www.strava.com/clubs/…</em> the original club id.</p>
<pre class="r test"><code>netsize &lt;- c(length(clubdata_rsiena[[1]]$nodeSets$Actors), length(clubdata_rsiena[[2]]$nodeSets$Actors), 
    length(clubdata_rsiena[[3]]$nodeSets$Actors), length(clubdata_rsiena[[4]]$nodeSets$Actors), length(clubdata_rsiena[[5]]$nodeSets$Actors))  # attrieve from the clubdata the number of actors in each network

clubsize &lt;- c(66, 127, 373, 15, 169)  # find the number of members currently on Strava

df &lt;- data.frame(netsize = netsize, clubsize = clubsize)

print(df)</code></pre>
<pre class="test2"><code>#&gt;   netsize clubsize
#&gt; 1      30       66
#&gt; 2      62      127
#&gt; 3     165      373
#&gt; 4      13       15
#&gt; 5      77      169</code></pre>
<p><br></p>
<hr />
</div>
<div id="friendship-network" class="section level2">
<h2>Friendship network</h2>
<p>We describe the friendship network. Note that the friendship network is a constant dyadic covariate.</p>
<div id="node-level" class="section level3 tabset tabset-fade">
<h3>1. Node-level</h3>
<p>Let’s describe the friendship-indegrees and -outdegrees of the Strava-users in each club. We take from the RSiena object the friendship network of the club in question, and turn it into an <em>igraph</em> object. Then we find the in- and outdegree of each node.</p>
<div id="club-1-1" class="section level4">
<h4>Club 1</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[1]]  # grab club 
fnet &lt;- df$dycCovars$friendship  # take friendship network

# make a &#39;graph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of outdegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of indegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-9-2.png" width="672" /></p>
</div>
<div id="club-2-1" class="section level4">
<h4>Club 2</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[2]]  # grab club 
fnet &lt;- df$dycCovars$friendship  # take friendship network

# make a &#39;graph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of outdegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of indegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-10-2.png" width="672" /></p>
</div>
<div id="club-3-1" class="section level4">
<h4>Club 3</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[3]]  # grab club 
fnet &lt;- df$dycCovars$friendship  # take friendship network

# make a &#39;graph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of outdegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of indegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-11-2.png" width="672" /></p>
</div>
<div id="club-4-1" class="section level4">
<h4>Club 4</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[4]]  # grab club 
fnet &lt;- df$dycCovars$friendship  # take friendship network

# make a &#39;graph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of outdegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of indegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-12-2.png" width="672" /></p>
</div>
<div id="club-5-1" class="section level4">
<h4>Club 5</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[5]]  # grab club 
fnet &lt;- df$dycCovars$friendship  # take friendship network

# make a &#39;graph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of outdegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of indegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-13-2.png" width="672" /></p>
</div>
</div>
<div id="section-2" class="section level3 unnumbered">
<h3></h3>
<p>In general, we see that the in- and outdegree distribution is right-skewed, suggesting that most Strava-users befriend and are befriended by relatively few club-members, while fewer users befriend and are befriended by many club-members.</p>
<p><br></p>
</div>
<div id="dyad-level" class="section level3 tabset tabset-fade">
<h3>2. Dyad-level</h3>
<p>Let’s investigate to what extent friendship-relationships (dyads) are reciprocated or mutual. There are three types of dyad: mutual, assymetric, and non-existent. We will classify dyads with the dyad-census function, and we will investigate if we observe more mutual dyads than we would expect based on chance.</p>
<div id="club-1-2" class="section level4">
<h4>Club 1</h4>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena[[1]]$dycCovars$friendship, mode = &quot;directed&quot;, 
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 66
#&gt; 
#&gt; $asym
#&gt; [1] 8
#&gt; 
#&gt; $null
#&gt; [1] 361
#&gt; 
#&gt; $total
#&gt; [1] 435</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of mutual dyads in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
</div>
<div id="club-2-2" class="section level4">
<h4>Club 2</h4>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena[[2]]$dycCovars$friendship, mode = &quot;directed&quot;, 
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dayds to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 436
#&gt; 
#&gt; $asym
#&gt; [1] 112
#&gt; 
#&gt; $null
#&gt; [1] 1343
#&gt; 
#&gt; $total
#&gt; [1] 1891</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of mutual dyads in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
</div>
<div id="club-3-2" class="section level4">
<h4>Club 3</h4>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena[[3]]$dycCovars$friendship, mode = &quot;directed&quot;, 
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dayds to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 291
#&gt; 
#&gt; $asym
#&gt; [1] 129
#&gt; 
#&gt; $null
#&gt; [1] 13110
#&gt; 
#&gt; $total
#&gt; [1] 13530</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of mutual dyads in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
</div>
<div id="club-4-2" class="section level4">
<h4>Club 4</h4>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena[[4]]$dycCovars$friendship, mode = &quot;directed&quot;, 
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dayds to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 25
#&gt; 
#&gt; $asym
#&gt; [1] 2
#&gt; 
#&gt; $null
#&gt; [1] 51
#&gt; 
#&gt; $total
#&gt; [1] 78</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of mutual dyads in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
</div>
<div id="club-5-2" class="section level4">
<h4>Club 5</h4>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena[[5]]$dycCovars$friendship, mode = &quot;directed&quot;, 
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dayds to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 433
#&gt; 
#&gt; $asym
#&gt; [1] 120
#&gt; 
#&gt; $null
#&gt; [1] 2373
#&gt; 
#&gt; $total
#&gt; [1] 2926</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of mutual dyads in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
</div>
</div>
<div id="section-3" class="section level3 unnumbered">
<h3></h3>
<p>As expected, mutual dyads are way more prominent than would be expected based on chance, which is indicative of reciprocity effects in Strava-friendships among the members of clubs.</p>
<p><br></p>
</div>
<div id="triad-level" class="section level3 tabset tabset-fade">
<h3>3. Triad-level</h3>
<p>There are 16 types of triads; see <span class="citation">Davis and Leinhardt (1967)</span>. They can be classified with the triad-census function. See <a href="https://igraph.org/r/doc/triad_census.html">here</a> for the order in which the multiple triad classifications are counted.</p>
<p>Let’s also calculate for each club the (global) transitivity index, which is the ratio of connected triplets (transitive triads) and potentially connected triplets (see <a href="http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf">here</a>). The direction of the edges is ignored. We will then calculate the global transitivity index for random (undirected) graphs.</p>
<div id="club-1-3" class="section level4">
<h4>Club 1</h4>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena[[1]]$dycCovars$friendship, mode = &quot;directed&quot;, 
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify triads
triadcount &lt;- igraph::triad.census(G1)

# and print the 16 configurations
print(triadcount)</code></pre>
<pre class="test2"><code>#&gt;  [1] 2472  144 1080    0    6    0   27   19    0    0  192    1    0    0   20   99</code></pre>
<pre class="r test"><code># global (or undirected) transitivity index
igraph::transitivity(G1)</code></pre>
<pre class="test2"><code>#&gt; [1] 0.5960265</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- transitivity(random_graph)
}

{
    hist(recip, main = &quot;global transitivity index in random graph&quot;, xlab = &quot;&quot;)
    abline(v = transitivity(G1), col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
</div>
<div id="club-2-3" class="section level4">
<h4>Club 2</h4>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena[[2]]$dycCovars$friendship, mode = &quot;directed&quot;, 
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify triads
triadcount &lt;- igraph::triad.census(G1)

# and print the 16 configurations
print(triadcount)</code></pre>
<pre class="test2"><code>#&gt;  [1] 15734  2517 11242   305   101    66   990   965    42     1  3433   166    70    26   651  1511</code></pre>
<pre class="r test"><code># global (or undirected) transitivity index
igraph::transitivity(G1)</code></pre>
<pre class="test2"><code>#&gt; [1] 0.5581027</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- transitivity(random_graph)
}

{
    hist(recip, main = &quot;global transitivity index in random graph&quot;, xlab = &quot;&quot;)
    abline(v = transitivity(G1), col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
</div>
<div id="club-3-3" class="section level4">
<h4>Club 3</h4>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena[[3]]$dycCovars$friendship, mode = &quot;directed&quot;, 
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify triads
triadcount &lt;- igraph::triad.census(G1)

# and print the 16 configurations
print(triadcount)</code></pre>
<pre class="test2"><code>#&gt;  [1] 671047  18490  41738    274    142     78    556    728     11      0   1555     20     26
#&gt; [14]      7    126    332</code></pre>
<pre class="r test"><code># global (or undirected) transitivity index
igraph::transitivity(G1)</code></pre>
<pre class="test2"><code>#&gt; [1] 0.3196571</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- transitivity(random_graph)
}

{
    hist(recip, main = &quot;global transitivity index in random graph&quot;, xlab = &quot;&quot;)
    abline(v = transitivity(G1), col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
</div>
<div id="club-4-3" class="section level4">
<h4>Club 4</h4>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena[[4]]$dycCovars$friendship, mode = &quot;directed&quot;, 
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify triads
triadcount &lt;- igraph::triad.census(G1)

# and print the 16 configurations
print(triadcount)</code></pre>
<pre class="test2"><code>#&gt;  [1]  69   5 152   0   0   1   5   9   0   0  25   0   0   0   1  19</code></pre>
<pre class="r test"><code># global (or undirected) transitivity index
igraph::transitivity(G1)</code></pre>
<pre class="test2"><code>#&gt; [1] 0.6</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- transitivity(random_graph)
}

{
    hist(recip, main = &quot;global transitivity index in random graph&quot;, xlab = &quot;&quot;)
    abline(v = transitivity(G1), col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
</div>
<div id="club-5-3" class="section level4">
<h4>Club 5</h4>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena[[5]]$dycCovars$friendship, mode = &quot;directed&quot;, 
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify triads
triadcount &lt;- igraph::triad.census(G1)

# and print the 16 configurations
print(triadcount)</code></pre>
<pre class="test2"><code>#&gt;  [1] 42054  4944 18114   125   339    54   870  1072    12     0  3237    76   150    20   550  1533</code></pre>
<pre class="r test"><code># global (or undirected) transitivity index
igraph::transitivity(G1)</code></pre>
<pre class="test2"><code>#&gt; [1] 0.5521226</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- transitivity(random_graph)
}

hist(recip, main = &quot;global transitivity index in random graph&quot;, xlab = &quot;&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
</div>
</div>
<div id="section-4" class="section level3 unnumbered">
<h3></h3>
<p>Also transitivity is more prominent than would be expected solely based on chance.</p>
<hr />
</div>
</div>
<div id="kudo-network" class="section level2">
<h2>Kudo network</h2>
<p>Now let’s describe the Kudo network, which we view as a dependent behavioral variable.</p>
<div id="node-level-1" class="section level3 tabset tabset-fade">
<h3>1. Node-level</h3>
<p>Starting, again, with indegrees and outdegrees: who receives and gives Kudos? We take from the RSiena object the Kudo network for each club, subset the first wave, and turn it into an <em>igraph</em> object.</p>
<div id="club-1-4" class="section level4">
<h4>Club 1</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[1]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-24-2.png" width="672" /></p>
</div>
<div id="club-2-4" class="section level4">
<h4>Club 2</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[2]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-25-2.png" width="672" /></p>
</div>
<div id="club-3-4" class="section level4">
<h4>Club 3</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[3]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-26-2.png" width="672" /></p>
</div>
<div id="club-4-4" class="section level4">
<h4>Club 4</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[4]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-27-2.png" width="672" /></p>
</div>
<div id="club-5-4" class="section level4">
<h4>Club 5</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[5]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-28-2.png" width="672" /></p>
</div>
</div>
<div id="section-5" class="section level3 unnumbered">
<h3></h3>
<p>We can observe the same Pareto-like-patern: some give/receive most of the Kudos given, while most give/receive few.</p>
<p><br></p>
</div>
<div id="dyad-level-1" class="section level3 tabset tabset-fade">
<h3>2. Dyad-level</h3>
<p>At the dyad-level: let’s see to what extent Kudos tend to be reciprocated between actors.</p>
<div id="club-1-5" class="section level4">
<h4>Club 1</h4>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena[[1]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 30
#&gt; 
#&gt; $asym
#&gt; [1] 5
#&gt; 
#&gt; $null
#&gt; [1] 400
#&gt; 
#&gt; $total
#&gt; [1] 435</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of reciprocated Kudos in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
</div>
<div id="club-2-5" class="section level4">
<h4>Club 2</h4>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena[[2]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 231
#&gt; 
#&gt; $asym
#&gt; [1] 99
#&gt; 
#&gt; $null
#&gt; [1] 1561
#&gt; 
#&gt; $total
#&gt; [1] 1891</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of reciprocated Kudos in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
</div>
<div id="club-3-5" class="section level4">
<h4>Club 3</h4>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena[[3]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 91
#&gt; 
#&gt; $asym
#&gt; [1] 104
#&gt; 
#&gt; $null
#&gt; [1] 13335
#&gt; 
#&gt; $total
#&gt; [1] 13530</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of reciprocated Kudos in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
</div>
<div id="club-4-5" class="section level4">
<h4>Club 4</h4>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena[[4]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 7
#&gt; 
#&gt; $asym
#&gt; [1] 2
#&gt; 
#&gt; $null
#&gt; [1] 69
#&gt; 
#&gt; $total
#&gt; [1] 78</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of reciprocated Kudos in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-32-1.png" width="672" /></p>
</div>
<div id="club-5-5" class="section level4">
<h4>Club 5</h4>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena[[5]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA, 
    add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 195
#&gt; 
#&gt; $asym
#&gt; [1] 119
#&gt; 
#&gt; $null
#&gt; [1] 2612
#&gt; 
#&gt; $total
#&gt; [1] 2926</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of reciprocated Kudos in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-33-1.png" width="672" /></p>
</div>
</div>
<div id="section-6" class="section level3 unnumbered">
<h3></h3>
<p>Conclusion: Kudos tend to be reciprocated, like friendships!</p>
<hr />
<p><br></p>
</div>
</div>
<div id="gender-composition" class="section level2">
<h2>Gender composition</h2>
<div id="section-7" class="section level3 tabset tabset-fade">
<h3></h3>
<p>Let’s investigate the gender composition of the club. We must retrieve gender from the object (note that we use the clubdata object, not the rsiena object). Then we make a categorical gender variable and plot it.</p>
<div id="club-1-6" class="section level4">
<h4>Club 1</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata[[1]]  # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# make dataframe
df &lt;- data.frame(gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)), n = c(length(gender[gender == 
    &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender == 
    &quot;Missing&quot;])), freq = c(round(length(gender[gender == &quot;Male&quot;])/length(gender), digits = 2), round(length(gender[gender == 
    &quot;Female&quot;])/length(gender), digits = 2), round(length(gender[gender == &quot;Other&quot;])/length(gender), digits = 2), 
    round(length(gender[gender == &quot;Missing&quot;])/length(gender), digits = 2)))

# plot
df %&gt;% mutate(gender = fct_reorder(gender, -n)) %&gt;% ggplot(aes(gender, n, fill = gender)) + geom_bar(stat = &quot;identity&quot;, 
    width = 0.8) + geom_text(aes(label = paste0(freq, &quot;%&quot;)), vjust = 1.5, colour = &quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-34-1.png" width="672" /></p>
</div>
<div id="club-2-6" class="section level4">
<h4>Club 2</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata[[2]]  # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# make dataframe
df &lt;- data.frame(gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)), n = c(length(gender[gender == 
    &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender == 
    &quot;Missing&quot;])), freq = c(round(length(gender[gender == &quot;Male&quot;])/length(gender), digits = 2), round(length(gender[gender == 
    &quot;Female&quot;])/length(gender), digits = 2), round(length(gender[gender == &quot;Other&quot;])/length(gender), digits = 2), 
    round(length(gender[gender == &quot;Missing&quot;])/length(gender), digits = 2)))

# plot
df %&gt;% mutate(gender = fct_reorder(gender, -n)) %&gt;% ggplot(aes(gender, n, fill = gender)) + geom_bar(stat = &quot;identity&quot;, 
    width = 0.8) + geom_text(aes(label = paste0(freq, &quot;%&quot;)), vjust = 1.5, colour = &quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-35-1.png" width="672" /></p>
</div>
<div id="club-3-6" class="section level4">
<h4>Club 3</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata[[3]]  # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# make dataframe
df &lt;- data.frame(gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)), n = c(length(gender[gender == 
    &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender == 
    &quot;Missing&quot;])), freq = c(round(length(gender[gender == &quot;Male&quot;])/length(gender), digits = 2), round(length(gender[gender == 
    &quot;Female&quot;])/length(gender), digits = 2), round(length(gender[gender == &quot;Other&quot;])/length(gender), digits = 2), 
    round(length(gender[gender == &quot;Missing&quot;])/length(gender), digits = 2)))

# plot
df %&gt;% mutate(gender = fct_reorder(gender, -n)) %&gt;% ggplot(aes(gender, n, fill = gender)) + geom_bar(stat = &quot;identity&quot;, 
    width = 0.8) + geom_text(aes(label = paste0(freq, &quot;%&quot;)), vjust = 1.5, colour = &quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-36-1.png" width="672" /></p>
</div>
<div id="club-4-6" class="section level4">
<h4>Club 4</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata[[4]]  # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# make dataframe
df &lt;- data.frame(gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)), n = c(length(gender[gender == 
    &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender == 
    &quot;Missing&quot;])), freq = c(round(length(gender[gender == &quot;Male&quot;])/length(gender), digits = 2), round(length(gender[gender == 
    &quot;Female&quot;])/length(gender), digits = 2), round(length(gender[gender == &quot;Other&quot;])/length(gender), digits = 2), 
    round(length(gender[gender == &quot;Missing&quot;])/length(gender), digits = 2)))

# plot
df %&gt;% mutate(gender = fct_reorder(gender, -n)) %&gt;% ggplot(aes(gender, n, fill = gender)) + geom_bar(stat = &quot;identity&quot;, 
    width = 0.8) + geom_text(aes(label = paste0(freq, &quot;%&quot;)), vjust = 1.5, colour = &quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-37-1.png" width="672" /></p>
</div>
<div id="club-5-6" class="section level4">
<h4>Club 5</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata[[5]]  # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# make dataframe
df &lt;- data.frame(gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)), n = c(length(gender[gender == 
    &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender == 
    &quot;Missing&quot;])), freq = c(round(length(gender[gender == &quot;Male&quot;])/length(gender), digits = 2), round(length(gender[gender == 
    &quot;Female&quot;])/length(gender), digits = 2), round(length(gender[gender == &quot;Other&quot;])/length(gender), digits = 2), 
    round(length(gender[gender == &quot;Missing&quot;])/length(gender), digits = 2)))

# plot
df %&gt;% mutate(gender = fct_reorder(gender, -n)) %&gt;% ggplot(aes(gender, n, fill = gender)) + geom_bar(stat = &quot;identity&quot;, 
    width = 0.8) + geom_text(aes(label = paste0(freq, &quot;%&quot;)), vjust = 1.5, colour = &quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-38-1.png" width="672" /></p>
</div>
</div>
<div id="section-8" class="section level3 unnumbered">
<h3></h3>
<p>We can see that in all clubs men are overrepresented.</p>
<hr />
<p><br></p>
</div>
</div>
<div id="gender-segregation" class="section level2">
<h2>Gender segregation</h2>
<p>Let’s now investigate segregation along gender in the friendship network.</p>
<div id="section-9" class="section level3 tabset tabset-fade">
<h3></h3>
<p>Let’s start with describing the total density and intra- (same gender) and intergroup (different gender) densities. We also calculate the Coleman Homophily index for gender, which refelcts gender segregation while taking into account the relative group size of gender categories. We describe these segregation measures for friendship and kudo-networks respectively.</p>
<div id="club-1-7" class="section level4">
<h4>Club 1</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[1]]  # grab club 
df2 &lt;- clubdata[[1]]

fnet &lt;- df$dycCovars$friendship  # take friendship network
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not
# work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)


# make object to store results
desmat &lt;- matrix(NA, nrow = 4, ncol = 2)

# use functions
desmat[1, 1] &lt;- fdensity(fnet)
desmat[2, 1] &lt;- fdensityintra(fnet, gender_m)
desmat[3, 1] &lt;- fdensityinter(fnet, gender_m)
desmat[4, 1] &lt;- fscolnet(fnet, gender)
desmat[1, 2] &lt;- fdensity(knet1)
desmat[2, 2] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 2] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 2] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;friendships&quot;, &quot;Kudos&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)



knitr::kable(desmat, digits = 2, &quot;html&quot;, caption = &quot;Gender segregation in friendship and kudo network&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
friendships
</th>
<th style="text-align:right;">
Kudos
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.16
</td>
<td style="text-align:right;">
0.07
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.19
</td>
<td style="text-align:right;">
0.12
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.14
</td>
<td style="text-align:right;">
0.05
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:right;">
0.26
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-2-7" class="section level4">
<h4>Club 2</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[2]]  # grab club 
df2 &lt;- clubdata[[2]]

fnet &lt;- df$dycCovars$friendship  # take friendship network
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not
# work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)


# make object to store results
desmat &lt;- matrix(NA, nrow = 4, ncol = 2)

# use functions
desmat[1, 1] &lt;- fdensity(fnet)
desmat[2, 1] &lt;- fdensityintra(fnet, gender_m)
desmat[3, 1] &lt;- fdensityinter(fnet, gender_m)
desmat[4, 1] &lt;- fscolnet(fnet, gender)
desmat[1, 2] &lt;- fdensity(knet1)
desmat[2, 2] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 2] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 2] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;friendships&quot;, &quot;Kudos&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)

# and make a nice table
knitr::kable(desmat, digits = 2, &quot;html&quot;, caption = &quot;Gender segregation in friendship and kudo network&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
friendships
</th>
<th style="text-align:right;">
Kudos
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.26
</td>
<td style="text-align:right;">
0.15
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.33
</td>
<td style="text-align:right;">
0.21
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.18
</td>
<td style="text-align:right;">
0.07
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
0.19
</td>
<td style="text-align:right;">
0.37
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-3-7" class="section level4">
<h4>Club 3</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[3]]  # grab club 
df2 &lt;- clubdata[[3]]

fnet &lt;- df$dycCovars$friendship  # take friendship network
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not
# work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)


# make object to store results
desmat &lt;- matrix(NA, nrow = 4, ncol = 2)

# use functions
desmat[1, 1] &lt;- fdensity(fnet)
desmat[2, 1] &lt;- fdensityintra(fnet, gender_m)
desmat[3, 1] &lt;- fdensityinter(fnet, gender_m)
desmat[4, 1] &lt;- fscolnet(fnet, gender)
desmat[1, 2] &lt;- fdensity(knet1)
desmat[2, 2] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 2] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 2] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;friendships&quot;, &quot;Kudos&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)

# and make a nice table
knitr::kable(desmat, digits = 2, &quot;html&quot;, caption = &quot;Gender segregation in friendship and kudo network&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
friendships
</th>
<th style="text-align:right;">
Kudos
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
0.01
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
0.01
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.02
</td>
<td style="text-align:right;">
0.01
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
0.09
</td>
<td style="text-align:right;">
0.03
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-4-7" class="section level4">
<h4>Club 4</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[4]]  # grab club 
df2 &lt;- clubdata[[4]]

fnet &lt;- df$dycCovars$friendship  # take friendship network
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not
# work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)


# make object to store results
desmat &lt;- matrix(NA, nrow = 4, ncol = 2)

# use functions
desmat[1, 1] &lt;- fdensity(fnet)
desmat[2, 1] &lt;- fdensityintra(fnet, gender_m)
desmat[3, 1] &lt;- fdensityinter(fnet, gender_m)
desmat[4, 1] &lt;- fscolnet(fnet, gender)
desmat[1, 2] &lt;- fdensity(knet1)
desmat[2, 2] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 2] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 2] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;friendships&quot;, &quot;Kudos&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)

# and make a nice table
knitr::kable(desmat, digits = 2, &quot;html&quot;, caption = &quot;Gender segregation in friendship and kudo network&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
friendships
</th>
<th style="text-align:right;">
Kudos
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.33
</td>
<td style="text-align:right;">
0.10
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.29
</td>
<td style="text-align:right;">
0.06
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.36
</td>
<td style="text-align:right;">
0.13
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
-0.12
</td>
<td style="text-align:right;">
-0.32
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-5-7" class="section level4">
<h4>Club 5</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[5]]  # grab club 
df2 &lt;- clubdata[[5]]

fnet &lt;- df$dycCovars$friendship  # take friendship network
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not
# work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)

# make object to store results
desmat &lt;- matrix(NA, nrow = 4, ncol = 2)

# use functions
desmat[1, 1] &lt;- fdensity(fnet)
desmat[2, 1] &lt;- fdensityintra(fnet, gender_m)
desmat[3, 1] &lt;- fdensityinter(fnet, gender_m)
desmat[4, 1] &lt;- fscolnet(fnet, gender)
desmat[1, 2] &lt;- fdensity(knet1)
desmat[2, 2] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 2] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 2] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;friendships&quot;, &quot;Kudos&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)

# and make a nice table
knitr::kable(desmat, digits = 2, &quot;html&quot;, caption = &quot;Gender segregation in friendship and kudo network&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
friendships
</th>
<th style="text-align:right;">
Kudos
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.17
</td>
<td style="text-align:right;">
0.09
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.16
</td>
<td style="text-align:right;">
0.09
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.18
</td>
<td style="text-align:right;">
0.08
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
-0.04
</td>
<td style="text-align:right;">
0.02
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="section-10" class="section level3 unnumbered">
<h3></h3>
<p>Density in friendships is not much higher within-gender than between-genders, though this ratio differs per club (and in some clubs between-gender friendships are more common). The same pattern holds for Kudo-relationships.</p>
<p>Coleman’s Homophily indices vary across clubs. In some clubs there is slight gender segregation (or same-gender preference) in friendship ties (values higher than 0, but rather close to 0), though in others members tend to befriend others outside their own gender (values lower than 0). Overall, tendencies towards segregation (or avoidance thereof) are pronounced to greater extent in the Kudo-relationships than in the friendships.</p>
<hr />
<p><br></p>
</div>
</div>
<div id="behavior" class="section level2">
<h2>Behavior</h2>
<div id="running" class="section level3 tabset tabset-fade">
<h3>1. Running</h3>
<p>We will describe the running activities of the club-members, in terms of times per week (0 - &gt;7) and minutes per month (8 equally populated categories). First, we make a histogram of all (aggregated) observations within clubs over time. Then we will plot the development of the mean over time (with error bars reflecting 95% confidence intervals), seperately for men and women.</p>
<div id="club-1-8" class="section level4">
<h4>Club 1</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata_rsiena[[1]]  # grab club 
df2 &lt;- clubdata[[1]]

# development of the mean over time

# retrieve gender
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category


# create wide dataframe
df2long &lt;- data.frame(id = 1:length(df$nodeSets$Actors), gender = gender, freq1 = df$depvars$freq_run[, 
    , 1], freq2 = df$depvars$freq_run[, , 2], freq3 = df$depvars$freq_run[, , 3], freq4 = df$depvars$freq_run[, 
    , 4], freq5 = df$depvars$freq_run[, , 5], freq6 = df$depvars$freq_run[, , 6], freq7 = df$depvars$freq_run[, 
    , 7], freq8 = df$depvars$freq_run[, , 8], freq9 = df$depvars$freq_run[, , 9], freq10 = df$depvars$freq_run[, 
    , 10], freq11 = df$depvars$freq_run[, , 11], freq12 = df$depvars$freq_run[, , 12], time1 = df$depvars$time_run[, 
    , 1], time2 = df$depvars$time_run[, , 2], time3 = df$depvars$time_run[, , 3], time4 = df$depvars$time_run[, 
    , 4], time5 = df$depvars$time_run[, , 5], time6 = df$depvars$time_run[, , 6], time7 = df$depvars$time_run[, 
    , 7], time8 = df$depvars$time_run[, , 8], time9 = df$depvars$time_run[, , 9], time10 = df$depvars$time_run[, 
    , 10], time11 = df$depvars$time_run[, , 11], time12 = df$depvars$time_run[, , 12])

# reshape to long dataframe
df_long &lt;- reshape(df2long, direction = &quot;long&quot;, varying = c(list(names(df2long)[3:14]), list(names(df2long)[15:26])), 
    v.names = c(&quot;run_freq&quot;, &quot;run_time&quot;), idvar = &quot;id&quot;, timevar = &quot;time&quot;, times = 1:12)

# Reorder data based on user id
df_long &lt;- df_long[(order(df_long$id)), ]

# create data to plot, seperately for men and women
data_all &lt;- df_long %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Full Sample&quot;)

data_men &lt;- df_long[which(df_long$gender == &quot;Male&quot;), ]
data_men &lt;- data_men %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Men&quot;)

data_women &lt;- df_long[which(df_long$gender == &quot;Female&quot;), ]
data_women &lt;- data_women %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Women&quot;)

# stack data
plot.data &lt;- rbind(data_all, data_men, data_women)
rm(data_all, data_men, data_women)

# add months
plot.data$month &lt;- rep(c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, 
    &quot;Dec&quot;), 3)

# plot
plot_mean_freq &lt;- ggplot(plot.data, aes(month, mean_freq, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_freq, ymin = mean_freq - se_freq, 
    ymax = mean_freq + se_freq, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Running frequency per week&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 5) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

plot_mean_time &lt;- ggplot(plot.data, aes(month, mean_time, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_time, ymin = mean_time - se_time, 
    ymax = mean_time + se_time, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Running volume per month&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 7) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

### Output ###

# histogram (assuming independent observations)
hist(df$depvars$freq_run, main = &quot;Histogram of Running Frequency&quot;, xlab = &quot;Times per week&quot;, ylab = &quot;count&quot;, 
    col = &quot;grey&quot;, border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-44-1.png" width="672" /></p>
<pre class="r fold-hide"><code>hist(df$depvars$time_run, main = &quot;Histogram of Running Volume&quot;, xlab = &quot;&quot;, ylab = &quot;count&quot;, col = &quot;grey&quot;, 
    border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-44-2.png" width="672" /></p>
<pre class="r fold-hide"><code># development mean over time
plot_mean_freq</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-44-3.png" width="672" /></p>
<pre class="r fold-hide"><code>plot_mean_time</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-44-4.png" width="672" /></p>
</div>
<div id="club-2-8" class="section level4">
<h4>Club 2</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata_rsiena[[2]]  # grab club 
df2 &lt;- clubdata[[2]]

# development of the mean over time

# retrieve gender
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category


# create wide dataframe
df2long &lt;- data.frame(id = 1:length(df$nodeSets$Actors), gender = gender, freq1 = df$depvars$freq_run[, 
    , 1], freq2 = df$depvars$freq_run[, , 2], freq3 = df$depvars$freq_run[, , 3], freq4 = df$depvars$freq_run[, 
    , 4], freq5 = df$depvars$freq_run[, , 5], freq6 = df$depvars$freq_run[, , 6], freq7 = df$depvars$freq_run[, 
    , 7], freq8 = df$depvars$freq_run[, , 8], freq9 = df$depvars$freq_run[, , 9], freq10 = df$depvars$freq_run[, 
    , 10], freq11 = df$depvars$freq_run[, , 11], freq12 = df$depvars$freq_run[, , 12], time1 = df$depvars$time_run[, 
    , 1], time2 = df$depvars$time_run[, , 2], time3 = df$depvars$time_run[, , 3], time4 = df$depvars$time_run[, 
    , 4], time5 = df$depvars$time_run[, , 5], time6 = df$depvars$time_run[, , 6], time7 = df$depvars$time_run[, 
    , 7], time8 = df$depvars$time_run[, , 8], time9 = df$depvars$time_run[, , 9], time10 = df$depvars$time_run[, 
    , 10], time11 = df$depvars$time_run[, , 11], time12 = df$depvars$time_run[, , 12])

# reshape to long dataframe
df_long &lt;- reshape(df2long, direction = &quot;long&quot;, varying = c(list(names(df2long)[3:14]), list(names(df2long)[15:26])), 
    v.names = c(&quot;run_freq&quot;, &quot;run_time&quot;), idvar = &quot;id&quot;, timevar = &quot;time&quot;, times = 1:12)

# Reorder data based on user id
df_long &lt;- df_long[(order(df_long$id)), ]

# create data to plot, seperately for men and women
data_all &lt;- df_long %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Full Sample&quot;)

data_men &lt;- df_long[which(df_long$gender == &quot;Male&quot;), ]
data_men &lt;- data_men %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Men&quot;)

data_women &lt;- df_long[which(df_long$gender == &quot;Female&quot;), ]
data_women &lt;- data_women %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Women&quot;)

# stack data
plot.data &lt;- rbind(data_all, data_men, data_women)
rm(data_all, data_men, data_women)

# add months
plot.data$month &lt;- rep(c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, 
    &quot;Dec&quot;), 3)

# plot
plot_mean_freq &lt;- ggplot(plot.data, aes(month, mean_freq, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_freq, ymin = mean_freq - se_freq, 
    ymax = mean_freq + se_freq, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Running frequency per week&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 5) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

plot_mean_time &lt;- ggplot(plot.data, aes(month, mean_time, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_time, ymin = mean_time - se_time, 
    ymax = mean_time + se_time, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Running volume per month&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 7) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

### Output ###

# histogram (assuming independent observations)
hist(df$depvars$freq_run, main = &quot;Histogram of Running Frequency&quot;, xlab = &quot;Times per week&quot;, ylab = &quot;count&quot;, 
    col = &quot;grey&quot;, border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-45-1.png" width="672" /></p>
<pre class="r fold-hide"><code>hist(df$depvars$time_run, main = &quot;Histogram of Running Volume&quot;, xlab = &quot;&quot;, ylab = &quot;count&quot;, col = &quot;grey&quot;, 
    border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-45-2.png" width="672" /></p>
<pre class="r fold-hide"><code># development mean over time
plot_mean_freq</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-45-3.png" width="672" /></p>
<pre class="r fold-hide"><code>plot_mean_time</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-45-4.png" width="672" /></p>
</div>
<div id="club-3-8" class="section level4">
<h4>Club 3</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata_rsiena[[3]]  # grab club 
df2 &lt;- clubdata[[3]]

# development of the mean over time

# retrieve gender
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category


# create wide dataframe
df2long &lt;- data.frame(id = 1:length(df$nodeSets$Actors), gender = gender, freq1 = df$depvars$freq_run[, 
    , 1], freq2 = df$depvars$freq_run[, , 2], freq3 = df$depvars$freq_run[, , 3], freq4 = df$depvars$freq_run[, 
    , 4], freq5 = df$depvars$freq_run[, , 5], freq6 = df$depvars$freq_run[, , 6], freq7 = df$depvars$freq_run[, 
    , 7], freq8 = df$depvars$freq_run[, , 8], freq9 = df$depvars$freq_run[, , 9], freq10 = df$depvars$freq_run[, 
    , 10], freq11 = df$depvars$freq_run[, , 11], freq12 = df$depvars$freq_run[, , 12], time1 = df$depvars$time_run[, 
    , 1], time2 = df$depvars$time_run[, , 2], time3 = df$depvars$time_run[, , 3], time4 = df$depvars$time_run[, 
    , 4], time5 = df$depvars$time_run[, , 5], time6 = df$depvars$time_run[, , 6], time7 = df$depvars$time_run[, 
    , 7], time8 = df$depvars$time_run[, , 8], time9 = df$depvars$time_run[, , 9], time10 = df$depvars$time_run[, 
    , 10], time11 = df$depvars$time_run[, , 11], time12 = df$depvars$time_run[, , 12])

# reshape to long dataframe
df_long &lt;- reshape(df2long, direction = &quot;long&quot;, varying = c(list(names(df2long)[3:14]), list(names(df2long)[15:26])), 
    v.names = c(&quot;run_freq&quot;, &quot;run_time&quot;), idvar = &quot;id&quot;, timevar = &quot;time&quot;, times = 1:12)

# Reorder data based on user id
df_long &lt;- df_long[(order(df_long$id)), ]

# create data to plot, seperately for men and women
data_all &lt;- df_long %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Full Sample&quot;)

data_men &lt;- df_long[which(df_long$gender == &quot;Male&quot;), ]
data_men &lt;- data_men %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Men&quot;)

data_women &lt;- df_long[which(df_long$gender == &quot;Female&quot;), ]
data_women &lt;- data_women %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Women&quot;)

# stack data
plot.data &lt;- rbind(data_all, data_men, data_women)
rm(data_all, data_men, data_women)

# add months
plot.data$month &lt;- rep(c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, 
    &quot;Dec&quot;), 3)

# plot
plot_mean_freq &lt;- ggplot(plot.data, aes(month, mean_freq, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_freq, ymin = mean_freq - se_freq, 
    ymax = mean_freq + se_freq, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Running frequency per week&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 5) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

plot_mean_time &lt;- ggplot(plot.data, aes(month, mean_time, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_time, ymin = mean_time - se_time, 
    ymax = mean_time + se_time, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Running volume per month&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 7) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

### Output ###

# histogram (assuming independent observations)
hist(df$depvars$freq_run, main = &quot;Histogram of Running Frequency&quot;, xlab = &quot;Times per week&quot;, ylab = &quot;count&quot;, 
    col = &quot;grey&quot;, border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-46-1.png" width="672" /></p>
<pre class="r fold-hide"><code>hist(df$depvars$time_run, main = &quot;Histogram of Running Volume&quot;, xlab = &quot;&quot;, ylab = &quot;count&quot;, col = &quot;grey&quot;, 
    border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-46-2.png" width="672" /></p>
<pre class="r fold-hide"><code># development mean over time
plot_mean_freq</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-46-3.png" width="672" /></p>
<pre class="r fold-hide"><code>plot_mean_time</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-46-4.png" width="672" /></p>
</div>
<div id="club-4-8" class="section level4">
<h4>Club 4</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata_rsiena[[4]]  # grab club 
df2 &lt;- clubdata[[4]]

# development of the mean over time

# retrieve gender
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category


# create wide dataframe
df2long &lt;- data.frame(id = 1:length(df$nodeSets$Actors), gender = gender, freq1 = df$depvars$freq_run[, 
    , 1], freq2 = df$depvars$freq_run[, , 2], freq3 = df$depvars$freq_run[, , 3], freq4 = df$depvars$freq_run[, 
    , 4], freq5 = df$depvars$freq_run[, , 5], freq6 = df$depvars$freq_run[, , 6], freq7 = df$depvars$freq_run[, 
    , 7], freq8 = df$depvars$freq_run[, , 8], freq9 = df$depvars$freq_run[, , 9], freq10 = df$depvars$freq_run[, 
    , 10], freq11 = df$depvars$freq_run[, , 11], freq12 = df$depvars$freq_run[, , 12], time1 = df$depvars$time_run[, 
    , 1], time2 = df$depvars$time_run[, , 2], time3 = df$depvars$time_run[, , 3], time4 = df$depvars$time_run[, 
    , 4], time5 = df$depvars$time_run[, , 5], time6 = df$depvars$time_run[, , 6], time7 = df$depvars$time_run[, 
    , 7], time8 = df$depvars$time_run[, , 8], time9 = df$depvars$time_run[, , 9], time10 = df$depvars$time_run[, 
    , 10], time11 = df$depvars$time_run[, , 11], time12 = df$depvars$time_run[, , 12])

# reshape to long dataframe
df_long &lt;- reshape(df2long, direction = &quot;long&quot;, varying = c(list(names(df2long)[3:14]), list(names(df2long)[15:26])), 
    v.names = c(&quot;run_freq&quot;, &quot;run_time&quot;), idvar = &quot;id&quot;, timevar = &quot;time&quot;, times = 1:12)

# Reorder data based on user id
df_long &lt;- df_long[(order(df_long$id)), ]

# create data to plot, seperately for men and women
data_all &lt;- df_long %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Full Sample&quot;)

data_men &lt;- df_long[which(df_long$gender == &quot;Male&quot;), ]
data_men &lt;- data_men %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Men&quot;)

data_women &lt;- df_long[which(df_long$gender == &quot;Female&quot;), ]
data_women &lt;- data_women %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Women&quot;)

# stack data
plot.data &lt;- rbind(data_all, data_men, data_women)
rm(data_all, data_men, data_women)

# add months
plot.data$month &lt;- rep(c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, 
    &quot;Dec&quot;), 3)

# plot
plot_mean_freq &lt;- ggplot(plot.data, aes(month, mean_freq, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_freq, ymin = mean_freq - se_freq, 
    ymax = mean_freq + se_freq, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Running frequency per week&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 5) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

plot_mean_time &lt;- ggplot(plot.data, aes(month, mean_time, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_time, ymin = mean_time - se_time, 
    ymax = mean_time + se_time, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Running volume per month&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 7) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

### Output ###

# histogram (assuming independent observations)
hist(df$depvars$freq_run, main = &quot;Histogram of Running Frequency&quot;, xlab = &quot;Times per week&quot;, ylab = &quot;count&quot;, 
    col = &quot;grey&quot;, border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-47-1.png" width="672" /></p>
<pre class="r fold-hide"><code>hist(df$depvars$time_run, main = &quot;Histogram of Running Volume&quot;, xlab = &quot;&quot;, ylab = &quot;count&quot;, col = &quot;grey&quot;, 
    border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-47-2.png" width="672" /></p>
<pre class="r fold-hide"><code># development mean over time
plot_mean_freq</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-47-3.png" width="672" /></p>
<pre class="r fold-hide"><code>plot_mean_time</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-47-4.png" width="672" /></p>
</div>
<div id="club-5-8" class="section level4">
<h4>Club 5</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata_rsiena[[5]]  # grab club 
df2 &lt;- clubdata[[5]]

# development of the mean over time

# retrieve gender
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category


# create wide dataframe
df2long &lt;- data.frame(id = 1:length(df$nodeSets$Actors), gender = gender, freq1 = df$depvars$freq_run[, 
    , 1], freq2 = df$depvars$freq_run[, , 2], freq3 = df$depvars$freq_run[, , 3], freq4 = df$depvars$freq_run[, 
    , 4], freq5 = df$depvars$freq_run[, , 5], freq6 = df$depvars$freq_run[, , 6], freq7 = df$depvars$freq_run[, 
    , 7], freq8 = df$depvars$freq_run[, , 8], freq9 = df$depvars$freq_run[, , 9], freq10 = df$depvars$freq_run[, 
    , 10], freq11 = df$depvars$freq_run[, , 11], freq12 = df$depvars$freq_run[, , 12], time1 = df$depvars$time_run[, 
    , 1], time2 = df$depvars$time_run[, , 2], time3 = df$depvars$time_run[, , 3], time4 = df$depvars$time_run[, 
    , 4], time5 = df$depvars$time_run[, , 5], time6 = df$depvars$time_run[, , 6], time7 = df$depvars$time_run[, 
    , 7], time8 = df$depvars$time_run[, , 8], time9 = df$depvars$time_run[, , 9], time10 = df$depvars$time_run[, 
    , 10], time11 = df$depvars$time_run[, , 11], time12 = df$depvars$time_run[, , 12])

# reshape to long dataframe
df_long &lt;- reshape(df2long, direction = &quot;long&quot;, varying = c(list(names(df2long)[3:14]), list(names(df2long)[15:26])), 
    v.names = c(&quot;run_freq&quot;, &quot;run_time&quot;), idvar = &quot;id&quot;, timevar = &quot;time&quot;, times = 1:12)

# Reorder data based on user id
df_long &lt;- df_long[(order(df_long$id)), ]

# create data to plot, seperately for men and women
data_all &lt;- df_long %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Full Sample&quot;)

data_men &lt;- df_long[which(df_long$gender == &quot;Male&quot;), ]
data_men &lt;- data_men %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Men&quot;)

data_women &lt;- df_long[which(df_long$gender == &quot;Female&quot;), ]
data_women &lt;- data_women %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(run_freq, na.rm = T), mean_time = mean(run_time, 
    na.rm = T), se_freq = 1.96 * (sd(run_freq, na.rm = T)/sqrt(sum(!is.na(run_freq)))), se_time = 1.96 * 
    (sd(run_time, na.rm = T)/sqrt(sum(!is.na(run_time)))), sd_freq = sd(run_freq, na.rm = T), sd_time = sd(run_time, 
    na.rm = T), var_freq = var(run_freq, na.rm = T), var_time = var(run_time, na.rm = T), kurtosis_freq = kurtosis(run_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(run_time, na.rm = T) - 3, class = &quot;Women&quot;)

# stack data
plot.data &lt;- rbind(data_all, data_men, data_women)
rm(data_all, data_men, data_women)

# add months
plot.data$month &lt;- rep(c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, 
    &quot;Dec&quot;), 3)

# plot
plot_mean_freq &lt;- ggplot(plot.data, aes(month, mean_freq, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_freq, ymin = mean_freq - se_freq, 
    ymax = mean_freq + se_freq, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Running frequency per week&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 5) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

plot_mean_time &lt;- ggplot(plot.data, aes(month, mean_time, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_time, ymin = mean_time - se_time, 
    ymax = mean_time + se_time, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Running volume per month&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 7) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

### Output ###

# histogram (assuming independent observations)
hist(df$depvars$freq_run, main = &quot;Histogram of Running Frequency&quot;, xlab = &quot;Times per week&quot;, ylab = &quot;count&quot;, 
    col = &quot;grey&quot;, border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-48-1.png" width="672" /></p>
<pre class="r fold-hide"><code>hist(df$depvars$time_run, main = &quot;Histogram of Running Volume&quot;, xlab = &quot;&quot;, ylab = &quot;count&quot;, col = &quot;grey&quot;, 
    border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-48-2.png" width="672" /></p>
<pre class="r fold-hide"><code># development mean over time
plot_mean_freq</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-48-3.png" width="672" /></p>
<pre class="r fold-hide"><code>plot_mean_time</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-48-4.png" width="672" /></p>
</div>
</div>
<div id="section-11" class="section level3 unnumbered">
<h3></h3>
<hr />
</div>
<div id="other-activities" class="section level3 tabset tabset-fade">
<h3>2. Other activities</h3>
<p>We will describe other activities as well (e.g., cycling and swimming).</p>
<div id="club-1-9" class="section level4">
<h4>Club 1</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata_rsiena[[1]]  # grab club 
df2 &lt;- clubdata[[1]]

# development of the mean over time

# retrieve gender
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# create wide dataframe
df2long &lt;- data.frame(id = 1:length(df$nodeSets$Actors), gender = gender, freq1 = df2$freq_other[, , 
    1], freq2 = df2$freq_other[, , 2], freq3 = df2$freq_other[, , 3], freq4 = df2$freq_other[, , 4], 
    freq5 = df2$freq_other[, , 5], freq6 = df2$freq_other[, , 6], freq7 = df2$freq_other[, , 7], freq8 = df2$freq_other[, 
        , 8], freq9 = df2$freq_other[, , 9], freq10 = df2$freq_other[, , 10], freq11 = df2$freq_other[, 
        , 11], freq12 = df2$freq_other[, , 12], time1 = df2$time_other[, , 1], time2 = df2$time_other[, 
        , 2], time3 = df2$time_other[, , 3], time4 = df2$time_other[, , 4], time5 = df2$time_other[, 
        , 5], time6 = df2$time_other[, , 6], time7 = df2$time_other[, , 7], time8 = df2$time_other[, 
        , 8], time9 = df2$time_other[, , 9], time10 = df2$time_other[, , 10], time11 = df2$time_other[, 
        , 11], time12 = df2$time_other[, , 12])

# reshape to long dataframe
df_long &lt;- reshape(df2long, direction = &quot;long&quot;, varying = c(list(names(df2long)[3:14]), list(names(df2long)[15:26])), 
    v.names = c(&quot;other_freq&quot;, &quot;other_time&quot;), idvar = &quot;id&quot;, timevar = &quot;time&quot;, times = 1:12)

# Reorder data based on user id
df_long &lt;- df_long[(order(df_long$id)), ]

# create data to plot, seperately for men and women
data_all &lt;- df_long %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Full Sample&quot;)

data_men &lt;- df_long[which(df_long$gender == &quot;Male&quot;), ]
data_men &lt;- data_men %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Men&quot;)

data_women &lt;- df_long[which(df_long$gender == &quot;Female&quot;), ]
data_women &lt;- data_women %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Women&quot;)

# stack data
plot.data &lt;- rbind(data_all, data_men, data_women)
rm(data_all, data_men, data_women)

# add months
plot.data$month &lt;- rep(c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, 
    &quot;Dec&quot;), 3)

# plot
plot_mean_freq &lt;- ggplot(plot.data, aes(month, mean_freq, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_freq, ymin = mean_freq - se_freq, 
    ymax = mean_freq + se_freq, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Other frequency per week&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 5) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

plot_mean_time &lt;- ggplot(plot.data, aes(month, mean_time, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_time, ymin = mean_time - se_time, 
    ymax = mean_time + se_time, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Other volume per month&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 7) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

### Output ###

# histogram (assuming independent observations)
hist(df$vCovar$freq_other, main = &quot;Histogram of Other Frequency&quot;, xlab = &quot;Times per week&quot;, ylab = &quot;count&quot;, 
    col = &quot;grey&quot;, border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-49-1.png" width="672" /></p>
<pre class="r fold-hide"><code>hist(df$vCovar$time_other, main = &quot;Histogram of Other Volume&quot;, xlab = &quot;&quot;, ylab = &quot;count&quot;, col = &quot;grey&quot;, 
    border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-49-2.png" width="672" /></p>
<pre class="r fold-hide"><code># development mean over time
plot_mean_freq</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-49-3.png" width="672" /></p>
<pre class="r fold-hide"><code>plot_mean_time</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-49-4.png" width="672" /></p>
</div>
<div id="club-2-9" class="section level4">
<h4>Club 2</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata_rsiena[[2]]  # grab club 
df2 &lt;- clubdata[[2]]

# development of the mean over time

# retrieve gender
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# create wide dataframe
df2long &lt;- data.frame(id = 1:length(df$nodeSets$Actors), gender = gender, freq1 = df2$freq_other[, , 
    1], freq2 = df2$freq_other[, , 2], freq3 = df2$freq_other[, , 3], freq4 = df2$freq_other[, , 4], 
    freq5 = df2$freq_other[, , 5], freq6 = df2$freq_other[, , 6], freq7 = df2$freq_other[, , 7], freq8 = df2$freq_other[, 
        , 8], freq9 = df2$freq_other[, , 9], freq10 = df2$freq_other[, , 10], freq11 = df2$freq_other[, 
        , 11], freq12 = df2$freq_other[, , 12], time1 = df2$time_other[, , 1], time2 = df2$time_other[, 
        , 2], time3 = df2$time_other[, , 3], time4 = df2$time_other[, , 4], time5 = df2$time_other[, 
        , 5], time6 = df2$time_other[, , 6], time7 = df2$time_other[, , 7], time8 = df2$time_other[, 
        , 8], time9 = df2$time_other[, , 9], time10 = df2$time_other[, , 10], time11 = df2$time_other[, 
        , 11], time12 = df2$time_other[, , 12])

# reshape to long dataframe
df_long &lt;- reshape(df2long, direction = &quot;long&quot;, varying = c(list(names(df2long)[3:14]), list(names(df2long)[15:26])), 
    v.names = c(&quot;other_freq&quot;, &quot;other_time&quot;), idvar = &quot;id&quot;, timevar = &quot;time&quot;, times = 1:12)

# Reorder data based on user id
df_long &lt;- df_long[(order(df_long$id)), ]

# create data to plot, seperately for men and women
data_all &lt;- df_long %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Full Sample&quot;)

data_men &lt;- df_long[which(df_long$gender == &quot;Male&quot;), ]
data_men &lt;- data_men %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Men&quot;)

data_women &lt;- df_long[which(df_long$gender == &quot;Female&quot;), ]
data_women &lt;- data_women %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Women&quot;)

# stack data
plot.data &lt;- rbind(data_all, data_men, data_women)
rm(data_all, data_men, data_women)

# add months
plot.data$month &lt;- rep(c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, 
    &quot;Dec&quot;), 3)

# plot
plot_mean_freq &lt;- ggplot(plot.data, aes(month, mean_freq, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_freq, ymin = mean_freq - se_freq, 
    ymax = mean_freq + se_freq, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Other frequency per week&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 5) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

plot_mean_time &lt;- ggplot(plot.data, aes(month, mean_time, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_time, ymin = mean_time - se_time, 
    ymax = mean_time + se_time, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Other volume per month&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 7) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

### Output ###

# histogram (assuming independent observations)
hist(df$vCovar$freq_other, main = &quot;Histogram of Other Frequency&quot;, xlab = &quot;Times per week&quot;, ylab = &quot;count&quot;, 
    col = &quot;grey&quot;, border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-50-1.png" width="672" /></p>
<pre class="r fold-hide"><code>hist(df$vCovar$time_other, main = &quot;Histogram of Other Volume&quot;, xlab = &quot;&quot;, ylab = &quot;count&quot;, col = &quot;grey&quot;, 
    border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-50-2.png" width="672" /></p>
<pre class="r fold-hide"><code># development mean over time
plot_mean_freq</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-50-3.png" width="672" /></p>
<pre class="r fold-hide"><code>plot_mean_time</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-50-4.png" width="672" /></p>
</div>
<div id="club-3-9" class="section level4">
<h4>Club 3</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata_rsiena[[3]]  # grab club 
df2 &lt;- clubdata[[3]]

# development of the mean over time

# retrieve gender
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# create wide dataframe
df2long &lt;- data.frame(id = 1:length(df$nodeSets$Actors), gender = gender, freq1 = df2$freq_other[, , 
    1], freq2 = df2$freq_other[, , 2], freq3 = df2$freq_other[, , 3], freq4 = df2$freq_other[, , 4], 
    freq5 = df2$freq_other[, , 5], freq6 = df2$freq_other[, , 6], freq7 = df2$freq_other[, , 7], freq8 = df2$freq_other[, 
        , 8], freq9 = df2$freq_other[, , 9], freq10 = df2$freq_other[, , 10], freq11 = df2$freq_other[, 
        , 11], freq12 = df2$freq_other[, , 12], time1 = df2$time_other[, , 1], time2 = df2$time_other[, 
        , 2], time3 = df2$time_other[, , 3], time4 = df2$time_other[, , 4], time5 = df2$time_other[, 
        , 5], time6 = df2$time_other[, , 6], time7 = df2$time_other[, , 7], time8 = df2$time_other[, 
        , 8], time9 = df2$time_other[, , 9], time10 = df2$time_other[, , 10], time11 = df2$time_other[, 
        , 11], time12 = df2$time_other[, , 12])

# reshape to long dataframe
df_long &lt;- reshape(df2long, direction = &quot;long&quot;, varying = c(list(names(df2long)[3:14]), list(names(df2long)[15:26])), 
    v.names = c(&quot;other_freq&quot;, &quot;other_time&quot;), idvar = &quot;id&quot;, timevar = &quot;time&quot;, times = 1:12)

# Reorder data based on user id
df_long &lt;- df_long[(order(df_long$id)), ]

# create data to plot, seperately for men and women
data_all &lt;- df_long %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Full Sample&quot;)

data_men &lt;- df_long[which(df_long$gender == &quot;Male&quot;), ]
data_men &lt;- data_men %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Men&quot;)

data_women &lt;- df_long[which(df_long$gender == &quot;Female&quot;), ]
data_women &lt;- data_women %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Women&quot;)

# stack data
plot.data &lt;- rbind(data_all, data_men, data_women)
rm(data_all, data_men, data_women)

# add months
plot.data$month &lt;- rep(c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, 
    &quot;Dec&quot;), 3)

# plot
plot_mean_freq &lt;- ggplot(plot.data, aes(month, mean_freq, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_freq, ymin = mean_freq - se_freq, 
    ymax = mean_freq + se_freq, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Other frequency per week&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 5) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

plot_mean_time &lt;- ggplot(plot.data, aes(month, mean_time, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_time, ymin = mean_time - se_time, 
    ymax = mean_time + se_time, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Other volume per month&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 7) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

### Output ###

# histogram (assuming independent observations)
hist(df$vCovar$freq_other, main = &quot;Histogram of Other Frequency&quot;, xlab = &quot;Times per week&quot;, ylab = &quot;count&quot;, 
    col = &quot;grey&quot;, border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-51-1.png" width="672" /></p>
<pre class="r fold-hide"><code>hist(df$vCovar$time_other, main = &quot;Histogram of Other Volume&quot;, xlab = &quot;&quot;, ylab = &quot;count&quot;, col = &quot;grey&quot;, 
    border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-51-2.png" width="672" /></p>
<pre class="r fold-hide"><code># development mean over time
plot_mean_freq</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-51-3.png" width="672" /></p>
<pre class="r fold-hide"><code>plot_mean_time</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-51-4.png" width="672" /></p>
</div>
<div id="club-4-9" class="section level4">
<h4>Club 4</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata_rsiena[[4]]  # grab club 
df2 &lt;- clubdata[[4]]

# development of the mean over time

# retrieve gender
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# create wide dataframe
df2long &lt;- data.frame(id = 1:length(df$nodeSets$Actors), gender = gender, freq1 = df2$freq_other[, , 
    1], freq2 = df2$freq_other[, , 2], freq3 = df2$freq_other[, , 3], freq4 = df2$freq_other[, , 4], 
    freq5 = df2$freq_other[, , 5], freq6 = df2$freq_other[, , 6], freq7 = df2$freq_other[, , 7], freq8 = df2$freq_other[, 
        , 8], freq9 = df2$freq_other[, , 9], freq10 = df2$freq_other[, , 10], freq11 = df2$freq_other[, 
        , 11], freq12 = df2$freq_other[, , 12], time1 = df2$time_other[, , 1], time2 = df2$time_other[, 
        , 2], time3 = df2$time_other[, , 3], time4 = df2$time_other[, , 4], time5 = df2$time_other[, 
        , 5], time6 = df2$time_other[, , 6], time7 = df2$time_other[, , 7], time8 = df2$time_other[, 
        , 8], time9 = df2$time_other[, , 9], time10 = df2$time_other[, , 10], time11 = df2$time_other[, 
        , 11], time12 = df2$time_other[, , 12])

# reshape to long dataframe
df_long &lt;- reshape(df2long, direction = &quot;long&quot;, varying = c(list(names(df2long)[3:14]), list(names(df2long)[15:26])), 
    v.names = c(&quot;other_freq&quot;, &quot;other_time&quot;), idvar = &quot;id&quot;, timevar = &quot;time&quot;, times = 1:12)

# Reorder data based on user id
df_long &lt;- df_long[(order(df_long$id)), ]

# create data to plot, seperately for men and women
data_all &lt;- df_long %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Full Sample&quot;)

data_men &lt;- df_long[which(df_long$gender == &quot;Male&quot;), ]
data_men &lt;- data_men %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Men&quot;)

data_women &lt;- df_long[which(df_long$gender == &quot;Female&quot;), ]
data_women &lt;- data_women %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Women&quot;)

# stack data
plot.data &lt;- rbind(data_all, data_men, data_women)
rm(data_all, data_men, data_women)

# add months
plot.data$month &lt;- rep(c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, 
    &quot;Dec&quot;), 3)

# plot
plot_mean_freq &lt;- ggplot(plot.data, aes(month, mean_freq, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_freq, ymin = mean_freq - se_freq, 
    ymax = mean_freq + se_freq, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Other frequency per week&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 5) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

plot_mean_time &lt;- ggplot(plot.data, aes(month, mean_time, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_time, ymin = mean_time - se_time, 
    ymax = mean_time + se_time, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Other volume per month&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 7) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

### Output ###

# histogram (assuming independent observations)
hist(df$vCovar$freq_other, main = &quot;Histogram of Other Frequency&quot;, xlab = &quot;Times per week&quot;, ylab = &quot;count&quot;, 
    col = &quot;grey&quot;, border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-52-1.png" width="672" /></p>
<pre class="r fold-hide"><code>hist(df$vCovar$time_other, main = &quot;Histogram of Other Volume&quot;, xlab = &quot;&quot;, ylab = &quot;count&quot;, col = &quot;grey&quot;, 
    border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-52-2.png" width="672" /></p>
<pre class="r fold-hide"><code># development mean over time
plot_mean_freq</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-52-3.png" width="672" /></p>
<pre class="r fold-hide"><code>plot_mean_time</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-52-4.png" width="672" /></p>
</div>
<div id="club-5-9" class="section level4">
<h4>Club 5</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata_rsiena[[5]]  # grab club 
df2 &lt;- clubdata[[5]]

# development of the mean over time

# retrieve gender
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# create wide dataframe
df2long &lt;- data.frame(id = 1:length(df$nodeSets$Actors), gender = gender, freq1 = df2$freq_other[, , 
    1], freq2 = df2$freq_other[, , 2], freq3 = df2$freq_other[, , 3], freq4 = df2$freq_other[, , 4], 
    freq5 = df2$freq_other[, , 5], freq6 = df2$freq_other[, , 6], freq7 = df2$freq_other[, , 7], freq8 = df2$freq_other[, 
        , 8], freq9 = df2$freq_other[, , 9], freq10 = df2$freq_other[, , 10], freq11 = df2$freq_other[, 
        , 11], freq12 = df2$freq_other[, , 12], time1 = df2$time_other[, , 1], time2 = df2$time_other[, 
        , 2], time3 = df2$time_other[, , 3], time4 = df2$time_other[, , 4], time5 = df2$time_other[, 
        , 5], time6 = df2$time_other[, , 6], time7 = df2$time_other[, , 7], time8 = df2$time_other[, 
        , 8], time9 = df2$time_other[, , 9], time10 = df2$time_other[, , 10], time11 = df2$time_other[, 
        , 11], time12 = df2$time_other[, , 12])

# reshape to long dataframe
df_long &lt;- reshape(df2long, direction = &quot;long&quot;, varying = c(list(names(df2long)[3:14]), list(names(df2long)[15:26])), 
    v.names = c(&quot;other_freq&quot;, &quot;other_time&quot;), idvar = &quot;id&quot;, timevar = &quot;time&quot;, times = 1:12)

# Reorder data based on user id
df_long &lt;- df_long[(order(df_long$id)), ]

# create data to plot, seperately for men and women
data_all &lt;- df_long %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Full Sample&quot;)

data_men &lt;- df_long[which(df_long$gender == &quot;Male&quot;), ]
data_men &lt;- data_men %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Men&quot;)

data_women &lt;- df_long[which(df_long$gender == &quot;Female&quot;), ]
data_women &lt;- data_women %&gt;% group_by(time) %&gt;% summarise(mean_freq = mean(other_freq, na.rm = T), mean_time = mean(other_time, 
    na.rm = T), se_freq = 1.96 * (sd(other_freq, na.rm = T)/sqrt(sum(!is.na(other_freq)))), se_time = 1.96 * 
    (sd(other_time, na.rm = T)/sqrt(sum(!is.na(other_time)))), sd_freq = sd(other_freq, na.rm = T), sd_time = sd(other_time, 
    na.rm = T), var_freq = var(other_freq, na.rm = T), var_time = var(other_time, na.rm = T), kurtosis_freq = kurtosis(other_freq, 
    na.rm = T) - 3, kurtosis_time = kurtosis(other_time, na.rm = T) - 3, class = &quot;Women&quot;)

# stack data
plot.data &lt;- rbind(data_all, data_men, data_women)
rm(data_all, data_men, data_women)

# add months
plot.data$month &lt;- rep(c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, 
    &quot;Dec&quot;), 3)

# plot
plot_mean_freq &lt;- ggplot(plot.data, aes(month, mean_freq, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_freq, ymin = mean_freq - se_freq, 
    ymax = mean_freq + se_freq, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Other frequency per week&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 5) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

plot_mean_time &lt;- ggplot(plot.data, aes(month, mean_time, group = class, colour = class)) + geom_point() + 
    geom_smooth(method = &quot;loess&quot;, size = 2) + geom_errorbar(aes(time, mean_time, ymin = mean_time - se_time, 
    ymax = mean_time + se_time, width = 0.4)) + theme_bw(base_family = &quot;serif&quot;, base_size = 16) + scale_colour_manual(values = c(&quot;#000000&quot;, 
    &quot;#E69F00&quot;, &quot;#56B4E9&quot;)) + labs(y = &quot;Other volume per month&quot;, x = &quot;Month&quot;) + scale_x_discrete(limits = c(&quot;Jan&quot;, 
    &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) + ylim(0, 7) + theme(axis.text.x = element_text(family = &quot;serif&quot;, 
    size = 10, angle = 45, hjust = 1), legend.position = &quot;right&quot;, legend.title = element_blank())

### Output ###

# histogram (assuming independent observations)
hist(df$vCovar$freq_other, main = &quot;Histogram of Other Frequency&quot;, xlab = &quot;Times per week&quot;, ylab = &quot;count&quot;, 
    col = &quot;grey&quot;, border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-53-1.png" width="672" /></p>
<pre class="r fold-hide"><code>hist(df$vCovar$time_other, main = &quot;Histogram of Other Volume&quot;, xlab = &quot;&quot;, ylab = &quot;count&quot;, col = &quot;grey&quot;, 
    border = &quot;black&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-53-2.png" width="672" /></p>
<pre class="r fold-hide"><code># development mean over time
plot_mean_freq</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-53-3.png" width="672" /></p>
<pre class="r fold-hide"><code>plot_mean_time</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-53-4.png" width="672" /></p>
</div>
</div>
<div id="section-12" class="section level3 unnumbered">
<h3></h3>
<hr />
<p><br></p>
</div>
</div>
<div id="within-person-change" class="section level2">
<h2>Within-person change</h2>
<div id="section-13" class="section level3 tabset tabset-fade">
<h3></h3>
<p>We have illustrated the development of the mean of the dependent behavioral variable over time, and the extent to which it differed across the genders. Now let’s also check if behavior varied over time within individuals. Within-person variation is a prerequisite for identifying influence effects on behavior. Down below we demonstrate how running activity varies within individuals over time, in absolute scores (i.e. in times per week).</p>
<div id="club-1-10" class="section level4">
<h4>Club 1</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata[[1]]  # grab club

# check within-person variability of running frequency absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[, , ]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df &lt;- df[(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size = 9, replace = F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line() + facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) + 
    xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-54-1.png" width="672" /></p>
</div>
<div id="club-2-10" class="section level4">
<h4>Club 2</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata[[2]]  # grab club

# check within-person variability of running frequency absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[, , ]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df &lt;- df[(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size = 9, replace = F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line() + facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) + 
    xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-55-1.png" width="672" /></p>
</div>
<div id="club-3-10" class="section level4">
<h4>Club 3</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata[[3]]  # grab club

# check within-person variability of running frequency absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[, , ]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df &lt;- df[(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size = 9, replace = F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line() + facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) + 
    xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-56-1.png" width="672" /></p>
</div>
<div id="club-4-10" class="section level4">
<h4>Club 4</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata[[4]]  # grab club

# check within-person variability of running frequency absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[, , ]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df &lt;- df[(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size = 9, replace = F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line() + facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) + 
    xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-57-1.png" width="672" /></p>
</div>
<div id="club-5-10" class="section level4">
<h4>Club 5</h4>
<pre class="r fold-hide"><code>df &lt;- clubdata[[5]]  # grab club

# check within-person variability of running frequency absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[, , ]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df &lt;- df[(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size = 9, replace = F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line() + facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) + 
    xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-58-1.png" width="672" /></p>
</div>
</div>
<div id="section-14" class="section level3 unnumbered">
<h3></h3>
<p>There seems to be ‘sufficient’ within-person variability in running behavior, at least in frequency.</p>
<hr />
<p><br></p>
</div>
</div>
<div id="network-autocorrelation" class="section level2">
<h2>Network autocorrelation</h2>
<div id="section-15" class="section level3 tabset tabset-fade">
<h3></h3>
<p>We have now covered the sport activity levels of our club-athletes, and the extent to which friendship- and Kudo-associations are segregated along gender. Last, we will explore if friendship- and Kudo-associations are also segregated along activity levels. Or in other words: do people with similar activity levels tend to socialize to a greater extent - by befriending one another and by exchanging Kudos - even when taking into account the opportunity structures for ‘interacting’ with (dis)similar others?</p>
<p>We use Moran’s I spatial autocorrelation measure for this, which is the correlation between the behavioral score of actor <em>i</em> and the (total/mean) behavioral score of alters <em>j</em> to whom <em>i</em> is connected <strong>directly</strong>. We included the behavioral scores of the actors <em>h</em> to whom <em>i</em> is indirectly tied, and used the negative exponential function as described by <span class="citation">Chen (2013)</span> as a distance-decay function for assigning weights.</p>
<div id="club-1-11" class="section level4">
<h4>Club 1</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[1]]  # grab club 
df2 &lt;- clubdata[[1]]  # grab club 

fnet &lt;- network::as.network(df$dycCovars$friendship)  # take friendship network
knet &lt;- df$depvars$kudonet  # take kudo network
knet1 &lt;- network::as.network(knet[, , 1])  # let&#39;s take wave 1

# get behavioral data
freq1 &lt;- df2$freq_run[, , 1]  # running frequencies wave 1
vol1 &lt;- df2$time_run[, , 1]  # running volume wave 1

# we include geodistances: shortest path lengths from i to j
f_geodistances &lt;- sna::geodist(fnet, count.paths = T)
f_geodistances &lt;- f_geodistances$gdist
k_geodistances &lt;- sna::geodist(knet1, count.paths = T)
k_geodistances &lt;- k_geodistances$gdist

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(f_geodistances) &lt;- Inf
diag(k_geodistances) &lt;- Inf

# and use the negative exponential distance-decay function
f_weights2 &lt;- exp(-f_geodistances)
k_weights2 &lt;- exp(-k_geodistances)

# calculate Moran&#39;s I we do not row standardize!
f_freq &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
f_vol &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_freq &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_vol &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results 1. frequency
mat &lt;- matrix(NA, nrow = 2, ncol = 4)
mat[1, 1] &lt;- f_freq$observed
mat[1, 2] &lt;- f_freq$expected
mat[1, 3] &lt;- f_freq$sd
mat[1, 4] &lt;- f_freq$p.value
mat[2, 1] &lt;- k_freq$observed
mat[2, 2] &lt;- k_freq$expected
mat[2, 3] &lt;- k_freq$sd
mat[2, 4] &lt;- k_freq$p.value

# 2. volume
mat2 &lt;- matrix(NA, nrow = 2, ncol = 4)
mat2[1, 1] &lt;- f_vol$observed
mat2[1, 2] &lt;- f_vol$expected
mat2[1, 3] &lt;- f_vol$sd
mat2[1, 4] &lt;- f_vol$p.value
mat2[2, 1] &lt;- k_vol$observed
mat2[2, 2] &lt;- k_vol$expected
mat2[2, 3] &lt;- k_vol$sd
mat2[2, 4] &lt;- k_vol$p.value

colnames(mat) &lt;- colnames(mat2) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(mat) &lt;- rownames(mat2) &lt;- c(&quot;friendship network&quot;, &quot;kudo network&quot;)

knitr::kable(mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
friendship network
</td>
<td style="text-align:right;">
0.00
</td>
<td style="text-align:right;">
-0.03
</td>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:right;">
0.48
</td>
</tr>
<tr>
<td style="text-align:left;">
kudo network
</td>
<td style="text-align:right;">
0.26
</td>
<td style="text-align:right;">
-0.03
</td>
<td style="text-align:right;">
0.09
</td>
<td style="text-align:right;">
0.00
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(mat2, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
friendship network
</td>
<td style="text-align:right;">
-0.03
</td>
<td style="text-align:right;">
-0.03
</td>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:right;">
0.9
</td>
</tr>
<tr>
<td style="text-align:left;">
kudo network
</td>
<td style="text-align:right;">
0.28
</td>
<td style="text-align:right;">
-0.03
</td>
<td style="text-align:right;">
0.09
</td>
<td style="text-align:right;">
0.0
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-2-11" class="section level4">
<h4>Club 2</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[2]]  # grab club 
df2 &lt;- clubdata[[2]]  # grab club 

fnet &lt;- network::as.network(df$dycCovars$friendship)  # take friendship network
knet &lt;- df$depvars$kudonet  # take kudo network
knet1 &lt;- network::as.network(knet[, , 1])  # let&#39;s take wave 1

# get behavioral data
freq1 &lt;- df2$freq_run[, , 1]  # running frequencies wave 1
vol1 &lt;- df2$time_run[, , 1]  # running volume wave 1

# we include geodistances: shortest path lengths from i to j
f_geodistances &lt;- sna::geodist(fnet, count.paths = T)
f_geodistances &lt;- f_geodistances$gdist
k_geodistances &lt;- sna::geodist(knet1, count.paths = T)
k_geodistances &lt;- k_geodistances$gdist

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(f_geodistances) &lt;- Inf
diag(k_geodistances) &lt;- Inf

# and use the negative exponential distance-decay function
f_weights2 &lt;- exp(-f_geodistances)
k_weights2 &lt;- exp(-k_geodistances)

# calculate Moran&#39;s I we do not row standardize!
f_freq &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
f_vol &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_freq &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_vol &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results 1. frequency
mat &lt;- matrix(NA, nrow = 2, ncol = 4)
mat[1, 1] &lt;- f_freq$observed
mat[1, 2] &lt;- f_freq$expected
mat[1, 3] &lt;- f_freq$sd
mat[1, 4] &lt;- f_freq$p.value
mat[2, 1] &lt;- k_freq$observed
mat[2, 2] &lt;- k_freq$expected
mat[2, 3] &lt;- k_freq$sd
mat[2, 4] &lt;- k_freq$p.value

# 2. volume
mat2 &lt;- matrix(NA, nrow = 2, ncol = 4)
mat2[1, 1] &lt;- f_vol$observed
mat2[1, 2] &lt;- f_vol$expected
mat2[1, 3] &lt;- f_vol$sd
mat2[1, 4] &lt;- f_vol$p.value
mat2[2, 1] &lt;- k_vol$observed
mat2[2, 2] &lt;- k_vol$expected
mat2[2, 3] &lt;- k_vol$sd
mat2[2, 4] &lt;- k_vol$p.value

colnames(mat) &lt;- colnames(mat2) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(mat) &lt;- rownames(mat2) &lt;- c(&quot;friendship network&quot;, &quot;kudo network&quot;)

knitr::kable(mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
friendship network
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
kudo network
</td>
<td style="text-align:right;">
0.14
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.02
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(mat2, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
friendship network
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
kudo network
</td>
<td style="text-align:right;">
0.15
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.02
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-3-11" class="section level4">
<h4>Club 3</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[3]]  # grab club 
df2 &lt;- clubdata[[3]]  # grab club 

fnet &lt;- network::as.network(df$dycCovars$friendship)  # take friendship network
knet &lt;- df$depvars$kudonet  # take kudo network
knet1 &lt;- network::as.network(knet[, , 1])  # let&#39;s take wave 1

# get behavioral data
freq1 &lt;- df2$freq_run[, , 1]  # running frequencies wave 1
vol1 &lt;- df2$time_run[, , 1]  # running volume wave 1

# we include geodistances: shortest path lengths from i to j
f_geodistances &lt;- sna::geodist(fnet, count.paths = T)
f_geodistances &lt;- f_geodistances$gdist
k_geodistances &lt;- sna::geodist(knet1, count.paths = T)
k_geodistances &lt;- k_geodistances$gdist

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(f_geodistances) &lt;- Inf
diag(k_geodistances) &lt;- Inf

# and use the negative exponential distance-decay function
f_weights2 &lt;- exp(-f_geodistances)
k_weights2 &lt;- exp(-k_geodistances)

# calculate Moran&#39;s I we do not row standardize!
f_freq &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
f_vol &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_freq &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_vol &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results 1. frequency
mat &lt;- matrix(NA, nrow = 2, ncol = 4)
mat[1, 1] &lt;- f_freq$observed
mat[1, 2] &lt;- f_freq$expected
mat[1, 3] &lt;- f_freq$sd
mat[1, 4] &lt;- f_freq$p.value
mat[2, 1] &lt;- k_freq$observed
mat[2, 2] &lt;- k_freq$expected
mat[2, 3] &lt;- k_freq$sd
mat[2, 4] &lt;- k_freq$p.value

# 2. volume
mat2 &lt;- matrix(NA, nrow = 2, ncol = 4)
mat2[1, 1] &lt;- f_vol$observed
mat2[1, 2] &lt;- f_vol$expected
mat2[1, 3] &lt;- f_vol$sd
mat2[1, 4] &lt;- f_vol$p.value
mat2[2, 1] &lt;- k_vol$observed
mat2[2, 2] &lt;- k_vol$expected
mat2[2, 3] &lt;- k_vol$sd
mat2[2, 4] &lt;- k_vol$p.value

colnames(mat) &lt;- colnames(mat2) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(mat) &lt;- rownames(mat2) &lt;- c(&quot;friendship network&quot;, &quot;kudo network&quot;)

knitr::kable(mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
friendship network
</td>
<td style="text-align:right;">
0.00
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
0.51
</td>
</tr>
<tr>
<td style="text-align:left;">
kudo network
</td>
<td style="text-align:right;">
0.08
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
0.00
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(mat2, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
friendship network
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
0.18
</td>
</tr>
<tr>
<td style="text-align:left;">
kudo network
</td>
<td style="text-align:right;">
0.28
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
0.00
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-4-11" class="section level4">
<h4>Club 4</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[4]]  # grab club 
df2 &lt;- clubdata[[4]]  # grab club 

fnet &lt;- network::as.network(df$dycCovars$friendship)  # take friendship network
knet &lt;- df$depvars$kudonet  # take kudo network
knet1 &lt;- network::as.network(knet[, , 1])  # let&#39;s take wave 1

# get behavioral data
freq1 &lt;- df2$freq_run[, , 1]  # running frequencies wave 1
vol1 &lt;- df2$time_run[, , 1]  # running volume wave 1

# we include geodistances: shortest path lengths from i to j
f_geodistances &lt;- sna::geodist(fnet, count.paths = T)
f_geodistances &lt;- f_geodistances$gdist
k_geodistances &lt;- sna::geodist(knet1, count.paths = T)
k_geodistances &lt;- k_geodistances$gdist

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(f_geodistances) &lt;- Inf
diag(k_geodistances) &lt;- Inf

# and use the negative exponential distance-decay function
f_weights2 &lt;- exp(-f_geodistances)
k_weights2 &lt;- exp(-k_geodistances)

# calculate Moran&#39;s I we do not row standardize!
f_freq &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
f_vol &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_freq &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_vol &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results 1. frequency
mat &lt;- matrix(NA, nrow = 2, ncol = 4)
mat[1, 1] &lt;- f_freq$observed
mat[1, 2] &lt;- f_freq$expected
mat[1, 3] &lt;- f_freq$sd
mat[1, 4] &lt;- f_freq$p.value
mat[2, 1] &lt;- k_freq$observed
mat[2, 2] &lt;- k_freq$expected
mat[2, 3] &lt;- k_freq$sd
mat[2, 4] &lt;- k_freq$p.value

# 2. volume
mat2 &lt;- matrix(NA, nrow = 2, ncol = 4)
mat2[1, 1] &lt;- f_vol$observed
mat2[1, 2] &lt;- f_vol$expected
mat2[1, 3] &lt;- f_vol$sd
mat2[1, 4] &lt;- f_vol$p.value
mat2[2, 1] &lt;- k_vol$observed
mat2[2, 2] &lt;- k_vol$expected
mat2[2, 3] &lt;- k_vol$sd
mat2[2, 4] &lt;- k_vol$p.value

colnames(mat) &lt;- colnames(mat2) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(mat) &lt;- rownames(mat2) &lt;- c(&quot;friendship network&quot;, &quot;kudo network&quot;)

knitr::kable(mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
friendship network
</td>
<td style="text-align:right;">
-0.13
</td>
<td style="text-align:right;">
-0.08
</td>
<td style="text-align:right;">
0.09
</td>
<td style="text-align:right;">
0.62
</td>
</tr>
<tr>
<td style="text-align:left;">
kudo network
</td>
<td style="text-align:right;">
0.53
</td>
<td style="text-align:right;">
-0.08
</td>
<td style="text-align:right;">
0.29
</td>
<td style="text-align:right;">
0.03
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(mat2, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
friendship network
</td>
<td style="text-align:right;">
-0.09
</td>
<td style="text-align:right;">
-0.08
</td>
<td style="text-align:right;">
0.09
</td>
<td style="text-align:right;">
0.95
</td>
</tr>
<tr>
<td style="text-align:left;">
kudo network
</td>
<td style="text-align:right;">
0.69
</td>
<td style="text-align:right;">
-0.08
</td>
<td style="text-align:right;">
0.29
</td>
<td style="text-align:right;">
0.01
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-5-11" class="section level4">
<h4>Club 5</h4>
<pre class="r test"><code>df &lt;- clubdata_rsiena[[5]]  # grab club 
df2 &lt;- clubdata[[5]]  # grab club 

fnet &lt;- network::as.network(df$dycCovars$friendship)  # take friendship network
knet &lt;- df$depvars$kudonet  # take kudo network
knet1 &lt;- network::as.network(knet[, , 1])  # let&#39;s take wave 1

# get behavioral data
freq1 &lt;- df2$freq_run[, , 1]  # running frequencies wave 1
vol1 &lt;- df2$time_run[, , 1]  # running volume wave 1

# we include geodistances: shortest path lengths from i to j
f_geodistances &lt;- sna::geodist(fnet, count.paths = T)
f_geodistances &lt;- f_geodistances$gdist
k_geodistances &lt;- sna::geodist(knet1, count.paths = T)
k_geodistances &lt;- k_geodistances$gdist

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(f_geodistances) &lt;- Inf
diag(k_geodistances) &lt;- Inf

# and use the negative exponential distance-decay function
f_weights2 &lt;- exp(-f_geodistances)
k_weights2 &lt;- exp(-k_geodistances)

# calculate Moran&#39;s I we do not row standardize!
f_freq &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
f_vol &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_freq &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_vol &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results 1. frequency
mat &lt;- matrix(NA, nrow = 2, ncol = 4)
mat[1, 1] &lt;- f_freq$observed
mat[1, 2] &lt;- f_freq$expected
mat[1, 3] &lt;- f_freq$sd
mat[1, 4] &lt;- f_freq$p.value
mat[2, 1] &lt;- k_freq$observed
mat[2, 2] &lt;- k_freq$expected
mat[2, 3] &lt;- k_freq$sd
mat[2, 4] &lt;- k_freq$p.value

# 2. volume
mat2 &lt;- matrix(NA, nrow = 2, ncol = 4)
mat2[1, 1] &lt;- f_vol$observed
mat2[1, 2] &lt;- f_vol$expected
mat2[1, 3] &lt;- f_vol$sd
mat2[1, 4] &lt;- f_vol$p.value
mat2[2, 1] &lt;- k_vol$observed
mat2[2, 2] &lt;- k_vol$expected
mat2[2, 3] &lt;- k_vol$sd
mat2[2, 4] &lt;- k_vol$p.value

colnames(mat) &lt;- colnames(mat2) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(mat) &lt;- rownames(mat2) &lt;- c(&quot;friendship network&quot;, &quot;kudo network&quot;)

knitr::kable(mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
friendship network
</td>
<td style="text-align:right;">
0.06
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
kudo network
</td>
<td style="text-align:right;">
0.18
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.02
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(mat2, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;% 
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
friendship network
</td>
<td style="text-align:right;">
0.06
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
kudo network
</td>
<td style="text-align:right;">
0.25
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.02
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="section-16" class="section level3 unnumbered">
<h3></h3>
<p>Here, the Moran’s I statistic tests whether club members that are <em>closer to one another</em> (i.e., having a shorter geodesic/path length), are more a similar with respect to their behavior, under the null hypothesis that behavior is ‘randomly distributed’ among the club members.</p>
<p>We observe that, indeed, friends that are closer to one another are more alike, and especially “strong tie” friends (indicated by the strongly significant Moran’s I statistics on the Kudo networks). Additional analyses (not shown here) revealed that autocorrelation was even stronger without the distance-decay function, which suggests that especially close alters (with path length one) are similar.</p>
<hr />
<p><br></p>
</div>
</div>
</div>
<div id="egos" class="section level1">
<h1>Egos</h1>
<p>For the egonets, we went two levels deep: 1) we mapped all the others Strava users that are followed by ego, 2) and all the Strava users that are followed by ego’s alters (i.e. “friends of friends”); we mapped all ties defined on this set (which we define as a 2.5 degree ego-centered network).</p>
<p>Let’s see what the resulting networks look like.</p>
<div id="degree" class="section level2">
<h2>2.5 degree</h2>
<div id="section-17" class="section level3 tabset tabset-fade">
<h3></h3>
<div id="e1" class="section level4">
<h4>E1</h4>
<pre class="r test"><code>df &lt;- egodata2.5[[1]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# identify ego&#39;s alters (1.0)
e &lt;- as.data.frame(get.edgelist(G))
colnames(e) &lt;- c(&quot;i&quot;, &quot;j&quot;)
e$alter &lt;- ifelse(e$i == vertex_attr(G)$name[1], 1, 0) #if ego i follows actor j, j is ego&#39;s alter

# make actors (ego, 1.0-alter; 2.0-alters) identifiable
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1))) # ego = squared
vertex_attr(G)$size &lt;- c(8, rep(4, (nrow(fnet) - 1))) # and bigger
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;, ifelse(vertex_attr(G)$name %in% e$j[e$alter==1], &quot;#FFFFB3&quot;, &quot;#8DD3C7&quot;))


# plot
par(bg=&quot;white&quot;)
plot(simplify(G),
     
     main = &quot;2.5 ego-centered network of directed STRAVA friendships&quot;,
     sub = &quot;ego is purple squared node, their alters (1.0) are yellow nodes, alters of alters (2.0) are green nodes&quot;,
     
     
     # === vertex
     vertex.frame.color =&quot;black&quot;,          
     vertex.shape=vertex_attr(G)$shape,                    
     vertex.size=vertex_attr(G)$size,
     vertex.size2=NA,                            
     
     # === vertex label
     vertex.label=NA,                             
     vertex.label.family=&quot;Times&quot;,              
     vertex.label.font=2,                     
     vertex.label.cex=1,                           
     vertex.label.dist=0,                        
     vertex.label.degree=0 ,                      
     
     # === Edge
     edge.color=&quot;black&quot;,                           
     edge.width=1,                                
     edge.arrow.size=0,                      
     edge.arrow.width=0,                         
     edge.lty=&quot;solid&quot;,                             
     edge.curved=0)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-64-1.png" width="1152" /></p>
</div>
<div id="e2" class="section level4">
<h4>E2</h4>
<pre class="r test"><code>df &lt;- egodata2.5[[2]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# identify ego&#39;s alters (1.0)
e &lt;- as.data.frame(get.edgelist(G))
colnames(e) &lt;- c(&quot;i&quot;, &quot;j&quot;)
e$alter &lt;- ifelse(e$i == vertex_attr(G)$name[1], 1, 0) #if ego i follows actor j, j is ego&#39;s alter

# make actors (ego, 1.0-alter; 2.0-alters) identifiable
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1))) # ego = squared
vertex_attr(G)$size &lt;- c(8, rep(4, (nrow(fnet) - 1))) # and bigger
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;, ifelse(vertex_attr(G)$name %in% e$j[e$alter==1], &quot;#FFFFB3&quot;, &quot;#8DD3C7&quot;))


# plot
par(bg=&quot;white&quot;)
plot(simplify(G),
     
     main = &quot;2.5 ego-centered network of directed STRAVA friendships&quot;,
     sub = &quot;ego is purple squared node, their alters (1.0) are yellow nodes, alters of alters (2.0) are green nodes&quot;,
     
     
     # === vertex
     vertex.frame.color =&quot;black&quot;,          
     vertex.shape=vertex_attr(G)$shape,                    
     vertex.size=vertex_attr(G)$size,
     vertex.size2=NA,                            
     
     # === vertex label
     vertex.label=NA,                             
     vertex.label.family=&quot;Times&quot;,              
     vertex.label.font=2,                     
     vertex.label.cex=1,                           
     vertex.label.dist=0,                        
     vertex.label.degree=0 ,                      
     
     # === Edge
     edge.color=&quot;black&quot;,                           
     edge.width=1,                                
     edge.arrow.size=0,                      
     edge.arrow.width=0,                         
     edge.lty=&quot;solid&quot;,                             
     edge.curved=0)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-65-1.png" width="1152" /></p>
</div>
<div id="e3" class="section level4">
<h4>E3</h4>
<pre class="r test"><code>df &lt;- egodata2.5[[3]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# identify ego (the first node)
vertex_attr(G)$name[1] &lt;- &quot;ego&quot;

# identify ego&#39;s alters (1.0)
e &lt;- as.data.frame(get.edgelist(G))
colnames(e) &lt;- c(&quot;i&quot;, &quot;j&quot;)
e$alter &lt;- ifelse(e$i == vertex_attr(G)$name[1], 1, 0) #if ego i follows actor j, j is ego&#39;s alter

# make actors (ego, 1.0-alter; 2.0-alters) identifiable
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1))) # ego = squared
vertex_attr(G)$size &lt;- c(8, rep(4, (nrow(fnet) - 1))) # and bigger
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;, ifelse(vertex_attr(G)$name %in% e$j[e$alter==1], &quot;#FFFFB3&quot;, &quot;#8DD3C7&quot;))


# plot
par(bg=&quot;white&quot;)
plot(simplify(G),
     
     main = &quot;2.5 ego-centered network of directed STRAVA friendships&quot;,
     sub = &quot;ego is purple squared node, their alters (1.0) are yellow nodes, alters of alters (2.0) are green nodes&quot;,
     
     
     # === vertex
     vertex.frame.color =&quot;black&quot;,          
     vertex.shape=vertex_attr(G)$shape,                    
     vertex.size=vertex_attr(G)$size,
     vertex.size2=NA,                            
     
     # === vertex label
     vertex.label=NA,                             
     vertex.label.family=&quot;Times&quot;,              
     vertex.label.font=2,                     
     vertex.label.cex=1,                           
     vertex.label.dist=0,                        
     vertex.label.degree=0 ,                      
     
     # === Edge
     edge.color=&quot;black&quot;,                           
     edge.width=1,                                
     edge.arrow.size=0,                      
     edge.arrow.width=0,                         
     edge.lty=&quot;solid&quot;,                             
     edge.curved=0)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-66-1.png" width="1152" /></p>
</div>
<div id="e4" class="section level4">
<h4>E4</h4>
<pre class="r test"><code>df &lt;- egodata2.5[[4]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# identify ego&#39;s alters (1.0)
e &lt;- as.data.frame(get.edgelist(G))
colnames(e) &lt;- c(&quot;i&quot;, &quot;j&quot;)
e$alter &lt;- ifelse(e$i == vertex_attr(G)$name[1], 1, 0) #if ego i follows actor j, j is ego&#39;s alter

# make actors (ego, 1.0-alter; 2.0-alters) identifiable
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1))) # ego = squared
vertex_attr(G)$size &lt;- c(8, rep(4, (nrow(fnet) - 1))) # and bigger
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;, ifelse(vertex_attr(G)$name %in% e$j[e$alter==1], &quot;#FFFFB3&quot;, &quot;#8DD3C7&quot;))


# plot
par(bg=&quot;white&quot;)
plot(simplify(G),
     
     main = &quot;2.5 ego-centered network of directed STRAVA friendships&quot;,
     sub = &quot;ego is purple squared node, their alters (1.0) are yellow nodes, alters of alters (2.0) are green nodes&quot;,
     
     
     # === vertex
     vertex.frame.color =&quot;black&quot;,          
     vertex.shape=vertex_attr(G)$shape,                    
     vertex.size=vertex_attr(G)$size,
     vertex.size2=NA,                            
     
     # === vertex label
     vertex.label=NA,                             
     vertex.label.family=&quot;Times&quot;,              
     vertex.label.font=2,                     
     vertex.label.cex=1,                           
     vertex.label.dist=0,                        
     vertex.label.degree=0 ,                      
     
     # === Edge
     edge.color=&quot;black&quot;,                           
     edge.width=1,                                
     edge.arrow.size=0,                      
     edge.arrow.width=0,                         
     edge.lty=&quot;solid&quot;,                             
     edge.curved=0)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-67-1.png" width="1152" /></p>
</div>
<div id="e5" class="section level4">
<h4>E5</h4>
<pre class="r test"><code>df &lt;- egodata2.5[[5]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# identify ego&#39;s alters (1.0)
e &lt;- as.data.frame(get.edgelist(G))
colnames(e) &lt;- c(&quot;i&quot;, &quot;j&quot;)
e$alter &lt;- ifelse(e$i == vertex_attr(G)$name[1], 1, 0) #if ego i follows actor j, j is ego&#39;s alter

# make actors (ego, 1.0-alter; 2.0-alters) identifiable
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1))) # ego = squared
vertex_attr(G)$size &lt;- c(8, rep(4, (nrow(fnet) - 1))) # and bigger
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;, ifelse(vertex_attr(G)$name %in% e$j[e$alter==1], &quot;#FFFFB3&quot;, &quot;#8DD3C7&quot;))


# plot
par(bg=&quot;white&quot;)
plot(simplify(G),
     
     main = &quot;2.5 ego-centered network of directed STRAVA friendships&quot;,
     sub = &quot;ego is purple squared node, their alters (1.0) are yellow nodes, alters of alters (2.0) are green nodes&quot;,
     
     
     # === vertex
     vertex.frame.color =&quot;black&quot;,          
     vertex.shape=vertex_attr(G)$shape,                    
     vertex.size=vertex_attr(G)$size,
     vertex.size2=NA,                            
     
     # === vertex label
     vertex.label=NA,                             
     vertex.label.family=&quot;Times&quot;,              
     vertex.label.font=2,                     
     vertex.label.cex=1,                           
     vertex.label.dist=0,                        
     vertex.label.degree=0 ,                      
     
     # === Edge
     edge.color=&quot;black&quot;,                           
     edge.width=1,                                
     edge.arrow.size=0,                      
     edge.arrow.width=0,                         
     edge.lty=&quot;solid&quot;,                             
     edge.curved=0)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-68-1.png" width="1152" /></p>
</div>
<div id="e6" class="section level4">
<h4>E6</h4>
<pre class="r test"><code>df &lt;- egodata2.5[[6]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# identify ego&#39;s alters (1.0)
e &lt;- as.data.frame(get.edgelist(G))
colnames(e) &lt;- c(&quot;i&quot;, &quot;j&quot;)
e$alter &lt;- ifelse(e$i == vertex_attr(G)$name[1], 1, 0) #if ego i follows actor j, j is ego&#39;s alter

# make actors (ego, 1.0-alter; 2.0-alters) identifiable
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1))) # ego = squared
vertex_attr(G)$size &lt;- c(8, rep(4, (nrow(fnet) - 1))) # and bigger
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;, ifelse(vertex_attr(G)$name %in% e$j[e$alter==1], &quot;#FFFFB3&quot;, &quot;#8DD3C7&quot;))


# plot
par(bg=&quot;white&quot;)
plot(simplify(G),
     
     main = &quot;2.5 ego-centered network of directed STRAVA friendships&quot;,
     sub = &quot;ego is purple squared node, their alters (1.0) are yellow nodes, alters of alters (2.0) are green nodes&quot;,
     
     
     # === vertex
     vertex.frame.color =&quot;black&quot;,          
     vertex.shape=vertex_attr(G)$shape,                    
     vertex.size=vertex_attr(G)$size,
     vertex.size2=NA,                            
     
     # === vertex label
     vertex.label=NA,                             
     vertex.label.family=&quot;Times&quot;,              
     vertex.label.font=2,                     
     vertex.label.cex=1,                           
     vertex.label.dist=0,                        
     vertex.label.degree=0 ,                      
     
     # === Edge
     edge.color=&quot;black&quot;,                           
     edge.width=1,                                
     edge.arrow.size=0,                      
     edge.arrow.width=0,                         
     edge.lty=&quot;solid&quot;,                             
     edge.curved=0)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-69-1.png" width="1152" /></p>
</div>
<div id="e8" class="section level4">
<h4>E8</h4>
<pre class="r test"><code>df &lt;- egodata2.5[[8]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# identify ego&#39;s alters (1.0)
e &lt;- as.data.frame(get.edgelist(G))
colnames(e) &lt;- c(&quot;i&quot;, &quot;j&quot;)
e$alter &lt;- ifelse(e$i == vertex_attr(G)$name[1], 1, 0) #if ego i follows actor j, j is ego&#39;s alter

# make actors (ego, 1.0-alter; 2.0-alters) identifiable
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1))) # ego = squared
vertex_attr(G)$size &lt;- c(8, rep(4, (nrow(fnet) - 1))) # and bigger
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;, ifelse(vertex_attr(G)$name %in% e$j[e$alter==1], &quot;#FFFFB3&quot;, &quot;#8DD3C7&quot;))

# plot
par(bg=&quot;white&quot;)
plot(simplify(G),
     
     main = &quot;2.5 ego-centered network of directed STRAVA friendships&quot;,
     sub = &quot;ego is purple squared node, their alters (1.0) are yellow nodes, alters of alters (2.0) are green nodes&quot;,
     
     
     # === vertex
     vertex.frame.color =&quot;black&quot;,          
     vertex.shape=vertex_attr(G)$shape,                    
     vertex.size=vertex_attr(G)$size,
     vertex.size2=NA,                            
     
     # === vertex label
     vertex.label=NA,                             
     vertex.label.family=&quot;Times&quot;,              
     vertex.label.font=2,                     
     vertex.label.cex=1,                           
     vertex.label.dist=0,                        
     vertex.label.degree=0 ,                      
     
     # === Edge
     edge.color=&quot;black&quot;,                           
     edge.width=1,                                
     edge.arrow.size=0,                      
     edge.arrow.width=0,                         
     edge.lty=&quot;solid&quot;,                             
     edge.curved=0)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-70-1.png" width="1152" /></p>
</div>
<div id="e9" class="section level4">
<h4>E9</h4>
<pre class="r test"><code>df &lt;- egodata2.5[[9]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# identify ego&#39;s alters (1.0)
e &lt;- as.data.frame(get.edgelist(G))
colnames(e) &lt;- c(&quot;i&quot;, &quot;j&quot;)
e$alter &lt;- ifelse(e$i == vertex_attr(G)$name[1], 1, 0) #if ego i follows actor j, j is ego&#39;s alter

# make actors (ego, 1.0-alter; 2.0-alters) identifiable
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1))) # ego = squared
vertex_attr(G)$size &lt;- c(8, rep(4, (nrow(fnet) - 1))) # and bigger
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;, ifelse(vertex_attr(G)$name %in% e$j[e$alter==1], &quot;#FFFFB3&quot;, &quot;#8DD3C7&quot;))

# plot
par(bg=&quot;white&quot;)
plot(simplify(G),
     
     main = &quot;2.5 ego-centered network of directed STRAVA friendships&quot;,
     sub = &quot;ego is purple squared node, their alters (1.0) are yellow nodes, alters of alters (2.0) are green nodes&quot;,
     
     
     # === vertex
     vertex.frame.color =&quot;black&quot;,          
     vertex.shape=vertex_attr(G)$shape,                    
     vertex.size=vertex_attr(G)$size,
     vertex.size2=NA,                            
     
     # === vertex label
     vertex.label=NA,                             
     vertex.label.family=&quot;Times&quot;,              
     vertex.label.font=2,                     
     vertex.label.cex=1,                           
     vertex.label.dist=0,                        
     vertex.label.degree=0 ,                      
     
     # === Edge
     edge.color=&quot;black&quot;,                           
     edge.width=1,                                
     edge.arrow.size=0,                      
     edge.arrow.width=0,                         
     edge.lty=&quot;solid&quot;,                             
     edge.curved=0)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-71-1.png" width="1152" /></p>
</div>
<div id="e10" class="section level4">
<h4>E10</h4>
<pre class="r test"><code>df &lt;- egodata2.5[[10]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# identify ego&#39;s alters (1.0)
e &lt;- as.data.frame(get.edgelist(G))
colnames(e) &lt;- c(&quot;i&quot;, &quot;j&quot;)
e$alter &lt;- ifelse(e$i == vertex_attr(G)$name[1], 1, 0) #if ego i follows actor j, j is ego&#39;s alter

# make actors (ego, 1.0-alter; 2.0-alters) identifiable
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1))) # ego = squared
vertex_attr(G)$size &lt;- c(8, rep(4, (nrow(fnet) - 1))) # and bigger
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;, ifelse(vertex_attr(G)$name %in% e$j[e$alter==1], &quot;#FFFFB3&quot;, &quot;#8DD3C7&quot;))

# plot
par(bg=&quot;white&quot;)
plot(simplify(G),
     
     main = &quot;2.5 ego-centered network of directed STRAVA friendships&quot;,
     sub = &quot;ego is purple squared node, their alters (1.0) are yellow nodes, alters of alters (2.0) are green nodes&quot;,
     
     
     # === vertex
     vertex.frame.color =&quot;black&quot;,          
     vertex.shape=vertex_attr(G)$shape,                    
     vertex.size=vertex_attr(G)$size,
     vertex.size2=NA,                            
     
     # === vertex label
     vertex.label=NA,                             
     vertex.label.family=&quot;Times&quot;,              
     vertex.label.font=2,                     
     vertex.label.cex=1,                           
     vertex.label.dist=0,                        
     vertex.label.degree=0 ,                      
     
     # === Edge
     edge.color=&quot;black&quot;,                           
     edge.width=1,                                
     edge.arrow.size=0,                      
     edge.arrow.width=0,                         
     edge.lty=&quot;solid&quot;,                             
     edge.curved=0)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-72-1.png" width="1152" /></p>
</div>
<div id="e11" class="section level4">
<h4>E11</h4>
<pre class="r test"><code>df &lt;- egodata2.5[[11]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# identify ego&#39;s alters (1.0)
e &lt;- as.data.frame(get.edgelist(G))
colnames(e) &lt;- c(&quot;i&quot;, &quot;j&quot;)
e$alter &lt;- ifelse(e$i == vertex_attr(G)$name[1], 1, 0) #if ego i follows actor j, j is ego&#39;s alter

# make actors (ego, 1.0-alter; 2.0-alters) identifiable
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1))) # ego = squared
vertex_attr(G)$size &lt;- c(8, rep(4, (nrow(fnet) - 1))) # and bigger
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;, ifelse(vertex_attr(G)$name %in% e$j[e$alter==1], &quot;#FFFFB3&quot;, &quot;#8DD3C7&quot;))

# plot
par(bg=&quot;white&quot;)
plot(simplify(G),
     
     main = &quot;2.5 ego-centered network of directed STRAVA friendships&quot;,
     sub = &quot;ego is purple squared node, their alters (1.0) are yellow nodes, alters of alters (2.0) are green nodes&quot;,
     
     
     # === vertex
     vertex.frame.color =&quot;black&quot;,          
     vertex.shape=vertex_attr(G)$shape,                    
     vertex.size=vertex_attr(G)$size,
     vertex.size2=NA,                            
     
     # === vertex label
     vertex.label=NA,                             
     vertex.label.family=&quot;Times&quot;,              
     vertex.label.font=2,                     
     vertex.label.cex=1,                           
     vertex.label.dist=0,                        
     vertex.label.degree=0 ,                      
     
     # === Edge
     edge.color=&quot;black&quot;,                           
     edge.width=1,                                
     edge.arrow.size=0,                      
     edge.arrow.width=0,                         
     edge.lty=&quot;solid&quot;,                             
     edge.curved=0)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-73-1.png" width="1152" /></p>
</div>
</div>
<div id="section-18" class="section level3 unnumbered">
<h3></h3>
<p>These are very big networks, so we will start with describing 1.5 degree ego-centered networks, which we define as the network consisting of ego, ego’s alters, and the ties defined on this set.</p>
<hr />
<p><br></p>
</div>
</div>
<div id="degree-1" class="section level2">
<h2>1.5 degree</h2>
<div id="section-19" class="section level3 tabset tabset-fade">
<h3></h3>
<div id="e1-1" class="section level4">
<h4>E1</h4>
<pre class="r test"><code>df &lt;- egodata1.5[[1]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# actor attributes: shape and colour
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1)))
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;,&quot;#FFFFB3&quot;)

# plot
{
  plot(simplify(G),
       main = &quot;1.5 ego-centered network of directed STRAVA friendships&quot;,

       # === vertex
       vertex.frame.color =&quot;black&quot;,          
       vertex.size2=NA,                            
       
       # === vertex label
       vertex.label=NA,                             
       vertex.label.family=&quot;Times&quot;,              
       vertex.label.font=2,                     
       vertex.label.cex=1,                           
       vertex.label.dist=0,                        
       vertex.label.degree=0 ,                      
       
       # === Edge
       edge.color=&quot;black&quot;,                           
       edge.width=1,                                
       edge.arrow.size=.4,                      
       edge.arrow.width=1,                         
       edge.lty=&quot;solid&quot;,                             
       edge.curved=0)
  
  # Add a legend
  legend(&quot;bottomleft&quot;, legend=c(&quot;ego&quot;, &quot;alter&quot;),
         col = vertex.attributes(G)$color, bty = &quot;n&quot;, pt.cex = 2.5, pch = c(15, 19), horiz = F, inset = c(0.15, 0.15)
  )
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-74-1.png" width="672" /></p>
</div>
<div id="e2-1" class="section level4">
<h4>E2</h4>
<pre class="r test"><code>df &lt;- egodata1.5[[2]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# actor attributes: shape and colour
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1)))
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;,&quot;#FFFFB3&quot;)

# plot
{
  plot(simplify(G),
       main = &quot;1.5 ego-centered network of directed STRAVA friendships&quot;,

       # === vertex
       vertex.frame.color =&quot;black&quot;,          
       vertex.size2=NA,                            
       
       # === vertex label
       vertex.label=NA,                             
       vertex.label.family=&quot;Times&quot;,              
       vertex.label.font=2,                     
       vertex.label.cex=1,                           
       vertex.label.dist=0,                        
       vertex.label.degree=0 ,                      
       
       # === Edge
       edge.color=&quot;black&quot;,                           
       edge.width=1,                                
       edge.arrow.size=.4,                      
       edge.arrow.width=1,                         
       edge.lty=&quot;solid&quot;,                             
       edge.curved=0)
  
  # Add a legend
  legend(&quot;bottomleft&quot;, legend=c(&quot;ego&quot;, &quot;alter&quot;),
         col = vertex.attributes(G)$color, bty = &quot;n&quot;, pt.cex = 2.5, pch = c(15, 19), horiz = F, inset = c(0.15, 0.15)
  )
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-75-1.png" width="672" /></p>
</div>
<div id="e3-1" class="section level4">
<h4>E3</h4>
<pre class="r test"><code>df &lt;- egodata1.5[[3]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# actor attributes: shape and colour
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1)))
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;,&quot;#FFFFB3&quot;)

# plot
{
  plot(simplify(G),
       main = &quot;1.5 ego-centered network of directed STRAVA friendships&quot;,

       # === vertex
       vertex.frame.color =&quot;black&quot;,          
       vertex.size2=NA,                            
       
       # === vertex label
       vertex.label=NA,                             
       vertex.label.family=&quot;Times&quot;,              
       vertex.label.font=2,                     
       vertex.label.cex=1,                           
       vertex.label.dist=0,                        
       vertex.label.degree=0 ,                      
       
       # === Edge
       edge.color=&quot;black&quot;,                           
       edge.width=1,                                
       edge.arrow.size=.4,                      
       edge.arrow.width=1,                         
       edge.lty=&quot;solid&quot;,                             
       edge.curved=0)
  
  # Add a legend
  legend(&quot;bottomleft&quot;, legend=c(&quot;ego&quot;, &quot;alter&quot;),
         col = vertex.attributes(G)$color, bty = &quot;n&quot;, pt.cex = 2.5, pch = c(15, 19), horiz = F, inset = c(0.15, 0.15)
  )
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-76-1.png" width="672" /></p>
</div>
<div id="e5-1" class="section level4">
<h4>E5</h4>
<pre class="r test"><code>df &lt;- egodata1.5[[5]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# actor attributes: shape and colour
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1)))
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;,&quot;#FFFFB3&quot;)

# plot
{
  plot(simplify(G),
       main = &quot;1.5 ego-centered network of directed STRAVA friendships&quot;,

       # === vertex
       vertex.frame.color =&quot;black&quot;,          
       vertex.size2=NA,                            
       
       # === vertex label
       vertex.label=NA,                             
       vertex.label.family=&quot;Times&quot;,              
       vertex.label.font=2,                     
       vertex.label.cex=1,                           
       vertex.label.dist=0,                        
       vertex.label.degree=0 ,                      
       
       # === Edge
       edge.color=&quot;black&quot;,                           
       edge.width=1,                                
       edge.arrow.size=.4,                      
       edge.arrow.width=1,                         
       edge.lty=&quot;solid&quot;,                             
       edge.curved=0)
  
  # Add a legend
  legend(&quot;bottomleft&quot;, legend=c(&quot;ego&quot;, &quot;alter&quot;),
         col = vertex.attributes(G)$color, bty = &quot;n&quot;, pt.cex = 2.5, pch = c(15, 19), horiz = F, inset = c(0.15, 0.15)
  )
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-77-1.png" width="672" /></p>
</div>
<div id="e6-1" class="section level4">
<h4>E6</h4>
<pre class="r test"><code>df &lt;- egodata1.5[[6]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# actor attributes: shape and colour
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1)))
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;,&quot;#FFFFB3&quot;)

# plot
{
  plot(simplify(G),
       main = &quot;1.5 ego-centered network of directed STRAVA friendships&quot;,

       # === vertex
       vertex.frame.color =&quot;black&quot;,          
       vertex.size2=NA,                            
       
       # === vertex label
       vertex.label=NA,                             
       vertex.label.family=&quot;Times&quot;,              
       vertex.label.font=2,                     
       vertex.label.cex=1,                           
       vertex.label.dist=0,                        
       vertex.label.degree=0 ,                      
       
       # === Edge
       edge.color=&quot;black&quot;,                           
       edge.width=1,                                
       edge.arrow.size=.4,                      
       edge.arrow.width=1,                         
       edge.lty=&quot;solid&quot;,                             
       edge.curved=0)
  
  # Add a legend
  legend(&quot;bottomleft&quot;, legend=c(&quot;ego&quot;, &quot;alter&quot;),
         col = vertex.attributes(G)$color, bty = &quot;n&quot;, pt.cex = 2.5, pch = c(15, 19), horiz = F, inset = c(0.15, 0.15)
  )
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-78-1.png" width="672" /></p>
</div>
<div id="e8-1" class="section level4">
<h4>E8</h4>
<pre class="r test"><code>df &lt;- egodata1.5[[8]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# actor attributes: shape and colour
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1)))
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;,&quot;#FFFFB3&quot;)

# plot
{
  plot(simplify(G),
       main = &quot;1.5 ego-centered network of directed STRAVA friendships&quot;,

       # === vertex
       vertex.frame.color =&quot;black&quot;,          
       vertex.size2=NA,                            
       
       # === vertex label
       vertex.label=NA,                             
       vertex.label.family=&quot;Times&quot;,              
       vertex.label.font=2,                     
       vertex.label.cex=1,                           
       vertex.label.dist=0,                        
       vertex.label.degree=0 ,                      
       
       # === Edge
       edge.color=&quot;black&quot;,                           
       edge.width=1,                                
       edge.arrow.size=.4,                      
       edge.arrow.width=1,                         
       edge.lty=&quot;solid&quot;,                             
       edge.curved=0)
  
  # Add a legend
  legend(&quot;bottomleft&quot;, legend=c(&quot;ego&quot;, &quot;alter&quot;),
         col = vertex.attributes(G)$color, bty = &quot;n&quot;, pt.cex = 2.5, pch = c(15, 19), horiz = F, inset = c(0.15, 0.15)
  )
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-79-1.png" width="672" /></p>
</div>
<div id="e9-1" class="section level4">
<h4>E9</h4>
<pre class="r test"><code>df &lt;- egodata1.5[[9]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# actor attributes: shape and colour
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1)))
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;,&quot;#FFFFB3&quot;)

# plot
{
  plot(simplify(G),
       main = &quot;1.5 ego-centered network of directed STRAVA friendships&quot;,

       # === vertex
       vertex.frame.color =&quot;black&quot;,          
       vertex.size2=NA,                            
       
       # === vertex label
       vertex.label=NA,                             
       vertex.label.family=&quot;Times&quot;,              
       vertex.label.font=2,                     
       vertex.label.cex=1,                           
       vertex.label.dist=0,                        
       vertex.label.degree=0 ,                      
       
       # === Edge
       edge.color=&quot;black&quot;,                           
       edge.width=1,                                
       edge.arrow.size=.4,                      
       edge.arrow.width=1,                         
       edge.lty=&quot;solid&quot;,                             
       edge.curved=0)
  
  # Add a legend
  legend(&quot;bottomleft&quot;, legend=c(&quot;ego&quot;, &quot;alter&quot;),
         col = vertex.attributes(G)$color, bty = &quot;n&quot;, pt.cex = 2.5, pch = c(15, 19), horiz = F, inset = c(0.15, 0.15)
  )
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-80-1.png" width="672" /></p>
</div>
<div id="e10-1" class="section level4">
<h4>E10</h4>
<pre class="r test"><code>df &lt;- egodata1.5[[10]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# actor attributes: shape and colour
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1)))
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;,&quot;#FFFFB3&quot;)

# plot
{
  plot(simplify(G),
       main = &quot;1.5 ego-centered network of directed STRAVA friendships&quot;,

       # === vertex
       vertex.frame.color =&quot;black&quot;,          
       vertex.size2=NA,                            
       
       # === vertex label
       vertex.label=NA,                             
       vertex.label.family=&quot;Times&quot;,              
       vertex.label.font=2,                     
       vertex.label.cex=1,                           
       vertex.label.dist=0,                        
       vertex.label.degree=0 ,                      
       
       # === Edge
       edge.color=&quot;black&quot;,                           
       edge.width=1,                                
       edge.arrow.size=.4,                      
       edge.arrow.width=1,                         
       edge.lty=&quot;solid&quot;,                             
       edge.curved=0)
  
  # Add a legend
  legend(&quot;bottomleft&quot;, legend=c(&quot;ego&quot;, &quot;alter&quot;),
         col = vertex.attributes(G)$color, bty = &quot;n&quot;, pt.cex = 2.5, pch = c(15, 19), horiz = F, inset = c(0.15, 0.15)
  )
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-81-1.png" width="672" /></p>
</div>
<div id="e11-1" class="section level4">
<h4>E11</h4>
<pre class="r test"><code>df &lt;- egodata1.5[[11]] #grab egonet 
fnet &lt;- RSiena::coDyadCovar(data.matrix(df$friendship)) #take friendship matrix
G &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, diag = FALSE) #make an &#39;igraph object&#39;

# actor attributes: shape and colour
vertex_attr(G)$shape &lt;- c(&quot;square&quot;, rep(&quot;circle&quot;, (nrow(fnet) - 1)))
vertex_attr(G)$color &lt;- ifelse(vertex_attr(G)$name == vertex_attr(G)$name[1], &quot;#BEBADA&quot;,&quot;#FFFFB3&quot;)

# plot
{
  plot(simplify(G),
       main = &quot;1.5 ego-centered network of directed STRAVA friendships&quot;,

       # === vertex
       vertex.frame.color =&quot;black&quot;,          
       vertex.size2=NA,                            
       
       # === vertex label
       vertex.label=NA,                             
       vertex.label.family=&quot;Times&quot;,              
       vertex.label.font=2,                     
       vertex.label.cex=1,                           
       vertex.label.dist=0,                        
       vertex.label.degree=0 ,                      
       
       # === Edge
       edge.color=&quot;black&quot;,                           
       edge.width=1,                                
       edge.arrow.size=.4,                      
       edge.arrow.width=1,                         
       edge.lty=&quot;solid&quot;,                             
       edge.curved=0)
  
  # Add a legend
  legend(&quot;bottomleft&quot;, legend=c(&quot;ego&quot;, &quot;alter&quot;),
         col = vertex.attributes(G)$color, bty = &quot;n&quot;, pt.cex = 2.5, pch = c(15, 19), horiz = F, inset = c(0.15, 0.15)
  )
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-82-1.png" width="672" /></p>
</div>
</div>
<div id="section-20" class="section level3 unnumbered">
<h3></h3>
<!--- 

#RF: especially E3 and E5 seem appropriate for R-SIENA (high density)
--->
<hr />
<p><br></p>
</div>
</div>
<div id="print-report-1" class="section level2">
<h2>Print report</h2>
<div id="section-21" class="section level3 tabset tabset-fade">
<h3></h3>
<p>Let’s get some first descriptives of the egonets</p>
<pre class="r test"><code>df &lt;- egodata1.5_rsiena[[1]]  # grab club 
print01Report(df, modelname = &quot;files/ego1_1.5&quot;)

df &lt;- egodata1.5_rsiena[[2]]  # grab club 
print01Report(df, modelname = &quot;files/ego2_1.5&quot;)

df &lt;- egodata1.5_rsiena[[3]]  # grab club 
print01Report(df, modelname = &quot;files/ego3_1.5&quot;)

df &lt;- egodata1.5_rsiena[[4]]  # grab club 
print01Report(df, modelname = &quot;files/ego4_1.5&quot;)

df &lt;- egodata1.5_rsiena[[5]]  # grab club 
print01Report(df, modelname = &quot;files/ego5_1.5&quot;)

df &lt;- egodata1.5_rsiena[[6]]  # grab club 
print01Report(df, modelname = &quot;files/ego6_1.5&quot;)

df &lt;- egodata1.5_rsiena[[7]]  # grab club 
print01Report(df, modelname = &quot;files/ego7_1.5&quot;)

df &lt;- egodata1.5_rsiena[[8]]  # grab club 
print01Report(df, modelname = &quot;files/ego8_1.5&quot;)

df &lt;- egodata1.5_rsiena[[9]]  # grab club 
print01Report(df, modelname = &quot;files/ego9_1.5&quot;)

df &lt;- egodata1.5_rsiena[[10]]  # grab club 
print01Report(df, modelname = &quot;files/ego10_1.5&quot;)

df &lt;- egodata1.5_rsiena[[11]]  # grab club 
print01Report(df, modelname = &quot;files/ego11_1.5&quot;)</code></pre>
<p><br></p>
<div id="e1-2" class="section level4">
<h4>E1</h4>
<p><embed src="files/ego1_1.5.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
<div id="e2-2" class="section level4">
<h4>E2</h4>
<p><embed src="files/ego2_1.5.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
<div id="e3-2" class="section level4">
<h4>E3</h4>
<p><embed src="files/ego3_1.5.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
<div id="e4-1" class="section level4">
<h4>E4</h4>
<p><embed src="files/ego4_1.5.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
<div id="e5-2" class="section level4">
<h4>E5</h4>
<p><embed src="files/ego5_1.5.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
<div id="e6-2" class="section level4">
<h4>E6</h4>
<p><embed src="files/ego6_1.5.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
<div id="e7" class="section level4">
<h4>E7</h4>
<p><embed src="files/ego7_1.5.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
<div id="e8-2" class="section level4">
<h4>E8</h4>
<p><embed src="files/ego8_1.5.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
<div id="e9-2" class="section level4">
<h4>E9</h4>
<p><embed src="files/ego9_1.5.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
<div id="e10-2" class="section level4">
<h4>E10</h4>
<p><embed src="files/ego10_1.5.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
<div id="e11-2" class="section level4">
<h4>E11</h4>
<p><embed src="files/ego11_1.5.txt" id="id" class="class" style="width:100.0%" height="200" /></p>
</div>
</div>
<div id="section-22" class="section level3 unnumbered">
<h3></h3>
<hr />
</div>
<div id="references" class="section level3 unnumbered">
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-chen2013">
<p>Chen, Yanguang. 2013. “New Approaches for Calculating Moran’s Index of Spatial Autocorrelation.” <em>PLOS ONE</em> 8 (7): –. <a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0068336">https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0068336</a>.</p>
</div>
<div id="ref-davis1967structure">
<p>Davis, James A, and Samuel Leinhardt. 1967. “The Structure of Positive Interpersonal Relations in Small Groups.” <a href="https://eric.ed.gov/?id=ED024086">https://eric.ed.gov/?id=ED024086</a>.</p>
</div>
</div>
</div>
</div>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIkRlc2NyaXB0aXZlIHN0YXRpc3RpY3MiDQpkYXRlOiAiTGFzdCBjb21waWxlZCBvbiBgciBmb3JtYXQoU3lzLnRpbWUoKSwgJyVCLCAlWScpYCINCmJpYmxpb2dyYXBoeTogcmVmZXJlbmNlcy5iaWINCm91dHB1dDoNCiAgaHRtbF9kb2N1bWVudDoNCiAgICBjc3M6IHR3ZWFrcy5jc3MNCiAgICB0b2M6IHRydWUNCiAgICB0b2NfZmxvYXQ6IHRydWUNCiAgICBjb2xsYXBzZWQ6IGZhbHNlDQogICAgbnVtYmVyX3NlY3Rpb25zOiBmYWxzZQ0KICAgIHRvY19kZXB0aDogMg0KICAgIGNvZGVfZm9sZGluZzogc2hvdw0KICAgIGNvZGVfZG93bmxvYWQ6IHllcw0KLS0tDQoNCg0KYGBge3IsIGdsb2JhbHNldHRpbmdzLCBlY2hvPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQ0KbGlicmFyeShrbml0cikNCmtuaXRyOjpvcHRzX2NodW5rJHNldChlY2hvID0gVFJVRSkNCm9wdHNfY2h1bmskc2V0KHRpZHkub3B0cz1saXN0KHdpZHRoLmN1dG9mZj0xMDApLHRpZHk9VFJVRSwgd2FybmluZyA9IEZBTFNFLCBtZXNzYWdlID0gRkFMU0UsY29tbWVudCA9ICIjPiIsIGNhY2hlPVRSVUUsIGNsYXNzLnNvdXJjZT1jKCJ0ZXN0IiksIGNsYXNzLm91dHB1dD1jKCJ0ZXN0MiIpKQ0Kb3B0aW9ucyh3aWR0aCA9IDEwMCkNCnJnbDo6c2V0dXBLbml0cigpDQoNCg0KDQpjb2xvcml6ZSA8LSBmdW5jdGlvbih4LCBjb2xvcikge3NwcmludGYoIjxzcGFuIHN0eWxlPSdjb2xvcjogJXM7Jz4lczwvc3Bhbj4iLCBjb2xvciwgeCkgfQ0KDQpgYGANCg0KYGBge3Iga2xpcHB5LCBlY2hvPUZBTFNFLCBpbmNsdWRlPVRSVUV9DQprbGlwcHk6OmtsaXBweShwb3NpdGlvbiA9IGMoJ3RvcCcsICdyaWdodCcpKQ0KI2tsaXBweTo6a2xpcHB5KGNvbG9yID0gJ2RhcmtyZWQnKQ0KI2tsaXBweTo6a2xpcHB5KHRvb2x0aXBfbWVzc2FnZSA9ICdDbGljayB0byBjb3B5JywgdG9vbHRpcF9zdWNjZXNzID0gJ0RvbmUnKQ0KYGBgDQoNCg0KDQotLS0NCg0KV2Ugd2lsbCB1c2UgdGhlIFJTaWVuYSBvYmplY3QgdG8gZGVzY3JpYmUgdGhlIGZyaWVuZHNoaXAgYW5kIGt1ZG8gbmV0d29ya3MsIGNvbnN0YW50IGNvdmFyaWF0ZXMgYW5kIGJlaGF2aW9yYWwgdmFyaWFibGVzLiBXZSB3aWxsIGRvIHRoaXMgc2VwZXJhdGVseSBmb3IgdGhlIFtjbHVic10oI2NsdWJzKSBhbmQgW2Vnb3NdKCNlZ29zKS4NCg0KDQoNCjxicj4NCg0KIyBQcmVwYXJhdGlvbg0KDQpDbGVhbiB0aGUgd29ya2luZyBlbnZpcm9ubWVudCBhbmQgbG9hZCBpbiB0aGUgY2x1YiBhbmQgZWdvIGRhdGEuDQoNCg0KYGBge3IsIGF0dHIub3V0cHV0PSdzdHlsZT0ibWF4LWhlaWdodDogMjAwcHg7Iid9DQojIGNsZWFuIHRoZSB3b3JraW5nIGVudmlyb25tZW50IA0Kcm0gKGxpc3QgPSBscyggKSkNCg0KIyBsb2FkIHRoZSBvYmplY3QNCmxvYWQoImNsdWJkYXRhX3JzaWVuYS5SRGF0YSIpDQpsb2FkKCJjbHViZGF0YS5SRGF0YSIpDQpsb2FkKCJlZ29kYXRhMS41LlJEYXRhIikNCmxvYWQoImVnb2RhdGEyLjUuUkRhdGEiKQ0KYGBgDQoNCg0KV2UgaW5zdGFsbCBhbmQgbG9hZCB0aGUgcGFja2FnZXMgd2UgbmVlZCBsYXRlciBvbi4NCg0KYGBge3IgcGFja2FnZXN9DQojaW5zdGFsbCBpZiBuZWNlc3NhcnkgDQppZiAoIXJlcXVpcmUoIlJTaWVuYSIsIGNoYXJhY3Rlci5vbmx5ID0gVFJVRSkpIHtpbnN0YWxsLnBhY2thZ2VzKCJSU2llbmEiLCBkZXBlbmRlbmNpZXM9VFJVRSl9DQppZiAoIXJlcXVpcmUoImlncmFwaCIsIGNoYXJhY3Rlci5vbmx5ID0gVFJVRSkpIHtpbnN0YWxsLnBhY2thZ2VzKCJpZ3JhcGgiLCBkZXBlbmRlbmNpZXM9VFJVRSl9DQppZiAoIXJlcXVpcmUoInRpZHl2ZXJzZSIsIGNoYXJhY3Rlci5vbmx5ID0gVFJVRSkpIHtpbnN0YWxsLnBhY2thZ2VzKCJ0aWR5dmVyc2UiLCBkZXBlbmRlbmNpZXM9VFJVRSl9DQppZiAoIXJlcXVpcmUoInRpZHlyIiwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKSkge2luc3RhbGwucGFja2FnZXMoInRpZHlyIiwgZGVwZW5kZW5jaWVzPVRSVUUpfQ0KaWYgKCFyZXF1aXJlKCJtb21lbnRzIiwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKSkge2luc3RhbGwucGFja2FnZXMoIm1vbWVudHMiLCBkZXBlbmRlbmNpZXM9VFJVRSl9DQppZiAoIXJlcXVpcmUoImRwbHlyIiwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKSkge2luc3RhbGwucGFja2FnZXMoImRwbHlyIiwgZGVwZW5kZW5jaWVzPVRSVUUpfQ0KaWYgKCFyZXF1aXJlKCJnZ3Bsb3QyIiwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKSkge2luc3RhbGwucGFja2FnZXMoImdncGxvdDIiLCBkZXBlbmRlbmNpZXM9VFJVRSl9DQppZiAoIXJlcXVpcmUoImZvcmNhdHMiLCBjaGFyYWN0ZXIub25seSA9IFRSVUUpKSB7aW5zdGFsbC5wYWNrYWdlcygiZm9yY2F0cyIsIGRlcGVuZGVuY2llcz1UUlVFKX0NCmlmICghcmVxdWlyZSgia25pdHIiLCBjaGFyYWN0ZXIub25seSA9IFRSVUUpKSB7aW5zdGFsbC5wYWNrYWdlcygia25pdHIiLCBkZXBlbmRlbmNpZXM9VFJVRSl9DQppZiAoIXJlcXVpcmUoImthYmxlRXh0cmEiLCBjaGFyYWN0ZXIub25seSA9IFRSVUUpKSB7aW5zdGFsbC5wYWNrYWdlcygia2FibGVFeHRyYSIsIGRlcGVuZGVuY2llcz1UUlVFKX0NCmlmICghcmVxdWlyZSgibmV0d29yayIsIGNoYXJhY3Rlci5vbmx5ID0gVFJVRSkpIHtpbnN0YWxsLnBhY2thZ2VzKCJuZXR3b3JrIiwgZGVwZW5kZW5jaWVzPVRSVUUpfQ0KaWYgKCFyZXF1aXJlKCJzbmEiLCBjaGFyYWN0ZXIub25seSA9IFRSVUUpKSB7aW5zdGFsbC5wYWNrYWdlcygic25hIiwgZGVwZW5kZW5jaWVzPVRSVUUpfQ0KDQojbG9hZCBwYWNrYWdlcy4NCmxpYnJhcnkoUlNpZW5hKSAjUlNpZW5hIG1vZGVscywgc29tZSBkZXNjcmlwdGl2ZXMgb24gbmV0d29yayBsZXZlbA0KbGlicmFyeShpZ3JhcGgpICNEZXNjcmlwdGl2ZXM6IGR5YWQvdHJpYWQgY2Vuc3VzLCBkZWdyZWUNCmxpYnJhcnkodGlkeXZlcnNlKQ0KbGlicmFyeSh0aWR5cikgI2ZvciB0aWR5IGRhdGENCmxpYnJhcnkobW9tZW50cykgI2ZvciBjYWxjdWxhdGluZyBzdGF0aXN0aWNzIChlLmcuLCBrdXJ0b3Npcywgc3RhbmRhcmQgZXJyb3IpDQpsaWJyYXJ5KGRwbHlyKSAjZm9yIGRhdGEgbWFuaXB1bGF0aW9uDQpsaWJyYXJ5KGdncGxvdDIpICNmb3IgZGF0YSB2aXN1YWxpc2F0aW9uDQpsaWJyYXJ5KGZvcmNhdHMpICNmb3IgaGFuZGxpbmcgY2F0ZWdvcmljYWwgdmFyaWFibGVzDQpsaWJyYXJ5KGtuaXRyKSAjZm9yIGdlbmVyYXRpbmcgdGFibGVzDQpsaWJyYXJ5KGthYmxlRXh0cmEpICNmb3IgbWFuaXB1bGF0aW5nIHRhYmxlcw0KbGlicmFyeShuZXR3b3JrKSAjZm9yIG5ldHdvcmsgYW5hbHlzaXMNCmxpYnJhcnkoc25hKSAjZm9yIG5ldHdvcmsgYW5hbHlzaXMNCmBgYA0KDQoNCi0tLS0NCg0KTm93IGRlZmluZSBzb21lIGZ1bmN0aW9ucyB3ZSB1c2UgbGF0ZXIgb24gdG8gZGVzY3JpYmUgb3VyIGRhdGEgKHNlZSBbd3d3LmpvY2hlbXRvbHNtYS5ubF0oaHR0cHM6Ly93d3cuam9jaGVtdG9sc21hLm5sL2NvdXJzZXMvY29tcGxldGUtbmV0d29ya3Mvc29jaW82LyNkZXNjcmlwdGl2ZS1zdGF0aXN0aWNzKSkuICANCg0KLSBmZGVuc2l0eTogY2FsY3VsYXRlIGRlbnNpdHkgKGV4Y2x1ZGUgTkEgYW5kIHN0cnVjdHVyYWwgemVyb3MpICANCi0gZmRlbnNpdHlpbnRyYTogY2FsY3VsYXRlIGRlbnNpdHkgd2l0aGluIGdyb3VwIChleGNsdWRlIE5BIGFuZCBzdHJ1Y3R1cmFsIHplcm9zKSAgDQotIGZkZW5zaXR5aW50ZXI6IGNhbGN1bGF0ZSBkZW5zaXR5IGJldHdlZW4gZ3JvdXBzIChleGNsdWRlIE5BIGFuZCBzdHJ1Y3R1cmFsIHplcm9zKSAgDQotIGZob21vbWF0OiBiYXNlZCBvbiBlZ28vYWx0ZXIgY2hhcmFjdGVyaXN0aWNzLCBjb25zdHJ1Y3QgZHlhZCBjaGFyYWN0ZXJpc3RpYyB3aGV0aGVyIG9yIG5vdCBlZ28vYWx0ZXIgYXJlIHNhbWUgDQotIGZuZHlhZHM6IGNhbGN1bGF0ZSBhbGwgdmFsaWQgZHlhZHMgKG5vIE5BIG9yIHN0cnVjdHVyYWwgemVyb3MpICANCi0gZnNjb2xuZXQ6IGNhbGN1bGF0ZSBDb2xlbWFuJ3Mgc2VncmVnYXRpb24gaW5kZXggb24gdGhlIG5ldHdvcmstbGV2ZWwgIA0KLSBmTW9yYW4uaTogY2FsY3VsYXRlIE1vcmFuJ3MgSSBzcGF0aWFsIGF1dG9jb3JyZWxhdGlvbiBzdGF0aXN0aWMgKHNlZSBbaGVyZV0oaHR0cHM6Ly93d3cuam9jaGVtdG9sc21hLm5sL2NvdXJzZXMvY29tcGxldGUtbmV0d29ya3Mvc29jaW83LyNtb3JhbnMtYXV0b2NvcnJlbGF0aW9uLWZvci1vdXRnb2luZy10aWVzLXJzaWVuYS1idWlsZC1pbi1kYXRhc2V0KSkNCg0KDQoNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KIyBkZW5zaXR5OiBvYnNlcnZlZCByZWxhdGlvbnMgZGl2aWRlZCBieSBwb3NzaWJsZSByZWxhdGlvbnMNCmZkZW5zaXR5IDwtIGZ1bmN0aW9uKHgpIHsNCiAgICAjIHggaXMgeW91ciBub21pbmF0aW9uIG5ldHdvcmsgbWFrZSBzdXJlIGRpYWdvbmFsIGNlbGxzIGFyZSBOQQ0KICAgIGRpYWcoeCkgPC0gTkENCiAgICAjIHRha2UgY2FyZSBvZiBSU2llbmEgc3RydWN0dXJhbCB6ZXJvcywgc2V0IGFzIG1pc3NpbmcuDQogICAgeFt4ID09IDEwXSA8LSBOQQ0KICAgIHN1bSh4ID09IDEsIG5hLnJtID0gVCkvKHN1bSh4ID09IDEgfCB4ID09IDAsIG5hLnJtID0gVCkpDQp9DQoNCiMgY2FsY3VsYXRlIGludHJhZ3JvdXAgZGVuc2l0eQ0KZmRlbnNpdHlpbnRyYSA8LSBmdW5jdGlvbih4LCBBKSB7DQogICAgIyBBIGlzIG1hdHJpeCBpbmRpY2F0aW5nIHdoZXRoZXIgbm9kZXMgaW4gZHlhZCBoYXZlIHNhbWUgbm9kZSBhdHRyaWJ1dGVzDQogICAgZGlhZyh4KSA8LSBOQQ0KICAgIHhbeCA9PSAxMF0gPC0gTkENCiAgICBkaWFnKEEpIDwtIE5BDQogICAgc3VtKHggPT0gMSAmIEEgPT0gMSwgbmEucm0gPSBUKS8oc3VtKCh4ID09IDEgfCB4ID09IDApICYgQSA9PSAxLCBuYS5ybSA9IFQpKQ0KfQ0KDQojIGNhbGN1bGF0ZSBpbnRyYWdyb3VwIGRlbnNpdHkNCmZkZW5zaXR5aW50ZXIgPC0gZnVuY3Rpb24oeCwgQSkgew0KICAgICMgQSBpcyBtYXRyaXggaW5kaWNhdGluZyB3aGV0aGVyIG5vZGVzIGluIGR5YWQgaGF2ZSBzYW1lIG5vZGUgYXR0cmlidXRlcw0KICAgIGRpYWcoeCkgPC0gTkENCiAgICB4W3ggPT0gMTBdIDwtIE5BDQogICAgZGlhZyhBKSA8LSBOQQ0KICAgIHN1bSh4ID09IDEgJiBBICE9IDEsIG5hLnJtID0gVCkvKHN1bSgoeCA9PSAxIHwgeCA9PSAwKSAmIEEgIT0gMSwgbmEucm0gPSBUKSkNCn0NCg0KIyBjb25zdHJ1Y3QgZHlhZCBjaGFyYWN0ZXJpc3RpYyB3aGV0aGVyIG5vZGVzIGFyZSBzaW1pbGFyL2hvbW9nZW5vdXMNCmZob21vbWF0IDwtIGZ1bmN0aW9uKHgpIHsNCiAgICAjIHggaXMgYSB2ZWN0b3Igb2Ygbm9kZS1jb3ZhcmlhdGUNCiAgICB4bWF0IDwtIG1hdHJpeCh4LCBucm93ID0gbGVuZ3RoKHgpLCBuY29sID0gbGVuZ3RoKHgpKQ0KICAgIHhtYXR0IDwtIHQoeG1hdCkNCiAgICB4aG9tbyA8LSB4bWF0ID09IHhtYXR0DQogICAgcmV0dXJuKHhob21vKQ0KfQ0KDQojIGEgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGFsbCB2YWxpZCBkeWFkcy4NCmZuZHlhZHMgPC0gZnVuY3Rpb24oeCkgew0KICAgIGRpYWcoeCkgPC0gTkENCiAgICB4W3ggPT0gMTBdIDwtIE5BDQogICAgKHN1bSgoeCA9PSAxIHwgeCA9PSAwKSwgbmEucm0gPSBUKSkNCn0NCg0KIyBhIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBhbGwgdmFsaWQgaW50cmFncm91cGR5YWRzLg0KZm5keWFkczIgPC0gZnVuY3Rpb24oeCwgQSkgew0KICAgIGRpYWcoeCkgPC0gTkENCiAgICB4W3ggPT0gMTBdIDwtIE5BDQogICAgZGlhZyhBKSA8LSBOQQ0KICAgIChzdW0oKHggPT0gMSB8IHggPT0gMCkgJiBBID09IDEsIG5hLnJtID0gVCkpDQp9DQoNCg0KZnNjb2xuZXQgPC0gZnVuY3Rpb24obmV0d29yaywgY2NvdmFyKSB7DQogICAgIyBDYWxjdWxhdGUgY29sZW1hbiBvbiBuZXR3b3JrIGxldmVsOg0KICAgICMgaHR0cHM6Ly9yZWFkZXIuZWxzZXZpZXIuY29tL3JlYWRlci9zZC9waWkvUzAzNzg4NzMzMTQwMDAyMzk/dG9rZW49QTQyRjk5RkY2RTJCNzUwNDM2REQyQ0IwREI3QjFGNDFCREVDMTYwNTJBNDU2ODNDMDI2NDREQUY4ODIxNUEzMzc5NjM2QjJBQTE5N0I2NTk0MUQ2MzczRTlFMkVFNDEzDQogICAgDQogICAgZmhvbW9tYXQgPC0gZnVuY3Rpb24oeCkgew0KICAgICAgICB4bWF0IDwtIG1hdHJpeCh4LCBucm93ID0gbGVuZ3RoKHgpLCBuY29sID0gbGVuZ3RoKHgpKQ0KICAgICAgICB4bWF0dCA8LSB0KHhtYXQpDQogICAgICAgIHhob21vIDwtIHhtYXQgPT0geG1hdHQNCiAgICAgICAgcmV0dXJuKHhob21vKQ0KICAgIH0NCiAgICANCiAgICBmc3VtaW50cmEgPC0gZnVuY3Rpb24oeCwgQSkgew0KICAgICAgICAjIEEgaXMgbWF0cml4IGluZGljYXRpbmcgd2hldGhlciBub2RlcyBjb25zdGl0dXRpbmcgZHlhZCBoYXZlIHNhbWUgY2hhcmFjdGVyaXN0aWNzDQogICAgICAgIGRpYWcoeCkgPC0gTkENCiAgICAgICAgeFt4ID09IDEwXSA8LSBOQQ0KICAgICAgICBkaWFnKEEpIDwtIE5BDQogICAgICAgIHN1bSh4ID09IDEgJiBBID09IDEsIG5hLnJtID0gVCkNCiAgICB9DQogICAgDQogICAgIyBleHBlY2F0aW9uIHcqPXN1bV9nIHN1bV9pIChuaSgobmctMSkvKE4tMSkpKQ0KICAgIG5ldHdvcmtbbmV0d29yayA9PSAxMF0gPC0gTkENCiAgICBuaSA8LSByb3dTdW1zKG5ldHdvcmssIG5hLnJtID0gVCkNCiAgICBuZyA8LSBOQQ0KICAgIGZvciAoaSBpbiAxOmxlbmd0aChjY292YXIpKSB7DQogICAgICAgIG5nW2ldIDwtIHRhYmxlKGNjb3Zhcilbcm93bmFtZXModGFibGUoY2NvdmFyKSkgPT0gY2NvdmFyW2ldXQ0KICAgIH0NCiAgICBOIDwtIGxlbmd0aChjY292YXIpDQogICAgd2V4cCA8LSBzdW0obmkgKiAoKG5nIC0gMSkvKE4gLSAxKSksIG5hLnJtID0gVCkNCiAgICANCiAgICAjIHdnZzEgaG93IG1hbnkgaW50cmFncm91cCB0aWVzDQogICAgdyA8LSBmc3VtaW50cmEobmV0d29yaywgZmhvbW9tYXQoY2NvdmFyKSkNCiAgICANCiAgICBTY29sX25ldCA8LSBpZmVsc2UodyA+PSB3ZXhwLCAodyAtIHdleHApLyhzdW0obmksIG5hLnJtID0gVCkgLSB3ZXhwKSwgKHcgLSB3ZXhwKS93ZXhwKQ0KICAgIHJldHVybihTY29sX25ldCkNCn0NCg0KZk1vcmFuLkkgPC0gZnVuY3Rpb24oeCwgd2VpZ2h0LCBzY2FsZWQgPSBGQUxTRSwgbmEucm0gPSBGQUxTRSwgYWx0ZXJuYXRpdmUgPSAidHdvLnNpZGVkIiwgcm93c3RhbmRhcmRpemUgPSBUUlVFKSB7DQogICAgaWYgKHJvd3N0YW5kYXJkaXplKSB7DQogICAgICAgIGlmIChkaW0od2VpZ2h0KVsxXSAhPSBkaW0od2VpZ2h0KVsyXSkgDQogICAgICAgICAgICBzdG9wKCInd2VpZ2h0JyBtdXN0IGJlIGEgc3F1YXJlIG1hdHJpeCIpDQogICAgICAgIG4gPC0gbGVuZ3RoKHgpDQogICAgICAgIGlmIChkaW0od2VpZ2h0KVsxXSAhPSBuKSANCiAgICAgICAgICAgIHN0b3AoIid3ZWlnaHQnIG11c3QgaGF2ZSBhcyBtYW55IHJvd3MgYXMgb2JzZXJ2YXRpb25zIGluICd4JyIpDQogICAgICAgIGVpIDwtIC0xLyhuIC0gMSkNCiAgICAgICAgbmFzIDwtIGlzLm5hKHgpDQogICAgICAgIGlmIChhbnkobmFzKSkgew0KICAgICAgICAgICAgaWYgKG5hLnJtKSB7DQogICAgICAgICAgICAgICAgeCA8LSB4WyFuYXNdDQogICAgICAgICAgICAgICAgbiA8LSBsZW5ndGgoeCkNCiAgICAgICAgICAgICAgICB3ZWlnaHQgPC0gd2VpZ2h0WyFuYXMsICFuYXNdDQogICAgICAgICAgICB9IGVsc2Ugew0KICAgICAgICAgICAgICAgIHdhcm5pbmcoIid4JyBoYXMgbWlzc2luZyB2YWx1ZXM6IG1heWJlIHlvdSB3YW50ZWQgdG8gc2V0IG5hLnJtID0gVFJVRT8iKQ0KICAgICAgICAgICAgICAgIHJldHVybihsaXN0KG9ic2VydmVkID0gTkEsIGV4cGVjdGVkID0gZWksIHNkID0gTkEsIHAudmFsdWUgPSBOQSkpDQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgUk9XU1VNIDwtIHJvd1N1bXMod2VpZ2h0KQ0KICAgICAgICBST1dTVU1bUk9XU1VNID09IDBdIDwtIDENCiAgICAgICAgd2VpZ2h0IDwtIHdlaWdodC9ST1dTVU0NCiAgICAgICAgcyA8LSBzdW0od2VpZ2h0KQ0KICAgICAgICBtIDwtIG1lYW4oeCkNCiAgICAgICAgeSA8LSB4IC0gbQ0KICAgICAgICBjdiA8LSBzdW0od2VpZ2h0ICogeSAlbyUgeSkNCiAgICAgICAgdiA8LSBzdW0oeV4yKQ0KICAgICAgICBvYnMgPC0gKG4vcykgKiAoY3YvdikNCiAgICAgICAgaWYgKHNjYWxlZCkgew0KICAgICAgICAgICAgaS5tYXggPC0gKG4vcykgKiAoc2Qocm93U3Vtcyh3ZWlnaHQpICogeSkvc3FydCh2LyhuIC0gMSkpKQ0KICAgICAgICAgICAgb2JzIDwtIG9icy9pLm1heA0KICAgICAgICB9DQogICAgICAgIFMxIDwtIDAuNSAqIHN1bSgod2VpZ2h0ICsgdCh3ZWlnaHQpKV4yKQ0KICAgICAgICBTMiA8LSBzdW0oKGFwcGx5KHdlaWdodCwgMSwgc3VtKSArIGFwcGx5KHdlaWdodCwgMiwgc3VtKSleMikNCiAgICAgICAgcy5zcSA8LSBzXjINCiAgICAgICAgayA8LSAoc3VtKHleNCkvbikvKHYvbileMg0KICAgICAgICBzZGkgPC0gc3FydCgobiAqICgobl4yIC0gMyAqIG4gKyAzKSAqIFMxIC0gbiAqIFMyICsgMyAqIHMuc3EpIC0gayAqIChuICogKG4gLSAxKSAqIFMxIC0gMiAqIG4gKiANCiAgICAgICAgICAgIFMyICsgNiAqIHMuc3EpKS8oKG4gLSAxKSAqIChuIC0gMikgKiAobiAtIDMpICogcy5zcSkgLSAxLygobiAtIDEpXjIpKQ0KICAgICAgICBhbHRlcm5hdGl2ZSA8LSBtYXRjaC5hcmcoYWx0ZXJuYXRpdmUsIGMoInR3by5zaWRlZCIsICJsZXNzIiwgImdyZWF0ZXIiKSkNCiAgICAgICAgcHYgPC0gcG5vcm0ob2JzLCBtZWFuID0gZWksIHNkID0gc2RpKQ0KICAgICAgICBpZiAoYWx0ZXJuYXRpdmUgPT0gInR3by5zaWRlZCIpIA0KICAgICAgICAgICAgcHYgPC0gaWYgKG9icyA8PSBlaSkgDQogICAgICAgICAgICAgICAgMiAqIHB2IGVsc2UgMiAqICgxIC0gcHYpDQogICAgICAgIGlmIChhbHRlcm5hdGl2ZSA9PSAiZ3JlYXRlciIpIA0KICAgICAgICAgICAgcHYgPC0gMSAtIHB2DQogICAgICAgIGxpc3Qob2JzZXJ2ZWQgPSBvYnMsIGV4cGVjdGVkID0gZWksIHNkID0gc2RpLCBwLnZhbHVlID0gcHYpDQogICAgfSBlbHNlIHsNCiAgICAgICAgaWYgKGRpbSh3ZWlnaHQpWzFdICE9IGRpbSh3ZWlnaHQpWzJdKSANCiAgICAgICAgICAgIHN0b3AoIid3ZWlnaHQnIG11c3QgYmUgYSBzcXVhcmUgbWF0cml4IikNCiAgICAgICAgbiA8LSBsZW5ndGgoeCkNCiAgICAgICAgaWYgKGRpbSh3ZWlnaHQpWzFdICE9IG4pIA0KICAgICAgICAgICAgc3RvcCgiJ3dlaWdodCcgbXVzdCBoYXZlIGFzIG1hbnkgcm93cyBhcyBvYnNlcnZhdGlvbnMgaW4gJ3gnIikNCiAgICAgICAgZWkgPC0gLTEvKG4gLSAxKQ0KICAgICAgICBuYXMgPC0gaXMubmEoeCkNCiAgICAgICAgaWYgKGFueShuYXMpKSB7DQogICAgICAgICAgICBpZiAobmEucm0pIHsNCiAgICAgICAgICAgICAgICB4IDwtIHhbIW5hc10NCiAgICAgICAgICAgICAgICBuIDwtIGxlbmd0aCh4KQ0KICAgICAgICAgICAgICAgIHdlaWdodCA8LSB3ZWlnaHRbIW5hcywgIW5hc10NCiAgICAgICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgICAgICAgd2FybmluZygiJ3gnIGhhcyBtaXNzaW5nIHZhbHVlczogbWF5YmUgeW91IHdhbnRlZCB0byBzZXQgbmEucm0gPSBUUlVFPyIpDQogICAgICAgICAgICAgICAgcmV0dXJuKGxpc3Qob2JzZXJ2ZWQgPSBOQSwgZXhwZWN0ZWQgPSBlaSwgc2QgPSBOQSwgcC52YWx1ZSA9IE5BKSkNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAjIFJPV1NVTSA8LSByb3dTdW1zKHdlaWdodCkgUk9XU1VNW1JPV1NVTSA9PSAwXSA8LSAxIHdlaWdodCA8LSB3ZWlnaHQvUk9XU1VNDQogICAgICAgIHMgPC0gc3VtKHdlaWdodCkNCiAgICAgICAgbSA8LSBtZWFuKHgpDQogICAgICAgIHkgPC0geCAtIG0NCiAgICAgICAgY3YgPC0gc3VtKHdlaWdodCAqIHkgJW8lIHkpDQogICAgICAgIHYgPC0gc3VtKHleMikNCiAgICAgICAgb2JzIDwtIChuL3MpICogKGN2L3YpDQogICAgICAgIGlmIChzY2FsZWQpIHsNCiAgICAgICAgICAgIGkubWF4IDwtIChuL3MpICogKHNkKHJvd1N1bXMod2VpZ2h0KSAqIHkpL3NxcnQodi8obiAtIDEpKSkNCiAgICAgICAgICAgIG9icyA8LSBvYnMvaS5tYXgNCiAgICAgICAgfQ0KICAgICAgICBTMSA8LSAwLjUgKiBzdW0oKHdlaWdodCArIHQod2VpZ2h0KSleMikNCiAgICAgICAgUzIgPC0gc3VtKChhcHBseSh3ZWlnaHQsIDEsIHN1bSkgKyBhcHBseSh3ZWlnaHQsIDIsIHN1bSkpXjIpDQogICAgICAgIHMuc3EgPC0gc14yDQogICAgICAgIGsgPC0gKHN1bSh5XjQpL24pLyh2L24pXjINCiAgICAgICAgc2RpIDwtIHNxcnQoKG4gKiAoKG5eMiAtIDMgKiBuICsgMykgKiBTMSAtIG4gKiBTMiArIDMgKiBzLnNxKSAtIGsgKiAobiAqIChuIC0gMSkgKiBTMSAtIDIgKiBuICogDQogICAgICAgICAgICBTMiArIDYgKiBzLnNxKSkvKChuIC0gMSkgKiAobiAtIDIpICogKG4gLSAzKSAqIHMuc3EpIC0gMS8oKG4gLSAxKV4yKSkNCiAgICAgICAgYWx0ZXJuYXRpdmUgPC0gbWF0Y2guYXJnKGFsdGVybmF0aXZlLCBjKCJ0d28uc2lkZWQiLCAibGVzcyIsICJncmVhdGVyIikpDQogICAgICAgIHB2IDwtIHBub3JtKG9icywgbWVhbiA9IGVpLCBzZCA9IHNkaSkNCiAgICAgICAgaWYgKGFsdGVybmF0aXZlID09ICJ0d28uc2lkZWQiKSANCiAgICAgICAgICAgIHB2IDwtIGlmIChvYnMgPD0gZWkpIA0KICAgICAgICAgICAgICAgIDIgKiBwdiBlbHNlIDIgKiAoMSAtIHB2KQ0KICAgICAgICBpZiAoYWx0ZXJuYXRpdmUgPT0gImdyZWF0ZXIiKSANCiAgICAgICAgICAgIHB2IDwtIDEgLSBwdg0KICAgICAgICBsaXN0KG9ic2VydmVkID0gb2JzLCBleHBlY3RlZCA9IGVpLCBzZCA9IHNkaSwgcC52YWx1ZSA9IHB2KQ0KICAgIH0NCiAgICANCiAgICANCn0NCmBgYA0KDQotLS0tDQoNCiMgQ2x1YnMgeyNjbHVic30NCg0KDQpXZSBjb3ZlciB0aGUgZm9sbG93aW5nOg0KDQoqIGNsdWIgY2hhcmFjdGVyaXN0aWNzDQoqIG5ldHdvcmsgc3RydWN0dXJlIGluIEZyaWVuZHNoaXAgYW5kIEt1ZG8gbmV0d29ya3MNCiogZ2VuZGVyIGNvbXBvc2l0aW9uIC8gc2VncmVnYXRpb24NCiogYmVoYXZpb3I6IGFjdGl2aXR5IGxldmVsIChmcmVxdWVuY3kgYW5kIHZvbHVtZSkNCiogc3BhdGlhbCBuZXR3b3JrIGF1dG9jb3JyZWxhdGlvbjogYmVoYXZpb3JhbCBzaW1pbGFyaXR5IGluIG5ldHdvcmtzDQoNCi0tLS0NCg0KPGJyPg0KDQojIyBQcmludCByZXBvcnQNCiMjIyB7LnRhYnNldCAudGFic2V0LWZhZGV9IA0KTWFrZSBzdXJlIHRvIGNoZWNrIHRoZSBvdXRwdXQgb2YgdGhlICdwcmludDAxUmVwb3J0KCknIGZ1bmN0aW9uIGZvciBnZW5lcmFsIGRhdGEgZGVzY3JpcHRvbiAoZGVncmVlcywgbmV0d29yayBzaXplLCBldGMuKSBhbmQgYSBnZW5lcmFsIG92ZXJ2aWV3IG9mIHRoZSBkYXRhc2V0LiBPdXRwdXQgaXMgcHJpbnRlZCBpbiBhIC50eHQgZmlsZSBpbiB0aGUgZGlyZWN0b3J5IHNwZWNpZmllZC4NCg0KDQojIyMjIENsdWIgMQ0KYGBge3IgZXZhbD0gRn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYVtbMV1dICMgZ3JhYiBjbHViIA0KcHJpbnQwMVJlcG9ydChkZiwgbW9kZWxuYW1lPSJmaWxlcy9jbHViMSIpDQpgYGANCg0KIVtdKGZpbGVzL2NsdWIxLnR4dCl7I2lkIC5jbGFzcyB3aWR0aD0xMDAlIGhlaWdodD0yMDBweH0NCg0KIyMjIyBDbHViIDINCmBgYHtyIGV2YWw9IEZ9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFbWzJdXSAjIGdyYWIgY2x1YiANCnByaW50MDFSZXBvcnQoZGYsIG1vZGVsbmFtZT0iZmlsZXMvY2x1YjIiKQ0KYGBgDQoNCiFbXShmaWxlcy9jbHViMi50eHQpeyNpZCAuY2xhc3Mgd2lkdGg9MTAwJSBoZWlnaHQ9MjAwcHh9DQoNCiMjIyMgQ2x1YiAzDQpgYGB7ciBldmFsPSBGfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1szXV0gIyBncmFiIGNsdWIgDQpwcmludDAxUmVwb3J0KGRmLCBtb2RlbG5hbWU9ImZpbGVzL2NsdWIzIikNCmBgYA0KDQohW10oZmlsZXMvY2x1YjMudHh0KXsjaWQgLmNsYXNzIHdpZHRoPTEwMCUgaGVpZ2h0PTIwMHB4fQ0KDQojIyMjIENsdWIgNA0KYGBge3IgZXZhbD0gRn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYVtbNF1dICMgZ3JhYiBjbHViIA0KcHJpbnQwMVJlcG9ydChkZiwgbW9kZWxuYW1lPSJmaWxlcy9jbHViNCIpDQpgYGANCg0KIVtdKGZpbGVzL2NsdWI0LnR4dCl7I2lkIC5jbGFzcyB3aWR0aD0xMDAlIGhlaWdodD0yMDBweH0NCg0KIyMjIyBDbHViIDUNCmBgYHtyIGV2YWw9IEZ9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFbWzVdXSAjIGdyYWIgY2x1YiANCnByaW50MDFSZXBvcnQoZGYsIG1vZGVsbmFtZT0iZmlsZXMvY2x1YjUiKQ0KYGBgDQoNCiFbXShmaWxlcy9jbHViNS50eHQpeyNpZCAuY2xhc3Mgd2lkdGg9MTAwJSBoZWlnaHQ9MjAwcHh9DQoNCiMjIyB7LX0NCg0KLS0tLQ0KDQojIyBDbHViIGNoYXJhY3RlcmlzdGljcw0KDQpTb21lIGNsdWIgY2hhcmFjdGVyaXN0aWNzLiBXZSBzaG93IHRoZSBzaXplIG9mIHRoZSBuZXR3b3JrICh0aGUgbnVtYmVyIG9mIGFjdG9ycykgZm9yIGVhY2ggY2x1YiBhbmQgdGhlIG51bWJlciBvZiBhY3RpdmUgbWVtYmVycyBjdXJyZW50bHkgKDE4LTEtMjAyMSkgb24gU3RyYXZhLCBieSBhZGRpbmcgdG8gKnd3dy5zdHJhdmEuY29tL2NsdWJzLy4uLiogdGhlIG9yaWdpbmFsIGNsdWIgaWQuIA0KDQpgYGB7cn0NCm5ldHNpemUgPC0gYyggDQogIGxlbmd0aChjbHViZGF0YV9yc2llbmFbWzFdXSRub2RlU2V0cyRBY3RvcnMpLCANCiAgbGVuZ3RoKGNsdWJkYXRhX3JzaWVuYVtbMl1dJG5vZGVTZXRzJEFjdG9ycyksIA0KICBsZW5ndGgoY2x1YmRhdGFfcnNpZW5hW1szXV0kbm9kZVNldHMkQWN0b3JzKSwgDQogIGxlbmd0aChjbHViZGF0YV9yc2llbmFbWzRdXSRub2RlU2V0cyRBY3RvcnMpLCANCiAgbGVuZ3RoKGNsdWJkYXRhX3JzaWVuYVtbNV1dJG5vZGVTZXRzJEFjdG9ycykpICMgYXR0cmlldmUgZnJvbSB0aGUgY2x1YmRhdGEgdGhlIG51bWJlciBvZiBhY3RvcnMgaW4gZWFjaCBuZXR3b3JrDQoNCmNsdWJzaXplIDwtIGMoNjYsIDEyNywgMzczLCAxNSwgMTY5KSAjIGZpbmQgdGhlIG51bWJlciBvZiBtZW1iZXJzIGN1cnJlbnRseSBvbiBTdHJhdmENCg0KZGYgPC0gZGF0YS5mcmFtZSggbmV0c2l6ZSA9IG5ldHNpemUsIGNsdWJzaXplID0gY2x1YnNpemUgKQ0KDQpwcmludChkZikNCmBgYA0KDQo8YnI+DQoNCi0tLS0NCg0KIyMgRnJpZW5kc2hpcCBuZXR3b3JrDQoNCldlIGRlc2NyaWJlIHRoZSBmcmllbmRzaGlwIG5ldHdvcmsuIE5vdGUgdGhhdCB0aGUgZnJpZW5kc2hpcCBuZXR3b3JrIGlzIGEgY29uc3RhbnQgZHlhZGljIGNvdmFyaWF0ZS4NCg0KIyMjIDEuIE5vZGUtbGV2ZWwgey50YWJzZXQgLnRhYnNldC1mYWRlfQ0KDQpMZXQncyBkZXNjcmliZSB0aGUgZnJpZW5kc2hpcC1pbmRlZ3JlZXMgYW5kIC1vdXRkZWdyZWVzIG9mIHRoZSBTdHJhdmEtdXNlcnMgaW4gZWFjaCBjbHViLiBXZSB0YWtlIGZyb20gdGhlIFJTaWVuYSBvYmplY3QgdGhlIGZyaWVuZHNoaXAgbmV0d29yayBvZiB0aGUgY2x1YiBpbiBxdWVzdGlvbiwgYW5kIHR1cm4gaXQgaW50byBhbiAqaWdyYXBoKiBvYmplY3QuIFRoZW4gd2UgZmluZCB0aGUgaW4tIGFuZCBvdXRkZWdyZWUgb2YgZWFjaCBub2RlLg0KDQojIyMjIENsdWIgMQ0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFbWzFdXSAjIGdyYWIgY2x1YiANCmZuZXQgPC0gZGYkZHljQ292YXJzJGZyaWVuZHNoaXAgIyB0YWtlIGZyaWVuZHNoaXAgbmV0d29yaw0KDQojIG1ha2UgYSAnZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoZm5ldCwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBmaW5kIGluLSBhbmQgb3V0ZGVncmVlIGZvciBlYWNoIG5vZGUNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9Im91dCIpLCB4bGFiPSJvdXRkZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2Ygb3V0ZGVncmVlIFN0cmF2YSBmcmllbmRzaGlwIG5ldHdvcmsiKQ0KaGlzdChpZ3JhcGg6OmRlZ3JlZShHMSwgbW9kZT0iaW4iKSwgeGxhYj0iaW5kZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2YgaW5kZWdyZWUgU3RyYXZhIGZyaWVuZHNoaXAgbmV0d29yayIpDQpgYGANCg0KIyMjIyBDbHViIDINCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1syXV0gIyBncmFiIGNsdWIgDQpmbmV0IDwtIGRmJGR5Y0NvdmFycyRmcmllbmRzaGlwICMgdGFrZSBmcmllbmRzaGlwIG5ldHdvcmsNCg0KIyBtYWtlIGEgJ2dyYXBoIG9iamVjdCcNCkcxIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGZuZXQsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgZmluZCBpbi0gYW5kIG91dGRlZ3JlZSBmb3IgZWFjaCBub2RlDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJvdXQiKSwgeGxhYj0ib3V0ZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIG91dGRlZ3JlZSBTdHJhdmEgZnJpZW5kc2hpcCBuZXR3b3JrIikNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9ImluIiksIHhsYWI9ImluZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIGluZGVncmVlIFN0cmF2YSBmcmllbmRzaGlwIG5ldHdvcmsiKQ0KYGBgDQoNCiMjIyMgQ2x1YiAzDQpgYGB7cn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYVtbM11dICMgZ3JhYiBjbHViIA0KZm5ldCA8LSBkZiRkeWNDb3ZhcnMkZnJpZW5kc2hpcCAjIHRha2UgZnJpZW5kc2hpcCBuZXR3b3JrDQoNCiMgbWFrZSBhICdncmFwaCBvYmplY3QnDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChmbmV0LCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGZpbmQgaW4tIGFuZCBvdXRkZWdyZWUgZm9yIGVhY2ggbm9kZQ0KaGlzdChpZ3JhcGg6OmRlZ3JlZShHMSwgbW9kZT0ib3V0IiksIHhsYWI9Im91dGRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBvdXRkZWdyZWUgU3RyYXZhIGZyaWVuZHNoaXAgbmV0d29yayIpDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJpbiIpLCB4bGFiPSJpbmRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBpbmRlZ3JlZSBTdHJhdmEgZnJpZW5kc2hpcCBuZXR3b3JrIikNCmBgYA0KDQojIyMjIENsdWIgNA0KYGBge3IgfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1s0XV0gIyBncmFiIGNsdWIgDQpmbmV0IDwtIGRmJGR5Y0NvdmFycyRmcmllbmRzaGlwICMgdGFrZSBmcmllbmRzaGlwIG5ldHdvcmsNCg0KIyBtYWtlIGEgJ2dyYXBoIG9iamVjdCcNCkcxIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGZuZXQsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgZmluZCBpbi0gYW5kIG91dGRlZ3JlZSBmb3IgZWFjaCBub2RlDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJvdXQiKSwgeGxhYj0ib3V0ZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIG91dGRlZ3JlZSBTdHJhdmEgZnJpZW5kc2hpcCBuZXR3b3JrIikNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9ImluIiksIHhsYWI9ImluZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIGluZGVncmVlIFN0cmF2YSBmcmllbmRzaGlwIG5ldHdvcmsiKQ0KYGBgDQoNCiMjIyMgQ2x1YiA1DQpgYGB7cn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYVtbNV1dICMgZ3JhYiBjbHViIA0KZm5ldCA8LSBkZiRkeWNDb3ZhcnMkZnJpZW5kc2hpcCAjIHRha2UgZnJpZW5kc2hpcCBuZXR3b3JrDQoNCiMgbWFrZSBhICdncmFwaCBvYmplY3QnDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChmbmV0LCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGZpbmQgaW4tIGFuZCBvdXRkZWdyZWUgZm9yIGVhY2ggbm9kZQ0KaGlzdChpZ3JhcGg6OmRlZ3JlZShHMSwgbW9kZT0ib3V0IiksIHhsYWI9Im91dGRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBvdXRkZWdyZWUgU3RyYXZhIGZyaWVuZHNoaXAgbmV0d29yayIpDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJpbiIpLCB4bGFiPSJpbmRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBpbmRlZ3JlZSBTdHJhdmEgZnJpZW5kc2hpcCBuZXR3b3JrIikNCmBgYA0KDQojIyMgey19DQoNCkluIGdlbmVyYWwsIHdlIHNlZSB0aGF0IHRoZSBpbi0gYW5kIG91dGRlZ3JlZSBkaXN0cmlidXRpb24gaXMgcmlnaHQtc2tld2VkLCBzdWdnZXN0aW5nIHRoYXQgbW9zdCBTdHJhdmEtdXNlcnMgYmVmcmllbmQgYW5kIGFyZSBiZWZyaWVuZGVkIGJ5IHJlbGF0aXZlbHkgZmV3IGNsdWItbWVtYmVycywgd2hpbGUgZmV3ZXIgdXNlcnMgYmVmcmllbmQgYW5kIGFyZSBiZWZyaWVuZGVkIGJ5IG1hbnkgY2x1Yi1tZW1iZXJzLg0KDQo8YnI+DQoNCiMjIyAyLiBEeWFkLWxldmVsIHsudGFic2V0IC50YWJzZXQtZmFkZX0NCg0KTGV0J3MgaW52ZXN0aWdhdGUgdG8gd2hhdCBleHRlbnQgZnJpZW5kc2hpcC1yZWxhdGlvbnNoaXBzIChkeWFkcykgYXJlIHJlY2lwcm9jYXRlZCBvciBtdXR1YWwuIFRoZXJlIGFyZSB0aHJlZSB0eXBlcyBvZiBkeWFkOiBtdXR1YWwsIGFzc3ltZXRyaWMsIGFuZCBub24tZXhpc3RlbnQuIFdlIHdpbGwgY2xhc3NpZnkgZHlhZHMgd2l0aCB0aGUgZHlhZC1jZW5zdXMgZnVuY3Rpb24sIGFuZCB3ZSB3aWxsIGludmVzdGlnYXRlIGlmIHdlIG9ic2VydmUgbW9yZSBtdXR1YWwgZHlhZHMgdGhhbiB3ZSB3b3VsZCBleHBlY3QgYmFzZWQgb24gY2hhbmNlLg0KDQojIyMjIENsdWIgMQ0KYGBge3IgfQ0KIyBtYWtlIGlncmFwaCBvYmplY3QgZm9yIHRoZSBjbHViDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChjbHViZGF0YV9yc2llbmFbWzFdXSRkeWNDb3ZhcnMkZnJpZW5kc2hpcCwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBjbGFzc2lmeSBkeWFkcw0KZHlhZGNvdW50IDwtIGlncmFwaDo6ZHlhZC5jZW5zdXMoRzEpDQoNCiMgYWRkIHRoZSB0b3RhbCBudW1iZXIgb2YgZHlhZHMgdG8gdGhlIGdyYXBoDQpkeWFkY291bnQkdG90YWwgPC0gKHZjb3VudChHMSkqKHZjb3VudChHMSktMSkpLzINCmR5YWRjb3VudA0KDQojIGNvbXBhcmUgdmFsdWVzIHdpdGggYSByYW5kb20gZ3JhcGggb2YgdGhlIHNhbWUgc2l6ZSB3aXRoIHRoZSBzYW1lIGRlbnNpdHkNCmRlbnMgPC0gaWdyYXBoOjpncmFwaC5kZW5zaXR5KEcxKQ0Kc2l6ZSA8LSBpZ3JhcGg6OnZjb3VudChHMSkNCnRyaWFsIDwtIDEwMDANCnJlY2lwIDwtIHJlcChOQSwgdHJpYWwpDQoNCmZvciAoIGkgaW4gMTp0cmlhbCApew0KICByYW5kb21fZ3JhcGggPC0gaWdyYXBoOjplcmRvcy5yZW55aS5nYW1lKG4gPSBzaXplLCBwLm9yLm0gPSBkZW5zLCBkaXJlY3RlZCA9IFRSVUUpDQogIHJlY2lwW2ldIDwtIGlncmFwaDo6ZHlhZC5jZW5zdXMocmFuZG9tX2dyYXBoKSRtdXQNCn0NCg0Ke2hpc3QocmVjaXAsIG1haW49Im51bWJlciBvZiBtdXR1YWwgZHlhZHMgaW4gcmFuZG9tIGdyYXBoIiwgeGxhYj0iIiwgKQ0KYWJsaW5lKHY9ZHlhZGNvdW50JG11dCwgY29sPSJyZWQiLCBsd2Q9Myl9DQpgYGANCg0KIyMjIyBDbHViIDINCmBgYHtyIH0NCiMgbWFrZSBpZ3JhcGggb2JqZWN0IGZvciB0aGUgY2x1Yg0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoY2x1YmRhdGFfcnNpZW5hW1syXV0kZHljQ292YXJzJGZyaWVuZHNoaXAsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgZHlhZHMNCmR5YWRjb3VudCA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKEcxKQ0KDQojIGFkZCB0aGUgdG90YWwgbnVtYmVyIG9mIGRheWRzIHRvIHRoZSBncmFwaA0KZHlhZGNvdW50JHRvdGFsIDwtICh2Y291bnQoRzEpKih2Y291bnQoRzEpLTEpKS8yDQpkeWFkY291bnQNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKHJhbmRvbV9ncmFwaCkkbXV0DQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJudW1iZXIgb2YgbXV0dWFsIGR5YWRzIGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIsICkNCmFibGluZSh2PWR5YWRjb3VudCRtdXQsIGNvbD0icmVkIiwgbHdkPTMpfQ0KYGBgDQoNCiMjIyMgQ2x1YiAzDQpgYGB7cn0NCiMgbWFrZSBpZ3JhcGggb2JqZWN0IGZvciB0aGUgY2x1Yg0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoY2x1YmRhdGFfcnNpZW5hW1szXV0kZHljQ292YXJzJGZyaWVuZHNoaXAsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgZHlhZHMNCmR5YWRjb3VudCA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKEcxKQ0KDQojIGFkZCB0aGUgdG90YWwgbnVtYmVyIG9mIGRheWRzIHRvIHRoZSBncmFwaA0KZHlhZGNvdW50JHRvdGFsIDwtICh2Y291bnQoRzEpKih2Y291bnQoRzEpLTEpKS8yDQpkeWFkY291bnQNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKHJhbmRvbV9ncmFwaCkkbXV0DQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJudW1iZXIgb2YgbXV0dWFsIGR5YWRzIGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIsICkNCmFibGluZSh2PWR5YWRjb3VudCRtdXQsIGNvbD0icmVkIiwgbHdkPTMpfQ0KYGBgDQoNCiMjIyMgQ2x1YiA0DQpgYGB7ciB9DQojIG1ha2UgaWdyYXBoIG9iamVjdCBmb3IgdGhlIGNsdWINCkcxIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGNsdWJkYXRhX3JzaWVuYVtbNF1dJGR5Y0NvdmFycyRmcmllbmRzaGlwLCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGNsYXNzaWZ5IGR5YWRzDQpkeWFkY291bnQgPC0gaWdyYXBoOjpkeWFkLmNlbnN1cyhHMSkNCg0KIyBhZGQgdGhlIHRvdGFsIG51bWJlciBvZiBkYXlkcyB0byB0aGUgZ3JhcGgNCmR5YWRjb3VudCR0b3RhbCA8LSAodmNvdW50KEcxKSoodmNvdW50KEcxKS0xKSkvMg0KZHlhZGNvdW50DQoNCiMgY29tcGFyZSB2YWx1ZXMgd2l0aCBhIHJhbmRvbSBncmFwaCBvZiB0aGUgc2FtZSBzaXplIHdpdGggdGhlIHNhbWUgZGVuc2l0eQ0KZGVucyA8LSBpZ3JhcGg6OmdyYXBoLmRlbnNpdHkoRzEpDQpzaXplIDwtIGlncmFwaDo6dmNvdW50KEcxKQ0KdHJpYWwgPC0gMTAwMA0KcmVjaXAgPC0gcmVwKE5BLCB0cmlhbCkNCg0KZm9yICggaSBpbiAxOnRyaWFsICl7DQogIHJhbmRvbV9ncmFwaCA8LSBpZ3JhcGg6OmVyZG9zLnJlbnlpLmdhbWUobiA9IHNpemUsIHAub3IubSA9IGRlbnMsIGRpcmVjdGVkID0gVFJVRSkNCiAgcmVjaXBbaV0gPC0gaWdyYXBoOjpkeWFkLmNlbnN1cyhyYW5kb21fZ3JhcGgpJG11dA0KfQ0KDQp7aGlzdChyZWNpcCwgbWFpbj0ibnVtYmVyIG9mIG11dHVhbCBkeWFkcyBpbiByYW5kb20gZ3JhcGgiLCB4bGFiPSIiLCApDQphYmxpbmUodj1keWFkY291bnQkbXV0LCBjb2w9InJlZCIsIGx3ZD0zKX0NCmBgYA0KDQojIyMjIENsdWIgNQ0KYGBge3J9DQojIG1ha2UgaWdyYXBoIG9iamVjdCBmb3IgdGhlIGNsdWINCkcxIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGNsdWJkYXRhX3JzaWVuYVtbNV1dJGR5Y0NvdmFycyRmcmllbmRzaGlwLCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGNsYXNzaWZ5IGR5YWRzDQpkeWFkY291bnQgPC0gaWdyYXBoOjpkeWFkLmNlbnN1cyhHMSkNCg0KIyBhZGQgdGhlIHRvdGFsIG51bWJlciBvZiBkYXlkcyB0byB0aGUgZ3JhcGgNCmR5YWRjb3VudCR0b3RhbCA8LSAodmNvdW50KEcxKSoodmNvdW50KEcxKS0xKSkvMg0KZHlhZGNvdW50DQoNCiMgY29tcGFyZSB2YWx1ZXMgd2l0aCBhIHJhbmRvbSBncmFwaCBvZiB0aGUgc2FtZSBzaXplIHdpdGggdGhlIHNhbWUgZGVuc2l0eQ0KZGVucyA8LSBpZ3JhcGg6OmdyYXBoLmRlbnNpdHkoRzEpDQpzaXplIDwtIGlncmFwaDo6dmNvdW50KEcxKQ0KdHJpYWwgPC0gMTAwMA0KcmVjaXAgPC0gcmVwKE5BLCB0cmlhbCkNCg0KZm9yICggaSBpbiAxOnRyaWFsICl7DQogIHJhbmRvbV9ncmFwaCA8LSBpZ3JhcGg6OmVyZG9zLnJlbnlpLmdhbWUobiA9IHNpemUsIHAub3IubSA9IGRlbnMsIGRpcmVjdGVkID0gVFJVRSkNCiAgcmVjaXBbaV0gPC0gaWdyYXBoOjpkeWFkLmNlbnN1cyhyYW5kb21fZ3JhcGgpJG11dA0KfQ0KDQp7aGlzdChyZWNpcCwgbWFpbj0ibnVtYmVyIG9mIG11dHVhbCBkeWFkcyBpbiByYW5kb20gZ3JhcGgiLCB4bGFiPSIiLCApDQphYmxpbmUodj1keWFkY291bnQkbXV0LCBjb2w9InJlZCIsIGx3ZD0zKX0NCmBgYA0KDQojIyMgey19DQoNCkFzIGV4cGVjdGVkLCBtdXR1YWwgZHlhZHMgYXJlIHdheSBtb3JlIHByb21pbmVudCB0aGFuIHdvdWxkIGJlIGV4cGVjdGVkIGJhc2VkIG9uIGNoYW5jZSwgd2hpY2ggaXMgaW5kaWNhdGl2ZSBvZiByZWNpcHJvY2l0eSBlZmZlY3RzIGluIFN0cmF2YS1mcmllbmRzaGlwcyBhbW9uZyB0aGUgbWVtYmVycyBvZiBjbHVicy4gICANCg0KPGJyPg0KDQojIyMgMy4gVHJpYWQtbGV2ZWwgey50YWJzZXQgLnRhYnNldC1mYWRlfQ0KDQpUaGVyZSBhcmUgMTYgdHlwZXMgb2YgdHJpYWRzOyBzZWUgQGRhdmlzMTk2N3N0cnVjdHVyZS4gVGhleSBjYW4gYmUgY2xhc3NpZmllZCB3aXRoIHRoZSB0cmlhZC1jZW5zdXMgZnVuY3Rpb24uIFNlZSBbaGVyZV0oaHR0cHM6Ly9pZ3JhcGgub3JnL3IvZG9jL3RyaWFkX2NlbnN1cy5odG1sKSBmb3IgdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBtdWx0aXBsZSB0cmlhZCBjbGFzc2lmaWNhdGlvbnMgYXJlIGNvdW50ZWQuDQoNCkxldCdzIGFsc28gY2FsY3VsYXRlIGZvciBlYWNoIGNsdWIgdGhlIChnbG9iYWwpIHRyYW5zaXRpdml0eSBpbmRleCwgd2hpY2ggaXMgdGhlIHJhdGlvIG9mIGNvbm5lY3RlZCB0cmlwbGV0cyAodHJhbnNpdGl2ZSB0cmlhZHMpIGFuZCBwb3RlbnRpYWxseSBjb25uZWN0ZWQgdHJpcGxldHMgKHNlZSBbaGVyZV0oaHR0cDovL3d3dy5zdGF0cy5veC5hYy51ay9+c25pamRlcnMvVHJhbnNfVHJpYWRzX2hhLnBkZikpLiBUaGUgZGlyZWN0aW9uIG9mIHRoZSBlZGdlcyBpcyBpZ25vcmVkLiBXZSB3aWxsIHRoZW4gY2FsY3VsYXRlIHRoZSBnbG9iYWwgdHJhbnNpdGl2aXR5IGluZGV4IGZvciByYW5kb20gKHVuZGlyZWN0ZWQpIGdyYXBocy4NCg0KIyMjIyBDbHViIDENCmBgYHtyfQ0KIyBtYWtlIGlncmFwaCBvYmplY3QgZm9yIHRoZSBjbHViDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChjbHViZGF0YV9yc2llbmFbWzFdXSRkeWNDb3ZhcnMkZnJpZW5kc2hpcCwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBjbGFzc2lmeSB0cmlhZHMNCnRyaWFkY291bnQgPC0gaWdyYXBoOjp0cmlhZC5jZW5zdXMoRzEpDQoNCiMgYW5kIHByaW50IHRoZSAxNiBjb25maWd1cmF0aW9ucw0KcHJpbnQodHJpYWRjb3VudCkNCg0KIyBnbG9iYWwgKG9yIHVuZGlyZWN0ZWQpIHRyYW5zaXRpdml0eSBpbmRleA0KaWdyYXBoOjp0cmFuc2l0aXZpdHkoRzEpDQoNCiMgY29tcGFyZSB2YWx1ZXMgd2l0aCBhIHJhbmRvbSBncmFwaCBvZiB0aGUgc2FtZSBzaXplIHdpdGggdGhlIHNhbWUgZGVuc2l0eQ0KZGVucyA8LSBpZ3JhcGg6OmdyYXBoLmRlbnNpdHkoRzEpDQpzaXplIDwtIGlncmFwaDo6dmNvdW50KEcxKQ0KdHJpYWwgPC0gMTAwMA0KcmVjaXAgPC0gcmVwKE5BLCB0cmlhbCkNCg0KZm9yICggaSBpbiAxOnRyaWFsICl7DQogIHJhbmRvbV9ncmFwaCA8LSBpZ3JhcGg6OmVyZG9zLnJlbnlpLmdhbWUobiA9IHNpemUsIHAub3IubSA9IGRlbnMsIGRpcmVjdGVkID0gVFJVRSkNCiAgcmVjaXBbaV0gPC0gdHJhbnNpdGl2aXR5KHJhbmRvbV9ncmFwaCkNCn0NCg0Ke2hpc3QocmVjaXAsIG1haW49Imdsb2JhbCB0cmFuc2l0aXZpdHkgaW5kZXggaW4gcmFuZG9tIGdyYXBoIiwgeGxhYj0iIiApDQphYmxpbmUodj10cmFuc2l0aXZpdHkoRzEpLCBjb2w9InJlZCIsIGx3ZD0zKX0NCg0KYGBgDQoNCiMjIyMgQ2x1YiAyDQpgYGB7ciB9DQojIG1ha2UgaWdyYXBoIG9iamVjdCBmb3IgdGhlIGNsdWINCkcxIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGNsdWJkYXRhX3JzaWVuYVtbMl1dJGR5Y0NvdmFycyRmcmllbmRzaGlwLCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGNsYXNzaWZ5IHRyaWFkcw0KdHJpYWRjb3VudCA8LSBpZ3JhcGg6OnRyaWFkLmNlbnN1cyhHMSkNCg0KIyBhbmQgcHJpbnQgdGhlIDE2IGNvbmZpZ3VyYXRpb25zDQpwcmludCh0cmlhZGNvdW50KQ0KDQojIGdsb2JhbCAob3IgdW5kaXJlY3RlZCkgdHJhbnNpdGl2aXR5IGluZGV4DQppZ3JhcGg6OnRyYW5zaXRpdml0eShHMSkNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSB0cmFuc2l0aXZpdHkocmFuZG9tX2dyYXBoKQ0KfQ0KDQp7aGlzdChyZWNpcCwgbWFpbj0iZ2xvYmFsIHRyYW5zaXRpdml0eSBpbmRleCBpbiByYW5kb20gZ3JhcGgiLCB4bGFiPSIiICkNCmFibGluZSh2PXRyYW5zaXRpdml0eShHMSksIGNvbD0icmVkIiwgbHdkPTMpfQ0KDQpgYGANCg0KIyMjIyBDbHViIDMNCmBgYHtyfQ0KIyBtYWtlIGlncmFwaCBvYmplY3QgZm9yIHRoZSBjbHViDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChjbHViZGF0YV9yc2llbmFbWzNdXSRkeWNDb3ZhcnMkZnJpZW5kc2hpcCwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBjbGFzc2lmeSB0cmlhZHMNCnRyaWFkY291bnQgPC0gaWdyYXBoOjp0cmlhZC5jZW5zdXMoRzEpDQoNCiMgYW5kIHByaW50IHRoZSAxNiBjb25maWd1cmF0aW9ucw0KcHJpbnQodHJpYWRjb3VudCkNCg0KIyBnbG9iYWwgKG9yIHVuZGlyZWN0ZWQpIHRyYW5zaXRpdml0eSBpbmRleA0KaWdyYXBoOjp0cmFuc2l0aXZpdHkoRzEpDQoNCiMgY29tcGFyZSB2YWx1ZXMgd2l0aCBhIHJhbmRvbSBncmFwaCBvZiB0aGUgc2FtZSBzaXplIHdpdGggdGhlIHNhbWUgZGVuc2l0eQ0KZGVucyA8LSBpZ3JhcGg6OmdyYXBoLmRlbnNpdHkoRzEpDQpzaXplIDwtIGlncmFwaDo6dmNvdW50KEcxKQ0KdHJpYWwgPC0gMTAwMA0KcmVjaXAgPC0gcmVwKE5BLCB0cmlhbCkNCg0KZm9yICggaSBpbiAxOnRyaWFsICl7DQogIHJhbmRvbV9ncmFwaCA8LSBpZ3JhcGg6OmVyZG9zLnJlbnlpLmdhbWUobiA9IHNpemUsIHAub3IubSA9IGRlbnMsIGRpcmVjdGVkID0gVFJVRSkNCiAgcmVjaXBbaV0gPC0gdHJhbnNpdGl2aXR5KHJhbmRvbV9ncmFwaCkNCn0NCg0Ke2hpc3QocmVjaXAsIG1haW49Imdsb2JhbCB0cmFuc2l0aXZpdHkgaW5kZXggaW4gcmFuZG9tIGdyYXBoIiwgeGxhYj0iIiApDQphYmxpbmUodj10cmFuc2l0aXZpdHkoRzEpLCBjb2w9InJlZCIsIGx3ZD0zKX0NCg0KYGBgDQoNCiMjIyMgQ2x1YiA0DQpgYGB7cn0NCiMgbWFrZSBpZ3JhcGggb2JqZWN0IGZvciB0aGUgY2x1Yg0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoY2x1YmRhdGFfcnNpZW5hW1s0XV0kZHljQ292YXJzJGZyaWVuZHNoaXAsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgdHJpYWRzDQp0cmlhZGNvdW50IDwtIGlncmFwaDo6dHJpYWQuY2Vuc3VzKEcxKQ0KDQojIGFuZCBwcmludCB0aGUgMTYgY29uZmlndXJhdGlvbnMNCnByaW50KHRyaWFkY291bnQpDQoNCiMgZ2xvYmFsIChvciB1bmRpcmVjdGVkKSB0cmFuc2l0aXZpdHkgaW5kZXgNCmlncmFwaDo6dHJhbnNpdGl2aXR5KEcxKQ0KDQojIGNvbXBhcmUgdmFsdWVzIHdpdGggYSByYW5kb20gZ3JhcGggb2YgdGhlIHNhbWUgc2l6ZSB3aXRoIHRoZSBzYW1lIGRlbnNpdHkNCmRlbnMgPC0gaWdyYXBoOjpncmFwaC5kZW5zaXR5KEcxKQ0Kc2l6ZSA8LSBpZ3JhcGg6OnZjb3VudChHMSkNCnRyaWFsIDwtIDEwMDANCnJlY2lwIDwtIHJlcChOQSwgdHJpYWwpDQoNCmZvciAoIGkgaW4gMTp0cmlhbCApew0KICByYW5kb21fZ3JhcGggPC0gaWdyYXBoOjplcmRvcy5yZW55aS5nYW1lKG4gPSBzaXplLCBwLm9yLm0gPSBkZW5zLCBkaXJlY3RlZCA9IFRSVUUpDQogIHJlY2lwW2ldIDwtIHRyYW5zaXRpdml0eShyYW5kb21fZ3JhcGgpDQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJnbG9iYWwgdHJhbnNpdGl2aXR5IGluZGV4IGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIgKQ0KYWJsaW5lKHY9dHJhbnNpdGl2aXR5KEcxKSwgY29sPSJyZWQiLCBsd2Q9Myl9DQoNCmBgYA0KDQojIyMjIENsdWIgNQ0KYGBge3J9DQojIG1ha2UgaWdyYXBoIG9iamVjdCBmb3IgdGhlIGNsdWINCkcxIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGNsdWJkYXRhX3JzaWVuYVtbNV1dJGR5Y0NvdmFycyRmcmllbmRzaGlwLCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGNsYXNzaWZ5IHRyaWFkcw0KdHJpYWRjb3VudCA8LSBpZ3JhcGg6OnRyaWFkLmNlbnN1cyhHMSkNCg0KIyBhbmQgcHJpbnQgdGhlIDE2IGNvbmZpZ3VyYXRpb25zDQpwcmludCh0cmlhZGNvdW50KQ0KDQojIGdsb2JhbCAob3IgdW5kaXJlY3RlZCkgdHJhbnNpdGl2aXR5IGluZGV4DQppZ3JhcGg6OnRyYW5zaXRpdml0eShHMSkNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSB0cmFuc2l0aXZpdHkocmFuZG9tX2dyYXBoKQ0KfQ0KDQpoaXN0KHJlY2lwLCBtYWluPSJnbG9iYWwgdHJhbnNpdGl2aXR5IGluZGV4IGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIgKQ0KDQpgYGANCg0KIyMjIHstfQ0KQWxzbyB0cmFuc2l0aXZpdHkgaXMgbW9yZSBwcm9taW5lbnQgdGhhbiB3b3VsZCBiZSBleHBlY3RlZCBzb2xlbHkgYmFzZWQgb24gY2hhbmNlLiANCg0KDQotLS0tDQoNCg0KIyMgS3VkbyBuZXR3b3JrDQoNCk5vdyBsZXQncyBkZXNjcmliZSB0aGUgS3VkbyBuZXR3b3JrLCB3aGljaCB3ZSB2aWV3IGFzIGEgZGVwZW5kZW50IGJlaGF2aW9yYWwgdmFyaWFibGUuIA0KDQojIyMgMS4gTm9kZS1sZXZlbCB7LnRhYnNldCAudGFic2V0LWZhZGV9DQoNClN0YXJ0aW5nLCBhZ2Fpbiwgd2l0aCBpbmRlZ3JlZXMgYW5kIG91dGRlZ3JlZXM6IHdobyByZWNlaXZlcyBhbmQgZ2l2ZXMgS3Vkb3M/IFdlIHRha2UgZnJvbSB0aGUgUlNpZW5hIG9iamVjdCB0aGUgS3VkbyBuZXR3b3JrIGZvciBlYWNoIGNsdWIsIHN1YnNldCB0aGUgZmlyc3Qgd2F2ZSwgYW5kIHR1cm4gaXQgaW50byBhbiAqaWdyYXBoKiBvYmplY3QuIA0KDQojIyMjIENsdWIgMQ0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFbWzFdXSAjIGdyYWIgY2x1YiANCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIG1ha2UgYW4gJ2lncmFwaCBvYmplY3QnDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChrbmV0MSwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBmaW5kIGluLSBhbmQgb3V0ZGVncmVlIGZvciBlYWNoIG5vZGUNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9Im91dCIpLCB4bGFiPSJvdXRkZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2YgS3VkbyBvdXRkZWdyZWUiKQ0KDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJpbiIpLCB4bGFiPSJpbmRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBLdWRvIGluZGVncmVlIikNCmBgYA0KDQojIyMjIENsdWIgMg0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFbWzJdXSAjIGdyYWIgY2x1YiANCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIG1ha2UgYW4gJ2lncmFwaCBvYmplY3QnDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChrbmV0MSwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBmaW5kIGluLSBhbmQgb3V0ZGVncmVlIGZvciBlYWNoIG5vZGUNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9Im91dCIpLCB4bGFiPSJvdXRkZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2YgS3VkbyBvdXRkZWdyZWUiKQ0KDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJpbiIpLCB4bGFiPSJpbmRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBLdWRvIGluZGVncmVlIikNCmBgYA0KDQojIyMjIENsdWIgMw0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFbWzNdXSAjIGdyYWIgY2x1YiANCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIG1ha2UgYW4gJ2lncmFwaCBvYmplY3QnDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChrbmV0MSwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBmaW5kIGluLSBhbmQgb3V0ZGVncmVlIGZvciBlYWNoIG5vZGUNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9Im91dCIpLCB4bGFiPSJvdXRkZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2YgS3VkbyBvdXRkZWdyZWUiKQ0KDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJpbiIpLCB4bGFiPSJpbmRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBLdWRvIGluZGVncmVlIikNCmBgYA0KDQojIyMjIENsdWIgNA0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFbWzRdXSAjIGdyYWIgY2x1YiANCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIG1ha2UgYW4gJ2lncmFwaCBvYmplY3QnDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChrbmV0MSwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBmaW5kIGluLSBhbmQgb3V0ZGVncmVlIGZvciBlYWNoIG5vZGUNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9Im91dCIpLCB4bGFiPSJvdXRkZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2YgS3VkbyBvdXRkZWdyZWUiKQ0KDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJpbiIpLCB4bGFiPSJpbmRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBLdWRvIGluZGVncmVlIikNCmBgYA0KDQojIyMjIENsdWIgNQ0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFbWzVdXSAjIGdyYWIgY2x1YiANCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIG1ha2UgYW4gJ2lncmFwaCBvYmplY3QnDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChrbmV0MSwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBmaW5kIGluLSBhbmQgb3V0ZGVncmVlIGZvciBlYWNoIG5vZGUNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9Im91dCIpLCB4bGFiPSJvdXRkZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2YgS3VkbyBvdXRkZWdyZWUiKQ0KDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJpbiIpLCB4bGFiPSJpbmRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBLdWRvIGluZGVncmVlIikNCmBgYA0KDQojIyMgey19DQoNCldlIGNhbiBvYnNlcnZlIHRoZSBzYW1lIFBhcmV0by1saWtlLXBhdGVybjogc29tZSBnaXZlL3JlY2VpdmUgbW9zdCBvZiB0aGUgS3Vkb3MgZ2l2ZW4sIHdoaWxlIG1vc3QgZ2l2ZS9yZWNlaXZlIGZldy4NCg0KPGJyPg0KDQojIyMgMi4gRHlhZC1sZXZlbCB7LnRhYnNldCAudGFic2V0LWZhZGV9DQoNCkF0IHRoZSBkeWFkLWxldmVsOiBsZXQncyBzZWUgdG8gd2hhdCBleHRlbnQgS3Vkb3MgdGVuZCB0byBiZSByZWNpcHJvY2F0ZWQgYmV0d2VlbiBhY3RvcnMuDQoNCiMjIyMgQ2x1YiAxDQpgYGB7ciB9DQojIG1ha2UgaWdyYXBoIG9iamVjdCBmb3IgdGhlIGNsdWIsIGF0IHdhdmUgMQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1sxXV0gIyBncmFiIGNsdWIgDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgZHlhZHMNCmR5YWRjb3VudCA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKEcxKQ0KDQojIGFkZCB0aGUgdG90YWwgbnVtYmVyIG9mIGR5YWRzIHRvIHRoZSBncmFwaA0KZHlhZGNvdW50JHRvdGFsIDwtICh2Y291bnQoRzEpKih2Y291bnQoRzEpLTEpKS8yDQpkeWFkY291bnQNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKHJhbmRvbV9ncmFwaCkkbXV0DQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJudW1iZXIgb2YgcmVjaXByb2NhdGVkIEt1ZG9zIGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIsICkNCmFibGluZSh2PWR5YWRjb3VudCRtdXQsIGNvbD0icmVkIiwgbHdkPTMpfQ0KYGBgDQoNCiMjIyMgQ2x1YiAyDQpgYGB7ciB9DQojIG1ha2UgaWdyYXBoIG9iamVjdCBmb3IgdGhlIGNsdWIsIGF0IHdhdmUgMQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1syXV0gIyBncmFiIGNsdWIgDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgZHlhZHMNCmR5YWRjb3VudCA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKEcxKQ0KDQojIGFkZCB0aGUgdG90YWwgbnVtYmVyIG9mIGR5YWRzIHRvIHRoZSBncmFwaA0KZHlhZGNvdW50JHRvdGFsIDwtICh2Y291bnQoRzEpKih2Y291bnQoRzEpLTEpKS8yDQpkeWFkY291bnQNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKHJhbmRvbV9ncmFwaCkkbXV0DQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJudW1iZXIgb2YgcmVjaXByb2NhdGVkIEt1ZG9zIGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIsICkNCmFibGluZSh2PWR5YWRjb3VudCRtdXQsIGNvbD0icmVkIiwgbHdkPTMpfQ0KYGBgDQoNCiMjIyMgQ2x1YiAzDQpgYGB7ciB9DQojIG1ha2UgaWdyYXBoIG9iamVjdCBmb3IgdGhlIGNsdWIsIGF0IHdhdmUgMQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1szXV0gIyBncmFiIGNsdWIgDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgZHlhZHMNCmR5YWRjb3VudCA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKEcxKQ0KDQojIGFkZCB0aGUgdG90YWwgbnVtYmVyIG9mIGR5YWRzIHRvIHRoZSBncmFwaA0KZHlhZGNvdW50JHRvdGFsIDwtICh2Y291bnQoRzEpKih2Y291bnQoRzEpLTEpKS8yDQpkeWFkY291bnQNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKHJhbmRvbV9ncmFwaCkkbXV0DQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJudW1iZXIgb2YgcmVjaXByb2NhdGVkIEt1ZG9zIGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIsICkNCmFibGluZSh2PWR5YWRjb3VudCRtdXQsIGNvbD0icmVkIiwgbHdkPTMpfQ0KYGBgDQoNCiMjIyMgQ2x1YiA0DQpgYGB7ciB9DQojIG1ha2UgaWdyYXBoIG9iamVjdCBmb3IgdGhlIGNsdWIsIGF0IHdhdmUgMQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1s0XV0gIyBncmFiIGNsdWIgDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgZHlhZHMNCmR5YWRjb3VudCA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKEcxKQ0KDQojIGFkZCB0aGUgdG90YWwgbnVtYmVyIG9mIGR5YWRzIHRvIHRoZSBncmFwaA0KZHlhZGNvdW50JHRvdGFsIDwtICh2Y291bnQoRzEpKih2Y291bnQoRzEpLTEpKS8yDQpkeWFkY291bnQNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKHJhbmRvbV9ncmFwaCkkbXV0DQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJudW1iZXIgb2YgcmVjaXByb2NhdGVkIEt1ZG9zIGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIsICkNCmFibGluZSh2PWR5YWRjb3VudCRtdXQsIGNvbD0icmVkIiwgbHdkPTMpfQ0KYGBgDQoNCiMjIyMgQ2x1YiA1DQpgYGB7ciB9DQojIG1ha2UgaWdyYXBoIG9iamVjdCBmb3IgdGhlIGNsdWIsIGF0IHdhdmUgMQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1s1XV0gIyBncmFiIGNsdWIgDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgZHlhZHMNCmR5YWRjb3VudCA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKEcxKQ0KDQojIGFkZCB0aGUgdG90YWwgbnVtYmVyIG9mIGR5YWRzIHRvIHRoZSBncmFwaA0KZHlhZGNvdW50JHRvdGFsIDwtICh2Y291bnQoRzEpKih2Y291bnQoRzEpLTEpKS8yDQpkeWFkY291bnQNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKHJhbmRvbV9ncmFwaCkkbXV0DQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJudW1iZXIgb2YgcmVjaXByb2NhdGVkIEt1ZG9zIGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIsICkNCmFibGluZSh2PWR5YWRjb3VudCRtdXQsIGNvbD0icmVkIiwgbHdkPTMpfQ0KYGBgDQoNCiMjIyB7LX0NCg0KQ29uY2x1c2lvbjogS3Vkb3MgdGVuZCB0byBiZSByZWNpcHJvY2F0ZWQsIGxpa2UgZnJpZW5kc2hpcHMhDQoNCi0tLS0NCg0KDQo8YnI+DQoNCiMjIEdlbmRlciBjb21wb3NpdGlvbiANCg0KIyMjIHsudGFic2V0IC50YWJzZXQtZmFkZX0NCg0KTGV0J3MgaW52ZXN0aWdhdGUgdGhlIGdlbmRlciBjb21wb3NpdGlvbiBvZiB0aGUgY2x1Yi4NCldlIG11c3QgcmV0cmlldmUgZ2VuZGVyIGZyb20gdGhlIG9iamVjdCAobm90ZSB0aGF0IHdlIHVzZSB0aGUgY2x1YmRhdGEgb2JqZWN0LCBub3QgdGhlIHJzaWVuYSBvYmplY3QpLiBUaGVuIHdlIG1ha2UgYSBjYXRlZ29yaWNhbCBnZW5kZXIgdmFyaWFibGUgYW5kIHBsb3QgaXQuDQoNCiMjIyMgQ2x1YiAxDQpgYGB7ciBjbGFzcy5zb3VyY2UgPSAnZm9sZC1oaWRlJ30NCmRmIDwtIGNsdWJkYXRhW1sxXV0gIyBncmFiIGNsdWIgDQoNCiMgcmV0cmlldmUgbm9kZS1hdHRyaWJ1dGUgZ2VuZGVyIGZyb20gb2JqZWN0DQptYWxlIDwtIGRmJG1hbGUNCmZlbWFsZSA8LSBkZiRmZW1hbGUNCm90aGVyIDwtIGRmJG90aGVyDQoNCiMgYXMgZmFjdG9yDQpnZW5kZXIgPC0gTkENCmdlbmRlciA8LSBpZmVsc2UobWFsZSA9PSAxLCAiTWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoZmVtYWxlID09IDEsICJGZW1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKG90aGVyID09IDEsICJPdGhlciIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoaXMubmEoZ2VuZGVyKSwgIk1pc3NpbmciLCBnZW5kZXIpICMgbWlzc2luZyBjYXRlZ29yeQ0KDQojIG1ha2UgZGF0YWZyYW1lDQpkZiA8LSBkYXRhLmZyYW1lKA0KICBnZW5kZXIgPSBhcy5mYWN0b3IoYygiTWFsZSIsICJGZW1hbGUiLCAiT3RoZXIiLCAiTWlzc2luZyIpKSwNCiAgbiA9IGMobGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk1hbGUiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJGZW1hbGUiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJPdGhlciJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk1pc3NpbmciXSkpLA0KICBmcmVxID0gYyhyb3VuZChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik1hbGUiXSkvbGVuZ3RoKGdlbmRlciksIGRpZ2l0cz0yKSwgcm91bmQobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJGZW1hbGUiXSkvbGVuZ3RoKGdlbmRlciksIGRpZ2l0cz0yKSwgcm91bmQobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJPdGhlciJdKS9sZW5ndGgoZ2VuZGVyKSwgZGlnaXRzPTIpLCByb3VuZChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik1pc3NpbmciXSkvbGVuZ3RoKGdlbmRlciksIGRpZ2l0cz0yKSkNCikNCg0KIyBwbG90DQpkZiAlPiUNCiAgbXV0YXRlKGdlbmRlciA9IGZjdF9yZW9yZGVyKGdlbmRlciwgLW4pKSAlPiUNCiAgICAgICAgICAgZ2dwbG90KGFlcyhnZW5kZXIsIG4sIGZpbGw9Z2VuZGVyKSkgKyANCiAgICAgICAgICAgZ2VvbV9iYXIoc3RhdD0iaWRlbnRpdHkiLCB3aWR0aD0wLjgpICsNCiAgICAgICAgICAgZ2VvbV90ZXh0KGFlcyhsYWJlbD1wYXN0ZTAoZnJlcSwiJSIpKSwgdmp1c3Q9MS41LCBjb2xvdXI9IndoaXRlIikNCg0KYGBgDQoNCiMjIyMgQ2x1YiAyDQpgYGB7ciBjbGFzcy5zb3VyY2UgPSAnZm9sZC1oaWRlJ30NCmRmIDwtIGNsdWJkYXRhW1syXV0gIyBncmFiIGNsdWIgDQoNCiMgcmV0cmlldmUgbm9kZS1hdHRyaWJ1dGUgZ2VuZGVyIGZyb20gb2JqZWN0DQptYWxlIDwtIGRmJG1hbGUNCmZlbWFsZSA8LSBkZiRmZW1hbGUNCm90aGVyIDwtIGRmJG90aGVyDQoNCiMgYXMgZmFjdG9yDQpnZW5kZXIgPC0gTkENCmdlbmRlciA8LSBpZmVsc2UobWFsZSA9PSAxLCAiTWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoZmVtYWxlID09IDEsICJGZW1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKG90aGVyID09IDEsICJPdGhlciIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoaXMubmEoZ2VuZGVyKSwgIk1pc3NpbmciLCBnZW5kZXIpICMgbWlzc2luZyBjYXRlZ29yeQ0KDQojIG1ha2UgZGF0YWZyYW1lDQpkZiA8LSBkYXRhLmZyYW1lKA0KICBnZW5kZXIgPSBhcy5mYWN0b3IoYygiTWFsZSIsICJGZW1hbGUiLCAiT3RoZXIiLCAiTWlzc2luZyIpKSwNCiAgbiA9IGMobGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk1hbGUiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJGZW1hbGUiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJPdGhlciJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk1pc3NpbmciXSkpLA0KICBmcmVxID0gYyhyb3VuZChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik1hbGUiXSkvbGVuZ3RoKGdlbmRlciksIGRpZ2l0cz0yKSwgcm91bmQobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJGZW1hbGUiXSkvbGVuZ3RoKGdlbmRlciksIGRpZ2l0cz0yKSwgcm91bmQobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJPdGhlciJdKS9sZW5ndGgoZ2VuZGVyKSwgZGlnaXRzPTIpLCByb3VuZChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik1pc3NpbmciXSkvbGVuZ3RoKGdlbmRlciksIGRpZ2l0cz0yKSkNCikNCg0KIyBwbG90DQpkZiAlPiUNCiAgbXV0YXRlKGdlbmRlciA9IGZjdF9yZW9yZGVyKGdlbmRlciwgLW4pKSAlPiUNCiAgICAgICAgICAgZ2dwbG90KGFlcyhnZW5kZXIsIG4sIGZpbGw9Z2VuZGVyKSkgKyANCiAgICAgICAgICAgZ2VvbV9iYXIoc3RhdD0iaWRlbnRpdHkiLCB3aWR0aD0wLjgpICsNCiAgICAgICAgICAgZ2VvbV90ZXh0KGFlcyhsYWJlbD1wYXN0ZTAoZnJlcSwiJSIpKSwgdmp1c3Q9MS41LCBjb2xvdXI9IndoaXRlIikNCmBgYA0KDQojIyMjIENsdWIgMw0KYGBge3IgY2xhc3Muc291cmNlID0gJ2ZvbGQtaGlkZSd9DQpkZiA8LSBjbHViZGF0YVtbM11dICMgZ3JhYiBjbHViIA0KDQojIHJldHJpZXZlIG5vZGUtYXR0cmlidXRlIGdlbmRlciBmcm9tIG9iamVjdA0KbWFsZSA8LSBkZiRtYWxlDQpmZW1hbGUgPC0gZGYkZmVtYWxlDQpvdGhlciA8LSBkZiRvdGhlcg0KDQojIGFzIGZhY3Rvcg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBtYWtlIGRhdGFmcmFtZQ0KZGYgPC0gZGF0YS5mcmFtZSgNCiAgZ2VuZGVyID0gYXMuZmFjdG9yKGMoIk1hbGUiLCAiRmVtYWxlIiwgIk90aGVyIiwgIk1pc3NpbmciKSksDQogIG4gPSBjKGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJNYWxlIl0pLCBsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiRmVtYWxlIl0pLCBsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiT3RoZXIiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJNaXNzaW5nIl0pKSwNCiAgZnJlcSA9IGMocm91bmQobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJNYWxlIl0pL2xlbmd0aChnZW5kZXIpLCBkaWdpdHM9MiksIHJvdW5kKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iRmVtYWxlIl0pL2xlbmd0aChnZW5kZXIpLCBkaWdpdHM9MiksIHJvdW5kKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iT3RoZXIiXSkvbGVuZ3RoKGdlbmRlciksIGRpZ2l0cz0yKSwgcm91bmQobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJNaXNzaW5nIl0pL2xlbmd0aChnZW5kZXIpLCBkaWdpdHM9MikpDQopDQoNCiMgcGxvdA0KZGYgJT4lDQogIG11dGF0ZShnZW5kZXIgPSBmY3RfcmVvcmRlcihnZW5kZXIsIC1uKSkgJT4lDQogICAgICAgICAgIGdncGxvdChhZXMoZ2VuZGVyLCBuLCBmaWxsPWdlbmRlcikpICsgDQogICAgICAgICAgIGdlb21fYmFyKHN0YXQ9ImlkZW50aXR5Iiwgd2lkdGg9MC44KSArDQogICAgICAgICAgIGdlb21fdGV4dChhZXMobGFiZWw9cGFzdGUwKGZyZXEsIiUiKSksIHZqdXN0PTEuNSwgY29sb3VyPSJ3aGl0ZSIpDQpgYGANCg0KIyMjIyBDbHViIDQNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFbWzRdXSAjIGdyYWIgY2x1YiANCg0KIyByZXRyaWV2ZSBub2RlLWF0dHJpYnV0ZSBnZW5kZXIgZnJvbSBvYmplY3QNCm1hbGUgPC0gZGYkbWFsZQ0KZmVtYWxlIDwtIGRmJGZlbWFsZQ0Kb3RoZXIgPC0gZGYkb3RoZXINCg0KIyBhcyBmYWN0b3INCmdlbmRlciA8LSBOQQ0KZ2VuZGVyIDwtIGlmZWxzZShtYWxlID09IDEsICJNYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShmZW1hbGUgPT0gMSwgIkZlbWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2Uob3RoZXIgPT0gMSwgIk90aGVyIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShpcy5uYShnZW5kZXIpLCAiTWlzc2luZyIsIGdlbmRlcikgIyBtaXNzaW5nIGNhdGVnb3J5DQoNCiMgbWFrZSBkYXRhZnJhbWUNCmRmIDwtIGRhdGEuZnJhbWUoDQogIGdlbmRlciA9IGFzLmZhY3RvcihjKCJNYWxlIiwgIkZlbWFsZSIsICJPdGhlciIsICJNaXNzaW5nIikpLA0KICBuID0gYyhsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiTWFsZSJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIkZlbWFsZSJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk90aGVyIl0pLCBsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiTWlzc2luZyJdKSksDQogIGZyZXEgPSBjKHJvdW5kKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iTWFsZSJdKS9sZW5ndGgoZ2VuZGVyKSwgZGlnaXRzPTIpLCByb3VuZChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09IkZlbWFsZSJdKS9sZW5ndGgoZ2VuZGVyKSwgZGlnaXRzPTIpLCByb3VuZChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik90aGVyIl0pL2xlbmd0aChnZW5kZXIpLCBkaWdpdHM9MiksIHJvdW5kKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iTWlzc2luZyJdKS9sZW5ndGgoZ2VuZGVyKSwgZGlnaXRzPTIpKQ0KKQ0KDQojIHBsb3QNCmRmICU+JQ0KICBtdXRhdGUoZ2VuZGVyID0gZmN0X3Jlb3JkZXIoZ2VuZGVyLCAtbikpICU+JQ0KICAgICAgICAgICBnZ3Bsb3QoYWVzKGdlbmRlciwgbiwgZmlsbD1nZW5kZXIpKSArIA0KICAgICAgICAgICBnZW9tX2JhcihzdGF0PSJpZGVudGl0eSIsIHdpZHRoPTAuOCkgKw0KICAgICAgICAgICBnZW9tX3RleHQoYWVzKGxhYmVsPXBhc3RlMChmcmVxLCIlIikpLCB2anVzdD0xLjUsIGNvbG91cj0id2hpdGUiKQ0KYGBgDQoNCiMjIyMgQ2x1YiA1DQpgYGB7ciBjbGFzcy5zb3VyY2UgPSAnZm9sZC1oaWRlJ30NCmRmIDwtIGNsdWJkYXRhW1s1XV0gIyBncmFiIGNsdWIgDQoNCiMgcmV0cmlldmUgbm9kZS1hdHRyaWJ1dGUgZ2VuZGVyIGZyb20gb2JqZWN0DQptYWxlIDwtIGRmJG1hbGUNCmZlbWFsZSA8LSBkZiRmZW1hbGUNCm90aGVyIDwtIGRmJG90aGVyDQoNCiMgYXMgZmFjdG9yDQpnZW5kZXIgPC0gTkENCmdlbmRlciA8LSBpZmVsc2UobWFsZSA9PSAxLCAiTWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoZmVtYWxlID09IDEsICJGZW1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKG90aGVyID09IDEsICJPdGhlciIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoaXMubmEoZ2VuZGVyKSwgIk1pc3NpbmciLCBnZW5kZXIpICMgbWlzc2luZyBjYXRlZ29yeQ0KDQojIG1ha2UgZGF0YWZyYW1lDQpkZiA8LSBkYXRhLmZyYW1lKA0KICBnZW5kZXIgPSBhcy5mYWN0b3IoYygiTWFsZSIsICJGZW1hbGUiLCAiT3RoZXIiLCAiTWlzc2luZyIpKSwNCiAgbiA9IGMobGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk1hbGUiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJGZW1hbGUiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJPdGhlciJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk1pc3NpbmciXSkpLA0KICBmcmVxID0gYyhyb3VuZChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik1hbGUiXSkvbGVuZ3RoKGdlbmRlciksIGRpZ2l0cz0yKSwgcm91bmQobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJGZW1hbGUiXSkvbGVuZ3RoKGdlbmRlciksIGRpZ2l0cz0yKSwgcm91bmQobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJPdGhlciJdKS9sZW5ndGgoZ2VuZGVyKSwgZGlnaXRzPTIpLCByb3VuZChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik1pc3NpbmciXSkvbGVuZ3RoKGdlbmRlciksIGRpZ2l0cz0yKSkNCikNCg0KIyBwbG90DQpkZiAlPiUNCiAgbXV0YXRlKGdlbmRlciA9IGZjdF9yZW9yZGVyKGdlbmRlciwgLW4pKSAlPiUNCiAgICAgICAgICAgZ2dwbG90KGFlcyhnZW5kZXIsIG4sIGZpbGw9Z2VuZGVyKSkgKyANCiAgICAgICAgICAgZ2VvbV9iYXIoc3RhdD0iaWRlbnRpdHkiLCB3aWR0aD0wLjgpICsNCiAgICAgICAgICAgZ2VvbV90ZXh0KGFlcyhsYWJlbD1wYXN0ZTAoZnJlcSwiJSIpKSwgdmp1c3Q9MS41LCBjb2xvdXI9IndoaXRlIikNCmBgYA0KDQojIyMgey19DQoNCldlIGNhbiBzZWUgdGhhdCBpbiBhbGwgY2x1YnMgbWVuIGFyZSBvdmVycmVwcmVzZW50ZWQuIA0KDQotLS0tDQoNCjxicj4NCg0KIyMgR2VuZGVyIHNlZ3JlZ2F0aW9uDQoNCkxldCdzIG5vdyBpbnZlc3RpZ2F0ZSBzZWdyZWdhdGlvbiBhbG9uZyBnZW5kZXIgaW4gdGhlIGZyaWVuZHNoaXAgbmV0d29yay4NCg0KDQojIyMgey50YWJzZXQgLnRhYnNldC1mYWRlfQ0KDQpMZXQncyBzdGFydCB3aXRoIGRlc2NyaWJpbmcgdGhlIHRvdGFsIGRlbnNpdHkgYW5kIGludHJhLSAoc2FtZSBnZW5kZXIpIGFuZCBpbnRlcmdyb3VwIChkaWZmZXJlbnQgZ2VuZGVyKSBkZW5zaXRpZXMuIFdlIGFsc28gY2FsY3VsYXRlIHRoZSBDb2xlbWFuIEhvbW9waGlseSBpbmRleCBmb3IgZ2VuZGVyLCB3aGljaCByZWZlbGN0cyBnZW5kZXIgc2VncmVnYXRpb24gd2hpbGUgdGFraW5nIGludG8gYWNjb3VudCB0aGUgcmVsYXRpdmUgZ3JvdXAgc2l6ZSBvZiBnZW5kZXIgY2F0ZWdvcmllcy4gV2UgZGVzY3JpYmUgdGhlc2Ugc2VncmVnYXRpb24gbWVhc3VyZXMgZm9yIGZyaWVuZHNoaXAgYW5kIGt1ZG8tbmV0d29ya3MgcmVzcGVjdGl2ZWx5LiANCg0KIyMjIyBDbHViIDENCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1sxXV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzFdXQ0KDQpmbmV0IDwtIGRmJGR5Y0NvdmFycyRmcmllbmRzaGlwICMgdGFrZSBmcmllbmRzaGlwIG5ldHdvcmsNCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIGZvciBzb21lIHJlYXNvbiBjb25zdHJ1Y3RpbmcgdGhlIGR5YWQtc2ltaWxhcml0eSBtYXRyaXggZm9yIGdlbmRlciB3aXRoIHRoZSByc2llbmEgb2JqZWN0IGRpZCBub3Qgd29yaywgc28gd2UgdXNlIHRoZSBjbHViZGF0YS5SRGF0YS4NCm1hbGUgPC0gZGYyJG1hbGUNCmZlbWFsZSA8LSBkZjIkZmVtYWxlDQpvdGhlciA8LSBkZjIkb3RoZXINCg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBjb25zdHJ1Y3QgZHlhZCBzaW1pbGFyaXR5IG1hdHJpeA0KZ2VuZGVyX20gPC0gZmhvbW9tYXQoZ2VuZGVyKQ0KDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KZGVzbWF0IDwtIG1hdHJpeChOQSwgbnJvdz00LCBuY29sPTIpDQoNCiMgdXNlIGZ1bmN0aW9ucw0KZGVzbWF0WzEsIDFdIDwtIGZkZW5zaXR5KGZuZXQpDQpkZXNtYXRbMiwgMV0gPC0gZmRlbnNpdHlpbnRyYShmbmV0LCBnZW5kZXJfbSkNCmRlc21hdFszLCAxXSA8LSBmZGVuc2l0eWludGVyKGZuZXQsIGdlbmRlcl9tKQ0KZGVzbWF0WzQsIDFdIDwtIGZzY29sbmV0KGZuZXQsIGdlbmRlcikNCmRlc21hdFsxLCAyXSA8LSBmZGVuc2l0eShrbmV0MSkNCmRlc21hdFsyLCAyXSA8LSBmZGVuc2l0eWludHJhKGtuZXQxLCBnZW5kZXJfbSkNCmRlc21hdFszLCAyXSA8LSBmZGVuc2l0eWludGVyKGtuZXQxLCBnZW5kZXJfbSkNCmRlc21hdFs0LCAyXSA8LSBmc2NvbG5ldChrbmV0MSwgZ2VuZGVyKQ0KDQpjb2xuYW1lcyhkZXNtYXQpIDwtIGMoImZyaWVuZHNoaXBzIiwgIkt1ZG9zIikNCnJvd25hbWVzKGRlc21hdCkgPC0gYygidG90YWwgZGVuc2l0eSIsICJzYW1lIGdlbmRlciBkZW5zaXR5IiwgImRpZmZlcmVudCBnZW5kZXIgZGVuc2l0eSIsICJDb2xlbWFuJ3MgaG9tb3BoaWx5IGluZGV4IikNCg0KDQoNCmtuaXRyOjprYWJsZShkZXNtYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249IkdlbmRlciBzZWdyZWdhdGlvbiBpbiBmcmllbmRzaGlwIGFuZCBrdWRvIG5ldHdvcmsiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQpgYGANCg0KIyMjIyBDbHViIDINCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1syXV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzJdXQ0KDQpmbmV0IDwtIGRmJGR5Y0NvdmFycyRmcmllbmRzaGlwICMgdGFrZSBmcmllbmRzaGlwIG5ldHdvcmsNCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIGZvciBzb21lIHJlYXNvbiBjb25zdHJ1Y3RpbmcgdGhlIGR5YWQtc2ltaWxhcml0eSBtYXRyaXggZm9yIGdlbmRlciB3aXRoIHRoZSByc2llbmEgb2JqZWN0IGRpZCBub3Qgd29yaywgc28gd2UgdXNlIHRoZSBjbHViZGF0YS5SRGF0YS4NCm1hbGUgPC0gZGYyJG1hbGUNCmZlbWFsZSA8LSBkZjIkZmVtYWxlDQpvdGhlciA8LSBkZjIkb3RoZXINCg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBjb25zdHJ1Y3QgZHlhZCBzaW1pbGFyaXR5IG1hdHJpeA0KZ2VuZGVyX20gPC0gZmhvbW9tYXQoZ2VuZGVyKQ0KDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KZGVzbWF0IDwtIG1hdHJpeChOQSwgbnJvdz00LCBuY29sPTIpDQoNCiMgdXNlIGZ1bmN0aW9ucw0KZGVzbWF0WzEsIDFdIDwtIGZkZW5zaXR5KGZuZXQpDQpkZXNtYXRbMiwgMV0gPC0gZmRlbnNpdHlpbnRyYShmbmV0LCBnZW5kZXJfbSkNCmRlc21hdFszLCAxXSA8LSBmZGVuc2l0eWludGVyKGZuZXQsIGdlbmRlcl9tKQ0KZGVzbWF0WzQsIDFdIDwtIGZzY29sbmV0KGZuZXQsIGdlbmRlcikNCmRlc21hdFsxLCAyXSA8LSBmZGVuc2l0eShrbmV0MSkNCmRlc21hdFsyLCAyXSA8LSBmZGVuc2l0eWludHJhKGtuZXQxLCBnZW5kZXJfbSkNCmRlc21hdFszLCAyXSA8LSBmZGVuc2l0eWludGVyKGtuZXQxLCBnZW5kZXJfbSkNCmRlc21hdFs0LCAyXSA8LSBmc2NvbG5ldChrbmV0MSwgZ2VuZGVyKQ0KDQpjb2xuYW1lcyhkZXNtYXQpIDwtIGMoImZyaWVuZHNoaXBzIiwgIkt1ZG9zIikNCnJvd25hbWVzKGRlc21hdCkgPC0gYygidG90YWwgZGVuc2l0eSIsICJzYW1lIGdlbmRlciBkZW5zaXR5IiwgImRpZmZlcmVudCBnZW5kZXIgZGVuc2l0eSIsICJDb2xlbWFuJ3MgaG9tb3BoaWx5IGluZGV4IikNCg0KIyBhbmQgbWFrZSBhIG5pY2UgdGFibGUNCmtuaXRyOjprYWJsZShkZXNtYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249IkdlbmRlciBzZWdyZWdhdGlvbiBpbiBmcmllbmRzaGlwIGFuZCBrdWRvIG5ldHdvcmsiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQpgYGANCg0KIyMjIyBDbHViIDMNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1szXV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzNdXQ0KDQpmbmV0IDwtIGRmJGR5Y0NvdmFycyRmcmllbmRzaGlwICMgdGFrZSBmcmllbmRzaGlwIG5ldHdvcmsNCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIGZvciBzb21lIHJlYXNvbiBjb25zdHJ1Y3RpbmcgdGhlIGR5YWQtc2ltaWxhcml0eSBtYXRyaXggZm9yIGdlbmRlciB3aXRoIHRoZSByc2llbmEgb2JqZWN0IGRpZCBub3Qgd29yaywgc28gd2UgdXNlIHRoZSBjbHViZGF0YS5SRGF0YS4NCm1hbGUgPC0gZGYyJG1hbGUNCmZlbWFsZSA8LSBkZjIkZmVtYWxlDQpvdGhlciA8LSBkZjIkb3RoZXINCg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBjb25zdHJ1Y3QgZHlhZCBzaW1pbGFyaXR5IG1hdHJpeA0KZ2VuZGVyX20gPC0gZmhvbW9tYXQoZ2VuZGVyKQ0KDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KZGVzbWF0IDwtIG1hdHJpeChOQSwgbnJvdz00LCBuY29sPTIpDQoNCiMgdXNlIGZ1bmN0aW9ucw0KZGVzbWF0WzEsIDFdIDwtIGZkZW5zaXR5KGZuZXQpDQpkZXNtYXRbMiwgMV0gPC0gZmRlbnNpdHlpbnRyYShmbmV0LCBnZW5kZXJfbSkNCmRlc21hdFszLCAxXSA8LSBmZGVuc2l0eWludGVyKGZuZXQsIGdlbmRlcl9tKQ0KZGVzbWF0WzQsIDFdIDwtIGZzY29sbmV0KGZuZXQsIGdlbmRlcikNCmRlc21hdFsxLCAyXSA8LSBmZGVuc2l0eShrbmV0MSkNCmRlc21hdFsyLCAyXSA8LSBmZGVuc2l0eWludHJhKGtuZXQxLCBnZW5kZXJfbSkNCmRlc21hdFszLCAyXSA8LSBmZGVuc2l0eWludGVyKGtuZXQxLCBnZW5kZXJfbSkNCmRlc21hdFs0LCAyXSA8LSBmc2NvbG5ldChrbmV0MSwgZ2VuZGVyKQ0KDQpjb2xuYW1lcyhkZXNtYXQpIDwtIGMoImZyaWVuZHNoaXBzIiwgIkt1ZG9zIikNCnJvd25hbWVzKGRlc21hdCkgPC0gYygidG90YWwgZGVuc2l0eSIsICJzYW1lIGdlbmRlciBkZW5zaXR5IiwgImRpZmZlcmVudCBnZW5kZXIgZGVuc2l0eSIsICJDb2xlbWFuJ3MgaG9tb3BoaWx5IGluZGV4IikNCg0KIyBhbmQgbWFrZSBhIG5pY2UgdGFibGUNCmtuaXRyOjprYWJsZShkZXNtYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249IkdlbmRlciBzZWdyZWdhdGlvbiBpbiBmcmllbmRzaGlwIGFuZCBrdWRvIG5ldHdvcmsiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQpgYGANCg0KIyMjIyBDbHViIDQNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1s0XV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzRdXQ0KDQpmbmV0IDwtIGRmJGR5Y0NvdmFycyRmcmllbmRzaGlwICMgdGFrZSBmcmllbmRzaGlwIG5ldHdvcmsNCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIGZvciBzb21lIHJlYXNvbiBjb25zdHJ1Y3RpbmcgdGhlIGR5YWQtc2ltaWxhcml0eSBtYXRyaXggZm9yIGdlbmRlciB3aXRoIHRoZSByc2llbmEgb2JqZWN0IGRpZCBub3Qgd29yaywgc28gd2UgdXNlIHRoZSBjbHViZGF0YS5SRGF0YS4NCm1hbGUgPC0gZGYyJG1hbGUNCmZlbWFsZSA8LSBkZjIkZmVtYWxlDQpvdGhlciA8LSBkZjIkb3RoZXINCg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBjb25zdHJ1Y3QgZHlhZCBzaW1pbGFyaXR5IG1hdHJpeA0KZ2VuZGVyX20gPC0gZmhvbW9tYXQoZ2VuZGVyKQ0KDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KZGVzbWF0IDwtIG1hdHJpeChOQSwgbnJvdz00LCBuY29sPTIpDQoNCiMgdXNlIGZ1bmN0aW9ucw0KZGVzbWF0WzEsIDFdIDwtIGZkZW5zaXR5KGZuZXQpDQpkZXNtYXRbMiwgMV0gPC0gZmRlbnNpdHlpbnRyYShmbmV0LCBnZW5kZXJfbSkNCmRlc21hdFszLCAxXSA8LSBmZGVuc2l0eWludGVyKGZuZXQsIGdlbmRlcl9tKQ0KZGVzbWF0WzQsIDFdIDwtIGZzY29sbmV0KGZuZXQsIGdlbmRlcikNCmRlc21hdFsxLCAyXSA8LSBmZGVuc2l0eShrbmV0MSkNCmRlc21hdFsyLCAyXSA8LSBmZGVuc2l0eWludHJhKGtuZXQxLCBnZW5kZXJfbSkNCmRlc21hdFszLCAyXSA8LSBmZGVuc2l0eWludGVyKGtuZXQxLCBnZW5kZXJfbSkNCmRlc21hdFs0LCAyXSA8LSBmc2NvbG5ldChrbmV0MSwgZ2VuZGVyKQ0KDQpjb2xuYW1lcyhkZXNtYXQpIDwtIGMoImZyaWVuZHNoaXBzIiwgIkt1ZG9zIikNCnJvd25hbWVzKGRlc21hdCkgPC0gYygidG90YWwgZGVuc2l0eSIsICJzYW1lIGdlbmRlciBkZW5zaXR5IiwgImRpZmZlcmVudCBnZW5kZXIgZGVuc2l0eSIsICJDb2xlbWFuJ3MgaG9tb3BoaWx5IGluZGV4IikNCg0KIyBhbmQgbWFrZSBhIG5pY2UgdGFibGUNCmtuaXRyOjprYWJsZShkZXNtYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249IkdlbmRlciBzZWdyZWdhdGlvbiBpbiBmcmllbmRzaGlwIGFuZCBrdWRvIG5ldHdvcmsiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQpgYGANCg0KIyMjIyBDbHViIDUNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1s1XV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzVdXQ0KDQpmbmV0IDwtIGRmJGR5Y0NvdmFycyRmcmllbmRzaGlwICMgdGFrZSBmcmllbmRzaGlwIG5ldHdvcmsNCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIGZvciBzb21lIHJlYXNvbiBjb25zdHJ1Y3RpbmcgdGhlIGR5YWQtc2ltaWxhcml0eSBtYXRyaXggZm9yIGdlbmRlciB3aXRoIHRoZSByc2llbmEgb2JqZWN0IGRpZCBub3Qgd29yaywgc28gd2UgdXNlIHRoZSBjbHViZGF0YS5SRGF0YS4NCm1hbGUgPC0gZGYyJG1hbGUNCmZlbWFsZSA8LSBkZjIkZmVtYWxlDQpvdGhlciA8LSBkZjIkb3RoZXINCg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBjb25zdHJ1Y3QgZHlhZCBzaW1pbGFyaXR5IG1hdHJpeA0KZ2VuZGVyX20gPC0gZmhvbW9tYXQoZ2VuZGVyKQ0KDQojIG1ha2Ugb2JqZWN0IHRvIHN0b3JlIHJlc3VsdHMNCmRlc21hdCA8LSBtYXRyaXgoTkEsIG5yb3c9NCwgbmNvbD0yKQ0KDQojIHVzZSBmdW5jdGlvbnMNCmRlc21hdFsxLCAxXSA8LSBmZGVuc2l0eShmbmV0KQ0KZGVzbWF0WzIsIDFdIDwtIGZkZW5zaXR5aW50cmEoZm5ldCwgZ2VuZGVyX20pDQpkZXNtYXRbMywgMV0gPC0gZmRlbnNpdHlpbnRlcihmbmV0LCBnZW5kZXJfbSkNCmRlc21hdFs0LCAxXSA8LSBmc2NvbG5ldChmbmV0LCBnZW5kZXIpDQpkZXNtYXRbMSwgMl0gPC0gZmRlbnNpdHkoa25ldDEpDQpkZXNtYXRbMiwgMl0gPC0gZmRlbnNpdHlpbnRyYShrbmV0MSwgZ2VuZGVyX20pDQpkZXNtYXRbMywgMl0gPC0gZmRlbnNpdHlpbnRlcihrbmV0MSwgZ2VuZGVyX20pDQpkZXNtYXRbNCwgMl0gPC0gZnNjb2xuZXQoa25ldDEsIGdlbmRlcikNCg0KY29sbmFtZXMoZGVzbWF0KSA8LSBjKCJmcmllbmRzaGlwcyIsICJLdWRvcyIpDQpyb3duYW1lcyhkZXNtYXQpIDwtIGMoInRvdGFsIGRlbnNpdHkiLCAic2FtZSBnZW5kZXIgZGVuc2l0eSIsICJkaWZmZXJlbnQgZ2VuZGVyIGRlbnNpdHkiLCAiQ29sZW1hbidzIGhvbW9waGlseSBpbmRleCIpDQoNCiMgYW5kIG1ha2UgYSBuaWNlIHRhYmxlDQprbml0cjo6a2FibGUoZGVzbWF0LCBkaWdpdHM9MiwgImh0bWwiLCBjYXB0aW9uPSJHZW5kZXIgc2VncmVnYXRpb24gaW4gZnJpZW5kc2hpcCBhbmQga3VkbyBuZXR3b3JrIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCiMjIyB7LX0NCg0KRGVuc2l0eSBpbiBmcmllbmRzaGlwcyBpcyBub3QgbXVjaCBoaWdoZXIgd2l0aGluLWdlbmRlciB0aGFuIGJldHdlZW4tZ2VuZGVycywgdGhvdWdoIHRoaXMgcmF0aW8gZGlmZmVycyBwZXIgY2x1YiAoYW5kIGluIHNvbWUgY2x1YnMgYmV0d2Vlbi1nZW5kZXIgZnJpZW5kc2hpcHMgYXJlIG1vcmUgY29tbW9uKS4gVGhlIHNhbWUgcGF0dGVybiBob2xkcyBmb3IgS3Vkby1yZWxhdGlvbnNoaXBzLiANCg0KQ29sZW1hbidzIEhvbW9waGlseSBpbmRpY2VzIHZhcnkgYWNyb3NzIGNsdWJzLiBJbiBzb21lIGNsdWJzIHRoZXJlIGlzIHNsaWdodCBnZW5kZXIgc2VncmVnYXRpb24gKG9yIHNhbWUtZ2VuZGVyIHByZWZlcmVuY2UpIGluIGZyaWVuZHNoaXAgdGllcyAodmFsdWVzIGhpZ2hlciB0aGFuIDAsIGJ1dCByYXRoZXIgY2xvc2UgdG8gMCksIHRob3VnaCBpbiBvdGhlcnMgbWVtYmVycyB0ZW5kIHRvIGJlZnJpZW5kIG90aGVycyBvdXRzaWRlIHRoZWlyIG93biBnZW5kZXIgKHZhbHVlcyBsb3dlciB0aGFuIDApLiBPdmVyYWxsLCB0ZW5kZW5jaWVzIHRvd2FyZHMgc2VncmVnYXRpb24gKG9yIGF2b2lkYW5jZSB0aGVyZW9mKSBhcmUgcHJvbm91bmNlZCB0byBncmVhdGVyIGV4dGVudCBpbiB0aGUgS3Vkby1yZWxhdGlvbnNoaXBzIHRoYW4gaW4gdGhlIGZyaWVuZHNoaXBzLiANCg0KLS0tLQ0KDQo8YnI+DQoNCiMjIEJlaGF2aW9yDQoNCiMjIyAxLiBSdW5uaW5nIHsudGFic2V0IC50YWJzZXQtZmFkZX0NCg0KV2Ugd2lsbCBkZXNjcmliZSB0aGUgcnVubmluZyBhY3Rpdml0aWVzIG9mIHRoZSBjbHViLW1lbWJlcnMsIGluIHRlcm1zIG9mIHRpbWVzIHBlciB3ZWVrICgwIC0gPjcpIGFuZCBtaW51dGVzIHBlciBtb250aCAoOCBlcXVhbGx5IHBvcHVsYXRlZCBjYXRlZ29yaWVzKS4gRmlyc3QsIHdlIG1ha2UgYSBoaXN0b2dyYW0gb2YgYWxsIChhZ2dyZWdhdGVkKSBvYnNlcnZhdGlvbnMgd2l0aGluIGNsdWJzIG92ZXIgdGltZS4gVGhlbiB3ZSB3aWxsIHBsb3QgdGhlIGRldmVsb3BtZW50IG9mIHRoZSBtZWFuIG92ZXIgdGltZSAod2l0aCBlcnJvciBiYXJzIHJlZmxlY3RpbmcgOTUlIGNvbmZpZGVuY2UgaW50ZXJ2YWxzKSwgc2VwZXJhdGVseSBmb3IgbWVuIGFuZCB3b21lbi4gIA0KDQoNCg0KIyMjIyBDbHViIDENCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1sxXV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzFdXQ0KDQojIGRldmVsb3BtZW50IG9mIHRoZSBtZWFuIG92ZXIgdGltZQ0KDQojIHJldHJpZXZlIGdlbmRlcg0KbWFsZSA8LSBkZjIkbWFsZQ0KZmVtYWxlIDwtIGRmMiRmZW1hbGUNCm90aGVyIDwtIGRmMiRvdGhlcg0KDQpnZW5kZXIgPC0gTkENCmdlbmRlciA8LSBpZmVsc2UobWFsZSA9PSAxLCAiTWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoZmVtYWxlID09IDEsICJGZW1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKG90aGVyID09IDEsICJPdGhlciIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoaXMubmEoZ2VuZGVyKSwgIk1pc3NpbmciLCBnZW5kZXIpICMgbWlzc2luZyBjYXRlZ29yeQ0KDQoNCiMgY3JlYXRlIHdpZGUgZGF0YWZyYW1lDQogIGRmMmxvbmcgPC0gZGF0YS5mcmFtZSAoDQogICAgaWQgPSAxOmxlbmd0aChkZiRub2RlU2V0cyRBY3RvcnMpLA0KICAgIGdlbmRlciA9IGdlbmRlciwNCiAgICBmcmVxMSA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCwxXSwNCiAgICBmcmVxMiA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCwyXSwNCiAgICBmcmVxMyA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCwzXSwNCiAgICBmcmVxNCA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw0XSwNCiAgICBmcmVxNSA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw1XSwNCiAgICBmcmVxNiA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw2XSwNCiAgICBmcmVxNyA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw3XSwNCiAgICBmcmVxOCA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw4XSwNCiAgICBmcmVxOSA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw5XSwNCiAgICBmcmVxMTAgPSBkZiRkZXB2YXJzJGZyZXFfcnVuWywsMTBdLA0KICAgIGZyZXExMSA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCwxMV0sDQogICAgZnJlcTEyID0gZGYkZGVwdmFycyRmcmVxX3J1blssLDEyXSwNCiAgICB0aW1lMSA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCwxXSwNCiAgICB0aW1lMiA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCwyXSwNCiAgICB0aW1lMyA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCwzXSwNCiAgICB0aW1lNCA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw0XSwNCiAgICB0aW1lNSA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw1XSwNCiAgICB0aW1lNiA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw2XSwNCiAgICB0aW1lNyA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw3XSwNCiAgICB0aW1lOCA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw4XSwNCiAgICB0aW1lOSA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw5XSwNCiAgICB0aW1lMTAgPSBkZiRkZXB2YXJzJHRpbWVfcnVuWywsMTBdLA0KICAgIHRpbWUxMSA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCwxMV0sDQogICAgdGltZTEyID0gZGYkZGVwdmFycyR0aW1lX3J1blssLDEyXSkNCg0KIyByZXNoYXBlIHRvIGxvbmcgZGF0YWZyYW1lDQpkZl9sb25nIDwtIHJlc2hhcGUoZGYybG9uZywNCiAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICJsb25nIiwNCiAgICAgICAgICAgICAgICAgICAgIHZhcnlpbmcgPSBjKGxpc3QobmFtZXMoZGYybG9uZylbMzoxNF0pLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdChuYW1lcyhkZjJsb25nKVsxNToyNl0pKSwNCiAgICAgICAgICAgICAgICAgICAgIHYubmFtZXMgPSBjKCJydW5fZnJlcSIsICJydW5fdGltZSIpLA0KICAgICAgICAgICAgICAgICAgICAgaWR2YXIgPSAiaWQiLA0KICAgICAgICAgICAgICAgICAgICAgdGltZXZhciA9ICJ0aW1lIiwNCiAgICAgICAgICAgICAgICAgICAgIHRpbWVzID0gMToxMikNCg0KIyBSZW9yZGVyIGRhdGEgYmFzZWQgb24gdXNlciBpZA0KZGZfbG9uZyAgPC0gZGZfbG9uZyBbKG9yZGVyKGRmX2xvbmckaWQpKSwgXQ0KDQojIGNyZWF0ZSBkYXRhIHRvIHBsb3QsIHNlcGVyYXRlbHkgZm9yIG1lbiBhbmQgd29tZW4NCmRhdGFfYWxsIDwtIGRmX2xvbmcgJT4lDQogICAgZ3JvdXBfYnkodGltZSkgJT4lDQogICAgc3VtbWFyaXNlKG1lYW5fZnJlcSA9IG1lYW4ocnVuX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBtZWFuX3RpbWUgPSBtZWFuKHJ1bl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2VfZnJlcSA9IDEuOTYgKiAoc2QocnVuX2ZyZXEsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShydW5fZnJlcSkpKSksDQogICAgICAgICAgICAgIHNlX3RpbWUgPSAxLjk2ICogKHNkKHJ1bl90aW1lLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEocnVuX3RpbWUpKSkpLA0KICAgICAgICAgICAgICBzZF9mcmVxID0gc2QocnVuX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZF90aW1lID0gc2QocnVuX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICB2YXJfZnJlcSA9IHZhcihydW5fZnJlcSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAgdmFyX3RpbWUgPSB2YXIocnVuX3RpbWUsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIGt1cnRvc2lzX2ZyZXEgPSBrdXJ0b3NpcyhydW5fZnJlcSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGt1cnRvc2lzX3RpbWUgPSBrdXJ0b3NpcyhydW5fdGltZSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGNsYXNzID0gIkZ1bGwgU2FtcGxlIg0KICAgICkNCiANCiBkYXRhX21lbiA8LSBkZl9sb25nW3doaWNoKGRmX2xvbmckZ2VuZGVyID09ICJNYWxlIiksIF0NCiAgZGF0YV9tZW4gPC0gZGF0YV9tZW4gJT4lDQogICAgZ3JvdXBfYnkodGltZSkgJT4lDQogICAgc3VtbWFyaXNlKG1lYW5fZnJlcSA9IG1lYW4ocnVuX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBtZWFuX3RpbWUgPSBtZWFuKHJ1bl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2VfZnJlcSA9IDEuOTYgKiAoc2QocnVuX2ZyZXEsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShydW5fZnJlcSkpKSksDQogICAgICAgICAgICAgIHNlX3RpbWUgPSAxLjk2ICogKHNkKHJ1bl90aW1lLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEocnVuX3RpbWUpKSkpLA0KICAgICAgICAgICAgICBzZF9mcmVxID0gc2QocnVuX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZF90aW1lID0gc2QocnVuX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICB2YXJfZnJlcSA9IHZhcihydW5fZnJlcSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAgdmFyX3RpbWUgPSB2YXIocnVuX3RpbWUsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIGt1cnRvc2lzX2ZyZXEgPSBrdXJ0b3NpcyhydW5fZnJlcSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGt1cnRvc2lzX3RpbWUgPSBrdXJ0b3NpcyhydW5fdGltZSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGNsYXNzID0gIk1lbiINCiAgICApDQogIA0KICBkYXRhX3dvbWVuIDwtIGRmX2xvbmdbd2hpY2goZGZfbG9uZyRnZW5kZXIgPT0gIkZlbWFsZSIpLCBdDQogIGRhdGFfd29tZW4gPC0gZGF0YV93b21lbiAlPiUNCiAgICBncm91cF9ieSh0aW1lKSAlPiUNCiAgICBzdW1tYXJpc2UobWVhbl9mcmVxID0gbWVhbihydW5fZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIG1lYW5fdGltZSA9IG1lYW4ocnVuX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZV9mcmVxID0gMS45NiAqIChzZChydW5fZnJlcSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKHJ1bl9mcmVxKSkpKSwNCiAgICAgICAgICAgICAgc2VfdGltZSA9IDEuOTYgKiAoc2QocnVuX3RpbWUsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShydW5fdGltZSkpKSksDQogICAgICAgICAgICAgIHNkX2ZyZXEgPSBzZChydW5fZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNkX3RpbWUgPSBzZChydW5fdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHZhcl9mcmVxID0gdmFyKHJ1bl9mcmVxLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICB2YXJfdGltZSA9IHZhcihydW5fdGltZSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAga3VydG9zaXNfZnJlcSA9IGt1cnRvc2lzKHJ1bl9mcmVxLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAga3VydG9zaXNfdGltZSA9IGt1cnRvc2lzKHJ1bl90aW1lLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAgY2xhc3MgPSAiV29tZW4iDQogICAgKQ0KDQojIHN0YWNrIGRhdGEgDQpwbG90LmRhdGEgPC0gcmJpbmQoZGF0YV9hbGwsIGRhdGFfbWVuLCBkYXRhX3dvbWVuKQ0Kcm0oZGF0YV9hbGwsIGRhdGFfbWVuLCBkYXRhX3dvbWVuKQ0KDQojIGFkZCBtb250aHMNCnBsb3QuZGF0YSRtb250aCA8LSByZXAoYygiSmFuIiwgIkZlYiIsICJNYXIiLCAiQXByIiwgIk1heSIsICJKdW4iLCAiSnVsIiwgIkF1ZyIsICJTZXAiLCAiT2N0IiwgIk5vdiIsICJEZWMiKSwgMykNCg0KIyBwbG90DQpwbG90X21lYW5fZnJlcSA8LSBnZ3Bsb3QocGxvdC5kYXRhLCBhZXMobW9udGgsIG1lYW5fZnJlcSwgZ3JvdXAgPSBjbGFzcywgY29sb3VyID0gY2xhc3MpKSArDQogICAgZ2VvbV9wb2ludCgpICsNCiAgICBnZW9tX3Ntb290aChtZXRob2QgPSAibG9lc3MiLCBzaXplPTIpICsNCiAgICBnZW9tX2Vycm9yYmFyKGFlcyh0aW1lLCBtZWFuX2ZyZXEsIHltaW4gPSBtZWFuX2ZyZXEgLSBzZV9mcmVxLCB5bWF4ID0gbWVhbl9mcmVxICsgc2VfZnJlcSwNCiAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDAuNCkpICsNCiAgICB0aGVtZV9idyhiYXNlX2ZhbWlseT0ic2VyaWYiLCBiYXNlX3NpemU9MTYpICsNCiAgICBzY2FsZV9jb2xvdXJfbWFudWFsKHZhbHVlcz1jKCIjMDAwMDAwIiwgIiNFNjlGMDAiLCAiIzU2QjRFOSIpKSArDQogICAgbGFicyh5ID0gIlJ1bm5pbmcgZnJlcXVlbmN5IHBlciB3ZWVrIiwgeD0iTW9udGgiKSArDQogICAgc2NhbGVfeF9kaXNjcmV0ZShsaW1pdHM9YygiSmFuIiwgIkZlYiIsICJNYXIiLCAiQXByIiwgIk1heSIsICJKdW4iLCAiSnVsIiwgIkF1ZyIsICJTZXAiLCAiT2N0IiwgIk5vdiIsICJEZWMiKSkgKw0KICAgIHlsaW0oMCw1KSArDQogICAgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoZmFtaWx5PSJzZXJpZiIsIHNpemUgPSAxMCwgYW5nbGUgPSA0NSwgaGp1c3QgPSAxKSwgDQogICAgICAgICAgbGVnZW5kLnBvc2l0aW9uID0gInJpZ2h0IiwgbGVnZW5kLnRpdGxlPWVsZW1lbnRfYmxhbmsoKQ0KICAgICkNCiAgDQogIHBsb3RfbWVhbl90aW1lIDwtIGdncGxvdChwbG90LmRhdGEsIGFlcyhtb250aCwgbWVhbl90aW1lLCBncm91cCA9IGNsYXNzLCBjb2xvdXIgPSBjbGFzcykpICsNCiAgICBnZW9tX3BvaW50KCkgKw0KICAgIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsb2VzcyIsIHNpemU9MikgKw0KICAgIGdlb21fZXJyb3JiYXIoYWVzKHRpbWUsIG1lYW5fdGltZSwgeW1pbiA9IG1lYW5fdGltZSAtIHNlX3RpbWUsIHltYXggPSBtZWFuX3RpbWUgKyBzZV90aW1lLA0KICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMC40KSkgKw0KICAgIHRoZW1lX2J3KGJhc2VfZmFtaWx5PSJzZXJpZiIsIGJhc2Vfc2l6ZT0xNikgKw0KICAgIHNjYWxlX2NvbG91cl9tYW51YWwodmFsdWVzPWMoIiMwMDAwMDAiLCAiI0U2OUYwMCIsICIjNTZCNEU5IikpICsNCiAgICBsYWJzKHkgPSAiUnVubmluZyB2b2x1bWUgcGVyIG1vbnRoIiwgeD0iTW9udGgiKSArDQogICAgc2NhbGVfeF9kaXNjcmV0ZShsaW1pdHM9YygiSmFuIiwgIkZlYiIsICJNYXIiLCAiQXByIiwgIk1heSIsICJKdW4iLCAiSnVsIiwgIkF1ZyIsICJTZXAiLCAiT2N0IiwgIk5vdiIsICJEZWMiKSkgKw0KICAgIHlsaW0oMCw3KSArDQogICAgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoZmFtaWx5PSJzZXJpZiIsIHNpemUgPSAxMCwgYW5nbGUgPSA0NSwgaGp1c3QgPSAxKSwgDQogICAgICAgICAgbGVnZW5kLnBvc2l0aW9uID0gInJpZ2h0IiwgbGVnZW5kLnRpdGxlPWVsZW1lbnRfYmxhbmsoKQ0KICAgICkNCg0KIyMjIE91dHB1dCAjIyMNCg0KIyBoaXN0b2dyYW0gKGFzc3VtaW5nIGluZGVwZW5kZW50IG9ic2VydmF0aW9ucykNCmhpc3QoZGYkZGVwdmFycyRmcmVxX3J1biwgbWFpbiA9ICJIaXN0b2dyYW0gb2YgUnVubmluZyBGcmVxdWVuY3kiLCB4bGFiID0gIlRpbWVzIHBlciB3ZWVrIiwgeWxhYiA9ICJjb3VudCIsIGNvbCA9ICJncmV5IiwgYm9yZGVyPSAiYmxhY2siKQ0KDQpoaXN0KGRmJGRlcHZhcnMkdGltZV9ydW4sIG1haW4gPSAiSGlzdG9ncmFtIG9mIFJ1bm5pbmcgVm9sdW1lIiwgeGxhYiA9ICIiLCB5bGFiID0gImNvdW50IiwgY29sID0gImdyZXkiLCBib3JkZXI9ICJibGFjayIpDQoNCiMgZGV2ZWxvcG1lbnQgbWVhbiBvdmVyIHRpbWUNCnBsb3RfbWVhbl9mcmVxDQpwbG90X21lYW5fdGltZQ0KDQpgYGANCg0KIyMjIyBDbHViIDINCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1syXV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzJdXQ0KDQojIGRldmVsb3BtZW50IG9mIHRoZSBtZWFuIG92ZXIgdGltZQ0KDQojIHJldHJpZXZlIGdlbmRlcg0KbWFsZSA8LSBkZjIkbWFsZQ0KZmVtYWxlIDwtIGRmMiRmZW1hbGUNCm90aGVyIDwtIGRmMiRvdGhlcg0KDQpnZW5kZXIgPC0gTkENCmdlbmRlciA8LSBpZmVsc2UobWFsZSA9PSAxLCAiTWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoZmVtYWxlID09IDEsICJGZW1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKG90aGVyID09IDEsICJPdGhlciIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoaXMubmEoZ2VuZGVyKSwgIk1pc3NpbmciLCBnZW5kZXIpICMgbWlzc2luZyBjYXRlZ29yeQ0KDQoNCiMgY3JlYXRlIHdpZGUgZGF0YWZyYW1lDQogIGRmMmxvbmcgPC0gZGF0YS5mcmFtZSAoDQogICAgaWQgPSAxOmxlbmd0aChkZiRub2RlU2V0cyRBY3RvcnMpLA0KICAgIGdlbmRlciA9IGdlbmRlciwNCiAgICBmcmVxMSA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCwxXSwNCiAgICBmcmVxMiA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCwyXSwNCiAgICBmcmVxMyA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCwzXSwNCiAgICBmcmVxNCA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw0XSwNCiAgICBmcmVxNSA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw1XSwNCiAgICBmcmVxNiA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw2XSwNCiAgICBmcmVxNyA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw3XSwNCiAgICBmcmVxOCA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw4XSwNCiAgICBmcmVxOSA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw5XSwNCiAgICBmcmVxMTAgPSBkZiRkZXB2YXJzJGZyZXFfcnVuWywsMTBdLA0KICAgIGZyZXExMSA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCwxMV0sDQogICAgZnJlcTEyID0gZGYkZGVwdmFycyRmcmVxX3J1blssLDEyXSwNCiAgICB0aW1lMSA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCwxXSwNCiAgICB0aW1lMiA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCwyXSwNCiAgICB0aW1lMyA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCwzXSwNCiAgICB0aW1lNCA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw0XSwNCiAgICB0aW1lNSA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw1XSwNCiAgICB0aW1lNiA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw2XSwNCiAgICB0aW1lNyA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw3XSwNCiAgICB0aW1lOCA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw4XSwNCiAgICB0aW1lOSA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw5XSwNCiAgICB0aW1lMTAgPSBkZiRkZXB2YXJzJHRpbWVfcnVuWywsMTBdLA0KICAgIHRpbWUxMSA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCwxMV0sDQogICAgdGltZTEyID0gZGYkZGVwdmFycyR0aW1lX3J1blssLDEyXSkNCg0KIyByZXNoYXBlIHRvIGxvbmcgZGF0YWZyYW1lDQpkZl9sb25nIDwtIHJlc2hhcGUoZGYybG9uZywNCiAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICJsb25nIiwNCiAgICAgICAgICAgICAgICAgICAgIHZhcnlpbmcgPSBjKGxpc3QobmFtZXMoZGYybG9uZylbMzoxNF0pLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdChuYW1lcyhkZjJsb25nKVsxNToyNl0pKSwNCiAgICAgICAgICAgICAgICAgICAgIHYubmFtZXMgPSBjKCJydW5fZnJlcSIsICJydW5fdGltZSIpLA0KICAgICAgICAgICAgICAgICAgICAgaWR2YXIgPSAiaWQiLA0KICAgICAgICAgICAgICAgICAgICAgdGltZXZhciA9ICJ0aW1lIiwNCiAgICAgICAgICAgICAgICAgICAgIHRpbWVzID0gMToxMikNCg0KIyBSZW9yZGVyIGRhdGEgYmFzZWQgb24gdXNlciBpZA0KZGZfbG9uZyAgPC0gZGZfbG9uZyBbKG9yZGVyKGRmX2xvbmckaWQpKSwgXQ0KDQojIGNyZWF0ZSBkYXRhIHRvIHBsb3QsIHNlcGVyYXRlbHkgZm9yIG1lbiBhbmQgd29tZW4NCiBkYXRhX2FsbCA8LSBkZl9sb25nICU+JQ0KICAgIGdyb3VwX2J5KHRpbWUpICU+JQ0KICAgIHN1bW1hcmlzZShtZWFuX2ZyZXEgPSBtZWFuKHJ1bl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgbWVhbl90aW1lID0gbWVhbihydW5fdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNlX2ZyZXEgPSAxLjk2ICogKHNkKHJ1bl9mcmVxLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEocnVuX2ZyZXEpKSkpLA0KICAgICAgICAgICAgICBzZV90aW1lID0gMS45NiAqIChzZChydW5fdGltZSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKHJ1bl90aW1lKSkpKSwNCiAgICAgICAgICAgICAgc2RfZnJlcSA9IHNkKHJ1bl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2RfdGltZSA9IHNkKHJ1bl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgdmFyX2ZyZXEgPSB2YXIocnVuX2ZyZXEsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIHZhcl90aW1lID0gdmFyKHJ1bl90aW1lLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICBrdXJ0b3Npc19mcmVxID0ga3VydG9zaXMocnVuX2ZyZXEsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBrdXJ0b3Npc190aW1lID0ga3VydG9zaXMocnVuX3RpbWUsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBjbGFzcyA9ICJGdWxsIFNhbXBsZSINCiAgICApDQogDQogZGF0YV9tZW4gPC0gZGZfbG9uZ1t3aGljaChkZl9sb25nJGdlbmRlciA9PSAiTWFsZSIpLCBdDQogIGRhdGFfbWVuIDwtIGRhdGFfbWVuICU+JQ0KICAgIGdyb3VwX2J5KHRpbWUpICU+JQ0KICAgIHN1bW1hcmlzZShtZWFuX2ZyZXEgPSBtZWFuKHJ1bl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgbWVhbl90aW1lID0gbWVhbihydW5fdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNlX2ZyZXEgPSAxLjk2ICogKHNkKHJ1bl9mcmVxLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEocnVuX2ZyZXEpKSkpLA0KICAgICAgICAgICAgICBzZV90aW1lID0gMS45NiAqIChzZChydW5fdGltZSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKHJ1bl90aW1lKSkpKSwNCiAgICAgICAgICAgICAgc2RfZnJlcSA9IHNkKHJ1bl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2RfdGltZSA9IHNkKHJ1bl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgdmFyX2ZyZXEgPSB2YXIocnVuX2ZyZXEsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIHZhcl90aW1lID0gdmFyKHJ1bl90aW1lLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICBrdXJ0b3Npc19mcmVxID0ga3VydG9zaXMocnVuX2ZyZXEsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBrdXJ0b3Npc190aW1lID0ga3VydG9zaXMocnVuX3RpbWUsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBjbGFzcyA9ICJNZW4iDQogICAgKQ0KICANCiAgZGF0YV93b21lbiA8LSBkZl9sb25nW3doaWNoKGRmX2xvbmckZ2VuZGVyID09ICJGZW1hbGUiKSwgXQ0KICBkYXRhX3dvbWVuIDwtIGRhdGFfd29tZW4gJT4lDQogICAgZ3JvdXBfYnkodGltZSkgJT4lDQogICAgc3VtbWFyaXNlKG1lYW5fZnJlcSA9IG1lYW4ocnVuX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBtZWFuX3RpbWUgPSBtZWFuKHJ1bl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2VfZnJlcSA9IDEuOTYgKiAoc2QocnVuX2ZyZXEsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShydW5fZnJlcSkpKSksDQogICAgICAgICAgICAgIHNlX3RpbWUgPSAxLjk2ICogKHNkKHJ1bl90aW1lLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEocnVuX3RpbWUpKSkpLA0KICAgICAgICAgICAgICBzZF9mcmVxID0gc2QocnVuX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZF90aW1lID0gc2QocnVuX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICB2YXJfZnJlcSA9IHZhcihydW5fZnJlcSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAgdmFyX3RpbWUgPSB2YXIocnVuX3RpbWUsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIGt1cnRvc2lzX2ZyZXEgPSBrdXJ0b3NpcyhydW5fZnJlcSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGt1cnRvc2lzX3RpbWUgPSBrdXJ0b3NpcyhydW5fdGltZSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGNsYXNzID0gIldvbWVuIg0KICAgICkNCg0KIyBzdGFjayBkYXRhIA0KcGxvdC5kYXRhIDwtIHJiaW5kKGRhdGFfYWxsLCBkYXRhX21lbiwgZGF0YV93b21lbikNCnJtKGRhdGFfYWxsLCBkYXRhX21lbiwgZGF0YV93b21lbikNCg0KIyBhZGQgbW9udGhzDQpwbG90LmRhdGEkbW9udGggPC0gcmVwKGMoIkphbiIsICJGZWIiLCAiTWFyIiwgIkFwciIsICJNYXkiLCAiSnVuIiwgIkp1bCIsICJBdWciLCAiU2VwIiwgIk9jdCIsICJOb3YiLCAiRGVjIiksIDMpDQoNCiMgcGxvdA0KcGxvdF9tZWFuX2ZyZXEgPC0gZ2dwbG90KHBsb3QuZGF0YSwgYWVzKG1vbnRoLCBtZWFuX2ZyZXEsIGdyb3VwID0gY2xhc3MsIGNvbG91ciA9IGNsYXNzKSkgKw0KICAgIGdlb21fcG9pbnQoKSArDQogICAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxvZXNzIiwgc2l6ZT0yKSArDQogICAgZ2VvbV9lcnJvcmJhcihhZXModGltZSwgbWVhbl9mcmVxLCB5bWluID0gbWVhbl9mcmVxIC0gc2VfZnJlcSwgeW1heCA9IG1lYW5fZnJlcSArIHNlX2ZyZXEsDQogICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwLjQpKSArDQogICAgdGhlbWVfYncoYmFzZV9mYW1pbHk9InNlcmlmIiwgYmFzZV9zaXplPTE2KSArDQogICAgc2NhbGVfY29sb3VyX21hbnVhbCh2YWx1ZXM9YygiIzAwMDAwMCIsICIjRTY5RjAwIiwgIiM1NkI0RTkiKSkgKw0KICAgIGxhYnMoeSA9ICJSdW5uaW5nIGZyZXF1ZW5jeSBwZXIgd2VlayIsIHg9Ik1vbnRoIikgKw0KICAgIHNjYWxlX3hfZGlzY3JldGUobGltaXRzPWMoIkphbiIsICJGZWIiLCAiTWFyIiwgIkFwciIsICJNYXkiLCAiSnVuIiwgIkp1bCIsICJBdWciLCAiU2VwIiwgIk9jdCIsICJOb3YiLCAiRGVjIikpICsNCiAgICB5bGltKDAsNSkgKw0KICAgIHRoZW1lKGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KGZhbWlseT0ic2VyaWYiLCBzaXplID0gMTAsIGFuZ2xlID0gNDUsIGhqdXN0ID0gMSksIA0KICAgICAgICAgIGxlZ2VuZC5wb3NpdGlvbiA9ICJyaWdodCIsIGxlZ2VuZC50aXRsZT1lbGVtZW50X2JsYW5rKCkNCiAgICApDQogIA0KICBwbG90X21lYW5fdGltZSA8LSBnZ3Bsb3QocGxvdC5kYXRhLCBhZXMobW9udGgsIG1lYW5fdGltZSwgZ3JvdXAgPSBjbGFzcywgY29sb3VyID0gY2xhc3MpKSArDQogICAgZ2VvbV9wb2ludCgpICsNCiAgICBnZW9tX3Ntb290aChtZXRob2QgPSAibG9lc3MiLCBzaXplPTIpICsNCiAgICBnZW9tX2Vycm9yYmFyKGFlcyh0aW1lLCBtZWFuX3RpbWUsIHltaW4gPSBtZWFuX3RpbWUgLSBzZV90aW1lLCB5bWF4ID0gbWVhbl90aW1lICsgc2VfdGltZSwNCiAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDAuNCkpICsNCiAgICB0aGVtZV9idyhiYXNlX2ZhbWlseT0ic2VyaWYiLCBiYXNlX3NpemU9MTYpICsNCiAgICBzY2FsZV9jb2xvdXJfbWFudWFsKHZhbHVlcz1jKCIjMDAwMDAwIiwgIiNFNjlGMDAiLCAiIzU2QjRFOSIpKSArDQogICAgbGFicyh5ID0gIlJ1bm5pbmcgdm9sdW1lIHBlciBtb250aCIsIHg9Ik1vbnRoIikgKw0KICAgIHNjYWxlX3hfZGlzY3JldGUobGltaXRzPWMoIkphbiIsICJGZWIiLCAiTWFyIiwgIkFwciIsICJNYXkiLCAiSnVuIiwgIkp1bCIsICJBdWciLCAiU2VwIiwgIk9jdCIsICJOb3YiLCAiRGVjIikpICsNCiAgICB5bGltKDAsNykgKw0KICAgIHRoZW1lKGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KGZhbWlseT0ic2VyaWYiLCBzaXplID0gMTAsIGFuZ2xlID0gNDUsIGhqdXN0ID0gMSksIA0KICAgICAgICAgIGxlZ2VuZC5wb3NpdGlvbiA9ICJyaWdodCIsIGxlZ2VuZC50aXRsZT1lbGVtZW50X2JsYW5rKCkNCiAgICApDQoNCiMjIyBPdXRwdXQgIyMjDQoNCiMgaGlzdG9ncmFtIChhc3N1bWluZyBpbmRlcGVuZGVudCBvYnNlcnZhdGlvbnMpDQpoaXN0KGRmJGRlcHZhcnMkZnJlcV9ydW4sIG1haW4gPSAiSGlzdG9ncmFtIG9mIFJ1bm5pbmcgRnJlcXVlbmN5IiwgeGxhYiA9ICJUaW1lcyBwZXIgd2VlayIsIHlsYWIgPSAiY291bnQiLCBjb2wgPSAiZ3JleSIsIGJvcmRlcj0gImJsYWNrIikNCg0KaGlzdChkZiRkZXB2YXJzJHRpbWVfcnVuLCBtYWluID0gIkhpc3RvZ3JhbSBvZiBSdW5uaW5nIFZvbHVtZSIsIHhsYWIgPSAiIiwgeWxhYiA9ICJjb3VudCIsIGNvbCA9ICJncmV5IiwgYm9yZGVyPSAiYmxhY2siKQ0KDQojIGRldmVsb3BtZW50IG1lYW4gb3ZlciB0aW1lDQpwbG90X21lYW5fZnJlcQ0KcGxvdF9tZWFuX3RpbWUNCmBgYA0KDQojIyMjIENsdWIgMw0KYGBge3IgY2xhc3Muc291cmNlID0gJ2ZvbGQtaGlkZSd9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFbWzNdXSAjIGdyYWIgY2x1YiANCmRmMiA8LSBjbHViZGF0YVtbM11dDQoNCiMgZGV2ZWxvcG1lbnQgb2YgdGhlIG1lYW4gb3ZlciB0aW1lDQoNCiMgcmV0cmlldmUgZ2VuZGVyDQptYWxlIDwtIGRmMiRtYWxlDQpmZW1hbGUgPC0gZGYyJGZlbWFsZQ0Kb3RoZXIgPC0gZGYyJG90aGVyDQoNCmdlbmRlciA8LSBOQQ0KZ2VuZGVyIDwtIGlmZWxzZShtYWxlID09IDEsICJNYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShmZW1hbGUgPT0gMSwgIkZlbWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2Uob3RoZXIgPT0gMSwgIk90aGVyIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShpcy5uYShnZW5kZXIpLCAiTWlzc2luZyIsIGdlbmRlcikgIyBtaXNzaW5nIGNhdGVnb3J5DQoNCg0KIyBjcmVhdGUgd2lkZSBkYXRhZnJhbWUNCiAgZGYybG9uZyA8LSBkYXRhLmZyYW1lICgNCiAgICBpZCA9IDE6bGVuZ3RoKGRmJG5vZGVTZXRzJEFjdG9ycyksDQogICAgZ2VuZGVyID0gZ2VuZGVyLA0KICAgIGZyZXExID0gZGYkZGVwdmFycyRmcmVxX3J1blssLDFdLA0KICAgIGZyZXEyID0gZGYkZGVwdmFycyRmcmVxX3J1blssLDJdLA0KICAgIGZyZXEzID0gZGYkZGVwdmFycyRmcmVxX3J1blssLDNdLA0KICAgIGZyZXE0ID0gZGYkZGVwdmFycyRmcmVxX3J1blssLDRdLA0KICAgIGZyZXE1ID0gZGYkZGVwdmFycyRmcmVxX3J1blssLDVdLA0KICAgIGZyZXE2ID0gZGYkZGVwdmFycyRmcmVxX3J1blssLDZdLA0KICAgIGZyZXE3ID0gZGYkZGVwdmFycyRmcmVxX3J1blssLDddLA0KICAgIGZyZXE4ID0gZGYkZGVwdmFycyRmcmVxX3J1blssLDhdLA0KICAgIGZyZXE5ID0gZGYkZGVwdmFycyRmcmVxX3J1blssLDldLA0KICAgIGZyZXExMCA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCwxMF0sDQogICAgZnJlcTExID0gZGYkZGVwdmFycyRmcmVxX3J1blssLDExXSwNCiAgICBmcmVxMTIgPSBkZiRkZXB2YXJzJGZyZXFfcnVuWywsMTJdLA0KICAgIHRpbWUxID0gZGYkZGVwdmFycyR0aW1lX3J1blssLDFdLA0KICAgIHRpbWUyID0gZGYkZGVwdmFycyR0aW1lX3J1blssLDJdLA0KICAgIHRpbWUzID0gZGYkZGVwdmFycyR0aW1lX3J1blssLDNdLA0KICAgIHRpbWU0ID0gZGYkZGVwdmFycyR0aW1lX3J1blssLDRdLA0KICAgIHRpbWU1ID0gZGYkZGVwdmFycyR0aW1lX3J1blssLDVdLA0KICAgIHRpbWU2ID0gZGYkZGVwdmFycyR0aW1lX3J1blssLDZdLA0KICAgIHRpbWU3ID0gZGYkZGVwdmFycyR0aW1lX3J1blssLDddLA0KICAgIHRpbWU4ID0gZGYkZGVwdmFycyR0aW1lX3J1blssLDhdLA0KICAgIHRpbWU5ID0gZGYkZGVwdmFycyR0aW1lX3J1blssLDldLA0KICAgIHRpbWUxMCA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCwxMF0sDQogICAgdGltZTExID0gZGYkZGVwdmFycyR0aW1lX3J1blssLDExXSwNCiAgICB0aW1lMTIgPSBkZiRkZXB2YXJzJHRpbWVfcnVuWywsMTJdKQ0KDQojIHJlc2hhcGUgdG8gbG9uZyBkYXRhZnJhbWUNCmRmX2xvbmcgPC0gcmVzaGFwZShkZjJsb25nLA0KICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gImxvbmciLA0KICAgICAgICAgICAgICAgICAgICAgdmFyeWluZyA9IGMobGlzdChuYW1lcyhkZjJsb25nKVszOjE0XSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0KG5hbWVzKGRmMmxvbmcpWzE1OjI2XSkpLA0KICAgICAgICAgICAgICAgICAgICAgdi5uYW1lcyA9IGMoInJ1bl9mcmVxIiwgInJ1bl90aW1lIiksDQogICAgICAgICAgICAgICAgICAgICBpZHZhciA9ICJpZCIsDQogICAgICAgICAgICAgICAgICAgICB0aW1ldmFyID0gInRpbWUiLA0KICAgICAgICAgICAgICAgICAgICAgdGltZXMgPSAxOjEyKQ0KDQojIFJlb3JkZXIgZGF0YSBiYXNlZCBvbiB1c2VyIGlkDQpkZl9sb25nICA8LSBkZl9sb25nIFsob3JkZXIoZGZfbG9uZyRpZCkpLCBdDQoNCiMgY3JlYXRlIGRhdGEgdG8gcGxvdCwgc2VwZXJhdGVseSBmb3IgbWVuIGFuZCB3b21lbg0KIGRhdGFfYWxsIDwtIGRmX2xvbmcgJT4lDQogICAgZ3JvdXBfYnkodGltZSkgJT4lDQogICAgc3VtbWFyaXNlKG1lYW5fZnJlcSA9IG1lYW4ocnVuX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBtZWFuX3RpbWUgPSBtZWFuKHJ1bl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2VfZnJlcSA9IDEuOTYgKiAoc2QocnVuX2ZyZXEsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShydW5fZnJlcSkpKSksDQogICAgICAgICAgICAgIHNlX3RpbWUgPSAxLjk2ICogKHNkKHJ1bl90aW1lLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEocnVuX3RpbWUpKSkpLA0KICAgICAgICAgICAgICBzZF9mcmVxID0gc2QocnVuX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZF90aW1lID0gc2QocnVuX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICB2YXJfZnJlcSA9IHZhcihydW5fZnJlcSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAgdmFyX3RpbWUgPSB2YXIocnVuX3RpbWUsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIGt1cnRvc2lzX2ZyZXEgPSBrdXJ0b3NpcyhydW5fZnJlcSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGt1cnRvc2lzX3RpbWUgPSBrdXJ0b3NpcyhydW5fdGltZSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGNsYXNzID0gIkZ1bGwgU2FtcGxlIg0KICAgICkNCiANCiBkYXRhX21lbiA8LSBkZl9sb25nW3doaWNoKGRmX2xvbmckZ2VuZGVyID09ICJNYWxlIiksIF0NCiAgZGF0YV9tZW4gPC0gZGF0YV9tZW4gJT4lDQogICAgZ3JvdXBfYnkodGltZSkgJT4lDQogICAgc3VtbWFyaXNlKG1lYW5fZnJlcSA9IG1lYW4ocnVuX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBtZWFuX3RpbWUgPSBtZWFuKHJ1bl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2VfZnJlcSA9IDEuOTYgKiAoc2QocnVuX2ZyZXEsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShydW5fZnJlcSkpKSksDQogICAgICAgICAgICAgIHNlX3RpbWUgPSAxLjk2ICogKHNkKHJ1bl90aW1lLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEocnVuX3RpbWUpKSkpLA0KICAgICAgICAgICAgICBzZF9mcmVxID0gc2QocnVuX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZF90aW1lID0gc2QocnVuX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICB2YXJfZnJlcSA9IHZhcihydW5fZnJlcSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAgdmFyX3RpbWUgPSB2YXIocnVuX3RpbWUsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIGt1cnRvc2lzX2ZyZXEgPSBrdXJ0b3NpcyhydW5fZnJlcSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGt1cnRvc2lzX3RpbWUgPSBrdXJ0b3NpcyhydW5fdGltZSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGNsYXNzID0gIk1lbiINCiAgICApDQogIA0KICBkYXRhX3dvbWVuIDwtIGRmX2xvbmdbd2hpY2goZGZfbG9uZyRnZW5kZXIgPT0gIkZlbWFsZSIpLCBdDQogIGRhdGFfd29tZW4gPC0gZGF0YV93b21lbiAlPiUNCiAgICBncm91cF9ieSh0aW1lKSAlPiUNCiAgICBzdW1tYXJpc2UobWVhbl9mcmVxID0gbWVhbihydW5fZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIG1lYW5fdGltZSA9IG1lYW4ocnVuX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZV9mcmVxID0gMS45NiAqIChzZChydW5fZnJlcSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKHJ1bl9mcmVxKSkpKSwNCiAgICAgICAgICAgICAgc2VfdGltZSA9IDEuOTYgKiAoc2QocnVuX3RpbWUsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShydW5fdGltZSkpKSksDQogICAgICAgICAgICAgIHNkX2ZyZXEgPSBzZChydW5fZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNkX3RpbWUgPSBzZChydW5fdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHZhcl9mcmVxID0gdmFyKHJ1bl9mcmVxLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICB2YXJfdGltZSA9IHZhcihydW5fdGltZSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAga3VydG9zaXNfZnJlcSA9IGt1cnRvc2lzKHJ1bl9mcmVxLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAga3VydG9zaXNfdGltZSA9IGt1cnRvc2lzKHJ1bl90aW1lLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAgY2xhc3MgPSAiV29tZW4iDQogICAgKQ0KDQojIHN0YWNrIGRhdGEgDQpwbG90LmRhdGEgPC0gcmJpbmQoZGF0YV9hbGwsIGRhdGFfbWVuLCBkYXRhX3dvbWVuKQ0Kcm0oZGF0YV9hbGwsIGRhdGFfbWVuLCBkYXRhX3dvbWVuKQ0KDQojIGFkZCBtb250aHMNCnBsb3QuZGF0YSRtb250aCA8LSByZXAoYygiSmFuIiwgIkZlYiIsICJNYXIiLCAiQXByIiwgIk1heSIsICJKdW4iLCAiSnVsIiwgIkF1ZyIsICJTZXAiLCAiT2N0IiwgIk5vdiIsICJEZWMiKSwgMykNCg0KIyBwbG90DQpwbG90X21lYW5fZnJlcSA8LSBnZ3Bsb3QocGxvdC5kYXRhLCBhZXMobW9udGgsIG1lYW5fZnJlcSwgZ3JvdXAgPSBjbGFzcywgY29sb3VyID0gY2xhc3MpKSArDQogICAgZ2VvbV9wb2ludCgpICsNCiAgICBnZW9tX3Ntb290aChtZXRob2QgPSAibG9lc3MiLCBzaXplPTIpICsNCiAgICBnZW9tX2Vycm9yYmFyKGFlcyh0aW1lLCBtZWFuX2ZyZXEsIHltaW4gPSBtZWFuX2ZyZXEgLSBzZV9mcmVxLCB5bWF4ID0gbWVhbl9mcmVxICsgc2VfZnJlcSwNCiAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDAuNCkpICsNCiAgICB0aGVtZV9idyhiYXNlX2ZhbWlseT0ic2VyaWYiLCBiYXNlX3NpemU9MTYpICsNCiAgICBzY2FsZV9jb2xvdXJfbWFudWFsKHZhbHVlcz1jKCIjMDAwMDAwIiwgIiNFNjlGMDAiLCAiIzU2QjRFOSIpKSArDQogICAgbGFicyh5ID0gIlJ1bm5pbmcgZnJlcXVlbmN5IHBlciB3ZWVrIiwgeD0iTW9udGgiKSArDQogICAgc2NhbGVfeF9kaXNjcmV0ZShsaW1pdHM9YygiSmFuIiwgIkZlYiIsICJNYXIiLCAiQXByIiwgIk1heSIsICJKdW4iLCAiSnVsIiwgIkF1ZyIsICJTZXAiLCAiT2N0IiwgIk5vdiIsICJEZWMiKSkgKw0KICAgIHlsaW0oMCw1KSArDQogICAgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoZmFtaWx5PSJzZXJpZiIsIHNpemUgPSAxMCwgYW5nbGUgPSA0NSwgaGp1c3QgPSAxKSwgDQogICAgICAgICAgbGVnZW5kLnBvc2l0aW9uID0gInJpZ2h0IiwgbGVnZW5kLnRpdGxlPWVsZW1lbnRfYmxhbmsoKQ0KICAgICkNCiAgDQogIHBsb3RfbWVhbl90aW1lIDwtIGdncGxvdChwbG90LmRhdGEsIGFlcyhtb250aCwgbWVhbl90aW1lLCBncm91cCA9IGNsYXNzLCBjb2xvdXIgPSBjbGFzcykpICsNCiAgICBnZW9tX3BvaW50KCkgKw0KICAgIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsb2VzcyIsIHNpemU9MikgKw0KICAgIGdlb21fZXJyb3JiYXIoYWVzKHRpbWUsIG1lYW5fdGltZSwgeW1pbiA9IG1lYW5fdGltZSAtIHNlX3RpbWUsIHltYXggPSBtZWFuX3RpbWUgKyBzZV90aW1lLA0KICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMC40KSkgKw0KICAgIHRoZW1lX2J3KGJhc2VfZmFtaWx5PSJzZXJpZiIsIGJhc2Vfc2l6ZT0xNikgKw0KICAgIHNjYWxlX2NvbG91cl9tYW51YWwodmFsdWVzPWMoIiMwMDAwMDAiLCAiI0U2OUYwMCIsICIjNTZCNEU5IikpICsNCiAgICBsYWJzKHkgPSAiUnVubmluZyB2b2x1bWUgcGVyIG1vbnRoIiwgeD0iTW9udGgiKSArDQogICAgc2NhbGVfeF9kaXNjcmV0ZShsaW1pdHM9YygiSmFuIiwgIkZlYiIsICJNYXIiLCAiQXByIiwgIk1heSIsICJKdW4iLCAiSnVsIiwgIkF1ZyIsICJTZXAiLCAiT2N0IiwgIk5vdiIsICJEZWMiKSkgKw0KICAgIHlsaW0oMCw3KSArDQogICAgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoZmFtaWx5PSJzZXJpZiIsIHNpemUgPSAxMCwgYW5nbGUgPSA0NSwgaGp1c3QgPSAxKSwgDQogICAgICAgICAgbGVnZW5kLnBvc2l0aW9uID0gInJpZ2h0IiwgbGVnZW5kLnRpdGxlPWVsZW1lbnRfYmxhbmsoKQ0KICAgICkNCg0KIyMjIE91dHB1dCAjIyMNCg0KIyBoaXN0b2dyYW0gKGFzc3VtaW5nIGluZGVwZW5kZW50IG9ic2VydmF0aW9ucykNCmhpc3QoZGYkZGVwdmFycyRmcmVxX3J1biwgbWFpbiA9ICJIaXN0b2dyYW0gb2YgUnVubmluZyBGcmVxdWVuY3kiLCB4bGFiID0gIlRpbWVzIHBlciB3ZWVrIiwgeWxhYiA9ICJjb3VudCIsIGNvbCA9ICJncmV5IiwgYm9yZGVyPSAiYmxhY2siKQ0KDQpoaXN0KGRmJGRlcHZhcnMkdGltZV9ydW4sIG1haW4gPSAiSGlzdG9ncmFtIG9mIFJ1bm5pbmcgVm9sdW1lIiwgeGxhYiA9ICIiLCB5bGFiID0gImNvdW50IiwgY29sID0gImdyZXkiLCBib3JkZXI9ICJibGFjayIpDQoNCiMgZGV2ZWxvcG1lbnQgbWVhbiBvdmVyIHRpbWUNCnBsb3RfbWVhbl9mcmVxDQpwbG90X21lYW5fdGltZQ0KYGBgDQoNCiMjIyMgQ2x1YiA0DQpgYGB7ciBjbGFzcy5zb3VyY2UgPSAnZm9sZC1oaWRlJ30NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYVtbNF1dICMgZ3JhYiBjbHViIA0KZGYyIDwtIGNsdWJkYXRhW1s0XV0NCg0KIyBkZXZlbG9wbWVudCBvZiB0aGUgbWVhbiBvdmVyIHRpbWUNCg0KIyByZXRyaWV2ZSBnZW5kZXINCm1hbGUgPC0gZGYyJG1hbGUNCmZlbWFsZSA8LSBkZjIkZmVtYWxlDQpvdGhlciA8LSBkZjIkb3RoZXINCg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KDQojIGNyZWF0ZSB3aWRlIGRhdGFmcmFtZQ0KICBkZjJsb25nIDwtIGRhdGEuZnJhbWUgKA0KICAgIGlkID0gMTpsZW5ndGgoZGYkbm9kZVNldHMkQWN0b3JzKSwNCiAgICBnZW5kZXIgPSBnZW5kZXIsDQogICAgZnJlcTEgPSBkZiRkZXB2YXJzJGZyZXFfcnVuWywsMV0sDQogICAgZnJlcTIgPSBkZiRkZXB2YXJzJGZyZXFfcnVuWywsMl0sDQogICAgZnJlcTMgPSBkZiRkZXB2YXJzJGZyZXFfcnVuWywsM10sDQogICAgZnJlcTQgPSBkZiRkZXB2YXJzJGZyZXFfcnVuWywsNF0sDQogICAgZnJlcTUgPSBkZiRkZXB2YXJzJGZyZXFfcnVuWywsNV0sDQogICAgZnJlcTYgPSBkZiRkZXB2YXJzJGZyZXFfcnVuWywsNl0sDQogICAgZnJlcTcgPSBkZiRkZXB2YXJzJGZyZXFfcnVuWywsN10sDQogICAgZnJlcTggPSBkZiRkZXB2YXJzJGZyZXFfcnVuWywsOF0sDQogICAgZnJlcTkgPSBkZiRkZXB2YXJzJGZyZXFfcnVuWywsOV0sDQogICAgZnJlcTEwID0gZGYkZGVwdmFycyRmcmVxX3J1blssLDEwXSwNCiAgICBmcmVxMTEgPSBkZiRkZXB2YXJzJGZyZXFfcnVuWywsMTFdLA0KICAgIGZyZXExMiA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCwxMl0sDQogICAgdGltZTEgPSBkZiRkZXB2YXJzJHRpbWVfcnVuWywsMV0sDQogICAgdGltZTIgPSBkZiRkZXB2YXJzJHRpbWVfcnVuWywsMl0sDQogICAgdGltZTMgPSBkZiRkZXB2YXJzJHRpbWVfcnVuWywsM10sDQogICAgdGltZTQgPSBkZiRkZXB2YXJzJHRpbWVfcnVuWywsNF0sDQogICAgdGltZTUgPSBkZiRkZXB2YXJzJHRpbWVfcnVuWywsNV0sDQogICAgdGltZTYgPSBkZiRkZXB2YXJzJHRpbWVfcnVuWywsNl0sDQogICAgdGltZTcgPSBkZiRkZXB2YXJzJHRpbWVfcnVuWywsN10sDQogICAgdGltZTggPSBkZiRkZXB2YXJzJHRpbWVfcnVuWywsOF0sDQogICAgdGltZTkgPSBkZiRkZXB2YXJzJHRpbWVfcnVuWywsOV0sDQogICAgdGltZTEwID0gZGYkZGVwdmFycyR0aW1lX3J1blssLDEwXSwNCiAgICB0aW1lMTEgPSBkZiRkZXB2YXJzJHRpbWVfcnVuWywsMTFdLA0KICAgIHRpbWUxMiA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCwxMl0pDQoNCiMgcmVzaGFwZSB0byBsb25nIGRhdGFmcmFtZQ0KZGZfbG9uZyA8LSByZXNoYXBlKGRmMmxvbmcsDQogICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAibG9uZyIsDQogICAgICAgICAgICAgICAgICAgICB2YXJ5aW5nID0gYyhsaXN0KG5hbWVzKGRmMmxvbmcpWzM6MTRdKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QobmFtZXMoZGYybG9uZylbMTU6MjZdKSksDQogICAgICAgICAgICAgICAgICAgICB2Lm5hbWVzID0gYygicnVuX2ZyZXEiLCAicnVuX3RpbWUiKSwNCiAgICAgICAgICAgICAgICAgICAgIGlkdmFyID0gImlkIiwNCiAgICAgICAgICAgICAgICAgICAgIHRpbWV2YXIgPSAidGltZSIsDQogICAgICAgICAgICAgICAgICAgICB0aW1lcyA9IDE6MTIpDQoNCiMgUmVvcmRlciBkYXRhIGJhc2VkIG9uIHVzZXIgaWQNCmRmX2xvbmcgIDwtIGRmX2xvbmcgWyhvcmRlcihkZl9sb25nJGlkKSksIF0NCg0KIyBjcmVhdGUgZGF0YSB0byBwbG90LCBzZXBlcmF0ZWx5IGZvciBtZW4gYW5kIHdvbWVuDQogZGF0YV9hbGwgPC0gZGZfbG9uZyAlPiUNCiAgICBncm91cF9ieSh0aW1lKSAlPiUNCiAgICBzdW1tYXJpc2UobWVhbl9mcmVxID0gbWVhbihydW5fZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIG1lYW5fdGltZSA9IG1lYW4ocnVuX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZV9mcmVxID0gMS45NiAqIChzZChydW5fZnJlcSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKHJ1bl9mcmVxKSkpKSwNCiAgICAgICAgICAgICAgc2VfdGltZSA9IDEuOTYgKiAoc2QocnVuX3RpbWUsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShydW5fdGltZSkpKSksDQogICAgICAgICAgICAgIHNkX2ZyZXEgPSBzZChydW5fZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNkX3RpbWUgPSBzZChydW5fdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHZhcl9mcmVxID0gdmFyKHJ1bl9mcmVxLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICB2YXJfdGltZSA9IHZhcihydW5fdGltZSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAga3VydG9zaXNfZnJlcSA9IGt1cnRvc2lzKHJ1bl9mcmVxLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAga3VydG9zaXNfdGltZSA9IGt1cnRvc2lzKHJ1bl90aW1lLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAgY2xhc3MgPSAiRnVsbCBTYW1wbGUiDQogICAgKQ0KIA0KIGRhdGFfbWVuIDwtIGRmX2xvbmdbd2hpY2goZGZfbG9uZyRnZW5kZXIgPT0gIk1hbGUiKSwgXQ0KICBkYXRhX21lbiA8LSBkYXRhX21lbiAlPiUNCiAgICBncm91cF9ieSh0aW1lKSAlPiUNCiAgICBzdW1tYXJpc2UobWVhbl9mcmVxID0gbWVhbihydW5fZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIG1lYW5fdGltZSA9IG1lYW4ocnVuX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZV9mcmVxID0gMS45NiAqIChzZChydW5fZnJlcSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKHJ1bl9mcmVxKSkpKSwNCiAgICAgICAgICAgICAgc2VfdGltZSA9IDEuOTYgKiAoc2QocnVuX3RpbWUsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShydW5fdGltZSkpKSksDQogICAgICAgICAgICAgIHNkX2ZyZXEgPSBzZChydW5fZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNkX3RpbWUgPSBzZChydW5fdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHZhcl9mcmVxID0gdmFyKHJ1bl9mcmVxLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICB2YXJfdGltZSA9IHZhcihydW5fdGltZSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAga3VydG9zaXNfZnJlcSA9IGt1cnRvc2lzKHJ1bl9mcmVxLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAga3VydG9zaXNfdGltZSA9IGt1cnRvc2lzKHJ1bl90aW1lLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAgY2xhc3MgPSAiTWVuIg0KICAgICkNCiAgDQogIGRhdGFfd29tZW4gPC0gZGZfbG9uZ1t3aGljaChkZl9sb25nJGdlbmRlciA9PSAiRmVtYWxlIiksIF0NCiAgZGF0YV93b21lbiA8LSBkYXRhX3dvbWVuICU+JQ0KICAgIGdyb3VwX2J5KHRpbWUpICU+JQ0KICAgIHN1bW1hcmlzZShtZWFuX2ZyZXEgPSBtZWFuKHJ1bl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgbWVhbl90aW1lID0gbWVhbihydW5fdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNlX2ZyZXEgPSAxLjk2ICogKHNkKHJ1bl9mcmVxLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEocnVuX2ZyZXEpKSkpLA0KICAgICAgICAgICAgICBzZV90aW1lID0gMS45NiAqIChzZChydW5fdGltZSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKHJ1bl90aW1lKSkpKSwNCiAgICAgICAgICAgICAgc2RfZnJlcSA9IHNkKHJ1bl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2RfdGltZSA9IHNkKHJ1bl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgdmFyX2ZyZXEgPSB2YXIocnVuX2ZyZXEsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIHZhcl90aW1lID0gdmFyKHJ1bl90aW1lLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICBrdXJ0b3Npc19mcmVxID0ga3VydG9zaXMocnVuX2ZyZXEsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBrdXJ0b3Npc190aW1lID0ga3VydG9zaXMocnVuX3RpbWUsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBjbGFzcyA9ICJXb21lbiINCiAgICApDQoNCiMgc3RhY2sgZGF0YSANCnBsb3QuZGF0YSA8LSByYmluZChkYXRhX2FsbCwgZGF0YV9tZW4sIGRhdGFfd29tZW4pDQpybShkYXRhX2FsbCwgZGF0YV9tZW4sIGRhdGFfd29tZW4pDQoNCiMgYWRkIG1vbnRocw0KcGxvdC5kYXRhJG1vbnRoIDwtIHJlcChjKCJKYW4iLCAiRmViIiwgIk1hciIsICJBcHIiLCAiTWF5IiwgIkp1biIsICJKdWwiLCAiQXVnIiwgIlNlcCIsICJPY3QiLCAiTm92IiwgIkRlYyIpLCAzKQ0KDQojIHBsb3QNCnBsb3RfbWVhbl9mcmVxIDwtIGdncGxvdChwbG90LmRhdGEsIGFlcyhtb250aCwgbWVhbl9mcmVxLCBncm91cCA9IGNsYXNzLCBjb2xvdXIgPSBjbGFzcykpICsNCiAgICBnZW9tX3BvaW50KCkgKw0KICAgIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsb2VzcyIsIHNpemU9MikgKw0KICAgIGdlb21fZXJyb3JiYXIoYWVzKHRpbWUsIG1lYW5fZnJlcSwgeW1pbiA9IG1lYW5fZnJlcSAtIHNlX2ZyZXEsIHltYXggPSBtZWFuX2ZyZXEgKyBzZV9mcmVxLA0KICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMC40KSkgKw0KICAgIHRoZW1lX2J3KGJhc2VfZmFtaWx5PSJzZXJpZiIsIGJhc2Vfc2l6ZT0xNikgKw0KICAgIHNjYWxlX2NvbG91cl9tYW51YWwodmFsdWVzPWMoIiMwMDAwMDAiLCAiI0U2OUYwMCIsICIjNTZCNEU5IikpICsNCiAgICBsYWJzKHkgPSAiUnVubmluZyBmcmVxdWVuY3kgcGVyIHdlZWsiLCB4PSJNb250aCIpICsNCiAgICBzY2FsZV94X2Rpc2NyZXRlKGxpbWl0cz1jKCJKYW4iLCAiRmViIiwgIk1hciIsICJBcHIiLCAiTWF5IiwgIkp1biIsICJKdWwiLCAiQXVnIiwgIlNlcCIsICJPY3QiLCAiTm92IiwgIkRlYyIpKSArDQogICAgeWxpbSgwLDUpICsNCiAgICB0aGVtZShheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChmYW1pbHk9InNlcmlmIiwgc2l6ZSA9IDEwLCBhbmdsZSA9IDQ1LCBoanVzdCA9IDEpLCANCiAgICAgICAgICBsZWdlbmQucG9zaXRpb24gPSAicmlnaHQiLCBsZWdlbmQudGl0bGU9ZWxlbWVudF9ibGFuaygpDQogICAgKQ0KICANCiAgcGxvdF9tZWFuX3RpbWUgPC0gZ2dwbG90KHBsb3QuZGF0YSwgYWVzKG1vbnRoLCBtZWFuX3RpbWUsIGdyb3VwID0gY2xhc3MsIGNvbG91ciA9IGNsYXNzKSkgKw0KICAgIGdlb21fcG9pbnQoKSArDQogICAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxvZXNzIiwgc2l6ZT0yKSArDQogICAgZ2VvbV9lcnJvcmJhcihhZXModGltZSwgbWVhbl90aW1lLCB5bWluID0gbWVhbl90aW1lIC0gc2VfdGltZSwgeW1heCA9IG1lYW5fdGltZSArIHNlX3RpbWUsDQogICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwLjQpKSArDQogICAgdGhlbWVfYncoYmFzZV9mYW1pbHk9InNlcmlmIiwgYmFzZV9zaXplPTE2KSArDQogICAgc2NhbGVfY29sb3VyX21hbnVhbCh2YWx1ZXM9YygiIzAwMDAwMCIsICIjRTY5RjAwIiwgIiM1NkI0RTkiKSkgKw0KICAgIGxhYnMoeSA9ICJSdW5uaW5nIHZvbHVtZSBwZXIgbW9udGgiLCB4PSJNb250aCIpICsNCiAgICBzY2FsZV94X2Rpc2NyZXRlKGxpbWl0cz1jKCJKYW4iLCAiRmViIiwgIk1hciIsICJBcHIiLCAiTWF5IiwgIkp1biIsICJKdWwiLCAiQXVnIiwgIlNlcCIsICJPY3QiLCAiTm92IiwgIkRlYyIpKSArDQogICAgeWxpbSgwLDcpICsNCiAgICB0aGVtZShheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChmYW1pbHk9InNlcmlmIiwgc2l6ZSA9IDEwLCBhbmdsZSA9IDQ1LCBoanVzdCA9IDEpLCANCiAgICAgICAgICBsZWdlbmQucG9zaXRpb24gPSAicmlnaHQiLCBsZWdlbmQudGl0bGU9ZWxlbWVudF9ibGFuaygpDQogICAgKQ0KDQojIyMgT3V0cHV0ICMjIw0KDQojIGhpc3RvZ3JhbSAoYXNzdW1pbmcgaW5kZXBlbmRlbnQgb2JzZXJ2YXRpb25zKQ0KaGlzdChkZiRkZXB2YXJzJGZyZXFfcnVuLCBtYWluID0gIkhpc3RvZ3JhbSBvZiBSdW5uaW5nIEZyZXF1ZW5jeSIsIHhsYWIgPSAiVGltZXMgcGVyIHdlZWsiLCB5bGFiID0gImNvdW50IiwgY29sID0gImdyZXkiLCBib3JkZXI9ICJibGFjayIpDQoNCmhpc3QoZGYkZGVwdmFycyR0aW1lX3J1biwgbWFpbiA9ICJIaXN0b2dyYW0gb2YgUnVubmluZyBWb2x1bWUiLCB4bGFiID0gIiIsIHlsYWIgPSAiY291bnQiLCBjb2wgPSAiZ3JleSIsIGJvcmRlcj0gImJsYWNrIikNCg0KIyBkZXZlbG9wbWVudCBtZWFuIG92ZXIgdGltZQ0KcGxvdF9tZWFuX2ZyZXENCnBsb3RfbWVhbl90aW1lDQpgYGANCg0KIyMjIyBDbHViIDUNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1s1XV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzVdXQ0KDQojIGRldmVsb3BtZW50IG9mIHRoZSBtZWFuIG92ZXIgdGltZQ0KDQojIHJldHJpZXZlIGdlbmRlcg0KbWFsZSA8LSBkZjIkbWFsZQ0KZmVtYWxlIDwtIGRmMiRmZW1hbGUNCm90aGVyIDwtIGRmMiRvdGhlcg0KDQpnZW5kZXIgPC0gTkENCmdlbmRlciA8LSBpZmVsc2UobWFsZSA9PSAxLCAiTWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoZmVtYWxlID09IDEsICJGZW1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKG90aGVyID09IDEsICJPdGhlciIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoaXMubmEoZ2VuZGVyKSwgIk1pc3NpbmciLCBnZW5kZXIpICMgbWlzc2luZyBjYXRlZ29yeQ0KDQoNCiMgY3JlYXRlIHdpZGUgZGF0YWZyYW1lDQogIGRmMmxvbmcgPC0gZGF0YS5mcmFtZSAoDQogICAgaWQgPSAxOmxlbmd0aChkZiRub2RlU2V0cyRBY3RvcnMpLA0KICAgIGdlbmRlciA9IGdlbmRlciwNCiAgICBmcmVxMSA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCwxXSwNCiAgICBmcmVxMiA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCwyXSwNCiAgICBmcmVxMyA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCwzXSwNCiAgICBmcmVxNCA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw0XSwNCiAgICBmcmVxNSA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw1XSwNCiAgICBmcmVxNiA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw2XSwNCiAgICBmcmVxNyA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw3XSwNCiAgICBmcmVxOCA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw4XSwNCiAgICBmcmVxOSA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCw5XSwNCiAgICBmcmVxMTAgPSBkZiRkZXB2YXJzJGZyZXFfcnVuWywsMTBdLA0KICAgIGZyZXExMSA9IGRmJGRlcHZhcnMkZnJlcV9ydW5bLCwxMV0sDQogICAgZnJlcTEyID0gZGYkZGVwdmFycyRmcmVxX3J1blssLDEyXSwNCiAgICB0aW1lMSA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCwxXSwNCiAgICB0aW1lMiA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCwyXSwNCiAgICB0aW1lMyA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCwzXSwNCiAgICB0aW1lNCA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw0XSwNCiAgICB0aW1lNSA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw1XSwNCiAgICB0aW1lNiA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw2XSwNCiAgICB0aW1lNyA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw3XSwNCiAgICB0aW1lOCA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw4XSwNCiAgICB0aW1lOSA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCw5XSwNCiAgICB0aW1lMTAgPSBkZiRkZXB2YXJzJHRpbWVfcnVuWywsMTBdLA0KICAgIHRpbWUxMSA9IGRmJGRlcHZhcnMkdGltZV9ydW5bLCwxMV0sDQogICAgdGltZTEyID0gZGYkZGVwdmFycyR0aW1lX3J1blssLDEyXSkNCg0KIyByZXNoYXBlIHRvIGxvbmcgZGF0YWZyYW1lDQpkZl9sb25nIDwtIHJlc2hhcGUoZGYybG9uZywNCiAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICJsb25nIiwNCiAgICAgICAgICAgICAgICAgICAgIHZhcnlpbmcgPSBjKGxpc3QobmFtZXMoZGYybG9uZylbMzoxNF0pLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdChuYW1lcyhkZjJsb25nKVsxNToyNl0pKSwNCiAgICAgICAgICAgICAgICAgICAgIHYubmFtZXMgPSBjKCJydW5fZnJlcSIsICJydW5fdGltZSIpLA0KICAgICAgICAgICAgICAgICAgICAgaWR2YXIgPSAiaWQiLA0KICAgICAgICAgICAgICAgICAgICAgdGltZXZhciA9ICJ0aW1lIiwNCiAgICAgICAgICAgICAgICAgICAgIHRpbWVzID0gMToxMikNCg0KIyBSZW9yZGVyIGRhdGEgYmFzZWQgb24gdXNlciBpZA0KZGZfbG9uZyAgPC0gZGZfbG9uZyBbKG9yZGVyKGRmX2xvbmckaWQpKSwgXQ0KDQojIGNyZWF0ZSBkYXRhIHRvIHBsb3QsIHNlcGVyYXRlbHkgZm9yIG1lbiBhbmQgd29tZW4NCiBkYXRhX2FsbCA8LSBkZl9sb25nICU+JQ0KICAgIGdyb3VwX2J5KHRpbWUpICU+JQ0KICAgIHN1bW1hcmlzZShtZWFuX2ZyZXEgPSBtZWFuKHJ1bl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgbWVhbl90aW1lID0gbWVhbihydW5fdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNlX2ZyZXEgPSAxLjk2ICogKHNkKHJ1bl9mcmVxLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEocnVuX2ZyZXEpKSkpLA0KICAgICAgICAgICAgICBzZV90aW1lID0gMS45NiAqIChzZChydW5fdGltZSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKHJ1bl90aW1lKSkpKSwNCiAgICAgICAgICAgICAgc2RfZnJlcSA9IHNkKHJ1bl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2RfdGltZSA9IHNkKHJ1bl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgdmFyX2ZyZXEgPSB2YXIocnVuX2ZyZXEsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIHZhcl90aW1lID0gdmFyKHJ1bl90aW1lLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICBrdXJ0b3Npc19mcmVxID0ga3VydG9zaXMocnVuX2ZyZXEsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBrdXJ0b3Npc190aW1lID0ga3VydG9zaXMocnVuX3RpbWUsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBjbGFzcyA9ICJGdWxsIFNhbXBsZSINCiAgICApDQogDQogZGF0YV9tZW4gPC0gZGZfbG9uZ1t3aGljaChkZl9sb25nJGdlbmRlciA9PSAiTWFsZSIpLCBdDQogIGRhdGFfbWVuIDwtIGRhdGFfbWVuICU+JQ0KICAgIGdyb3VwX2J5KHRpbWUpICU+JQ0KICAgIHN1bW1hcmlzZShtZWFuX2ZyZXEgPSBtZWFuKHJ1bl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgbWVhbl90aW1lID0gbWVhbihydW5fdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNlX2ZyZXEgPSAxLjk2ICogKHNkKHJ1bl9mcmVxLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEocnVuX2ZyZXEpKSkpLA0KICAgICAgICAgICAgICBzZV90aW1lID0gMS45NiAqIChzZChydW5fdGltZSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKHJ1bl90aW1lKSkpKSwNCiAgICAgICAgICAgICAgc2RfZnJlcSA9IHNkKHJ1bl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2RfdGltZSA9IHNkKHJ1bl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgdmFyX2ZyZXEgPSB2YXIocnVuX2ZyZXEsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIHZhcl90aW1lID0gdmFyKHJ1bl90aW1lLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICBrdXJ0b3Npc19mcmVxID0ga3VydG9zaXMocnVuX2ZyZXEsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBrdXJ0b3Npc190aW1lID0ga3VydG9zaXMocnVuX3RpbWUsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBjbGFzcyA9ICJNZW4iDQogICAgKQ0KICANCiAgZGF0YV93b21lbiA8LSBkZl9sb25nW3doaWNoKGRmX2xvbmckZ2VuZGVyID09ICJGZW1hbGUiKSwgXQ0KICBkYXRhX3dvbWVuIDwtIGRhdGFfd29tZW4gJT4lDQogICAgZ3JvdXBfYnkodGltZSkgJT4lDQogICAgc3VtbWFyaXNlKG1lYW5fZnJlcSA9IG1lYW4ocnVuX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBtZWFuX3RpbWUgPSBtZWFuKHJ1bl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2VfZnJlcSA9IDEuOTYgKiAoc2QocnVuX2ZyZXEsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShydW5fZnJlcSkpKSksDQogICAgICAgICAgICAgIHNlX3RpbWUgPSAxLjk2ICogKHNkKHJ1bl90aW1lLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEocnVuX3RpbWUpKSkpLA0KICAgICAgICAgICAgICBzZF9mcmVxID0gc2QocnVuX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZF90aW1lID0gc2QocnVuX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICB2YXJfZnJlcSA9IHZhcihydW5fZnJlcSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAgdmFyX3RpbWUgPSB2YXIocnVuX3RpbWUsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIGt1cnRvc2lzX2ZyZXEgPSBrdXJ0b3NpcyhydW5fZnJlcSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGt1cnRvc2lzX3RpbWUgPSBrdXJ0b3NpcyhydW5fdGltZSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGNsYXNzID0gIldvbWVuIg0KICAgICkNCg0KIyBzdGFjayBkYXRhIA0KcGxvdC5kYXRhIDwtIHJiaW5kKGRhdGFfYWxsLCBkYXRhX21lbiwgZGF0YV93b21lbikNCnJtKGRhdGFfYWxsLCBkYXRhX21lbiwgZGF0YV93b21lbikNCg0KIyBhZGQgbW9udGhzDQpwbG90LmRhdGEkbW9udGggPC0gcmVwKGMoIkphbiIsICJGZWIiLCAiTWFyIiwgIkFwciIsICJNYXkiLCAiSnVuIiwgIkp1bCIsICJBdWciLCAiU2VwIiwgIk9jdCIsICJOb3YiLCAiRGVjIiksIDMpDQoNCiMgcGxvdA0KcGxvdF9tZWFuX2ZyZXEgPC0gZ2dwbG90KHBsb3QuZGF0YSwgYWVzKG1vbnRoLCBtZWFuX2ZyZXEsIGdyb3VwID0gY2xhc3MsIGNvbG91ciA9IGNsYXNzKSkgKw0KICAgIGdlb21fcG9pbnQoKSArDQogICAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxvZXNzIiwgc2l6ZT0yKSArDQogICAgZ2VvbV9lcnJvcmJhcihhZXModGltZSwgbWVhbl9mcmVxLCB5bWluID0gbWVhbl9mcmVxIC0gc2VfZnJlcSwgeW1heCA9IG1lYW5fZnJlcSArIHNlX2ZyZXEsDQogICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwLjQpKSArDQogICAgdGhlbWVfYncoYmFzZV9mYW1pbHk9InNlcmlmIiwgYmFzZV9zaXplPTE2KSArDQogICAgc2NhbGVfY29sb3VyX21hbnVhbCh2YWx1ZXM9YygiIzAwMDAwMCIsICIjRTY5RjAwIiwgIiM1NkI0RTkiKSkgKw0KICAgIGxhYnMoeSA9ICJSdW5uaW5nIGZyZXF1ZW5jeSBwZXIgd2VlayIsIHg9Ik1vbnRoIikgKw0KICAgIHNjYWxlX3hfZGlzY3JldGUobGltaXRzPWMoIkphbiIsICJGZWIiLCAiTWFyIiwgIkFwciIsICJNYXkiLCAiSnVuIiwgIkp1bCIsICJBdWciLCAiU2VwIiwgIk9jdCIsICJOb3YiLCAiRGVjIikpICsNCiAgICB5bGltKDAsNSkgKw0KICAgIHRoZW1lKGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KGZhbWlseT0ic2VyaWYiLCBzaXplID0gMTAsIGFuZ2xlID0gNDUsIGhqdXN0ID0gMSksIA0KICAgICAgICAgIGxlZ2VuZC5wb3NpdGlvbiA9ICJyaWdodCIsIGxlZ2VuZC50aXRsZT1lbGVtZW50X2JsYW5rKCkNCiAgICApDQogIA0KICBwbG90X21lYW5fdGltZSA8LSBnZ3Bsb3QocGxvdC5kYXRhLCBhZXMobW9udGgsIG1lYW5fdGltZSwgZ3JvdXAgPSBjbGFzcywgY29sb3VyID0gY2xhc3MpKSArDQogICAgZ2VvbV9wb2ludCgpICsNCiAgICBnZW9tX3Ntb290aChtZXRob2QgPSAibG9lc3MiLCBzaXplPTIpICsNCiAgICBnZW9tX2Vycm9yYmFyKGFlcyh0aW1lLCBtZWFuX3RpbWUsIHltaW4gPSBtZWFuX3RpbWUgLSBzZV90aW1lLCB5bWF4ID0gbWVhbl90aW1lICsgc2VfdGltZSwNCiAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDAuNCkpICsNCiAgICB0aGVtZV9idyhiYXNlX2ZhbWlseT0ic2VyaWYiLCBiYXNlX3NpemU9MTYpICsNCiAgICBzY2FsZV9jb2xvdXJfbWFudWFsKHZhbHVlcz1jKCIjMDAwMDAwIiwgIiNFNjlGMDAiLCAiIzU2QjRFOSIpKSArDQogICAgbGFicyh5ID0gIlJ1bm5pbmcgdm9sdW1lIHBlciBtb250aCIsIHg9Ik1vbnRoIikgKw0KICAgIHNjYWxlX3hfZGlzY3JldGUobGltaXRzPWMoIkphbiIsICJGZWIiLCAiTWFyIiwgIkFwciIsICJNYXkiLCAiSnVuIiwgIkp1bCIsICJBdWciLCAiU2VwIiwgIk9jdCIsICJOb3YiLCAiRGVjIikpICsNCiAgICB5bGltKDAsNykgKw0KICAgIHRoZW1lKGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KGZhbWlseT0ic2VyaWYiLCBzaXplID0gMTAsIGFuZ2xlID0gNDUsIGhqdXN0ID0gMSksIA0KICAgICAgICAgIGxlZ2VuZC5wb3NpdGlvbiA9ICJyaWdodCIsIGxlZ2VuZC50aXRsZT1lbGVtZW50X2JsYW5rKCkNCiAgICApDQoNCiMjIyBPdXRwdXQgIyMjDQoNCiMgaGlzdG9ncmFtIChhc3N1bWluZyBpbmRlcGVuZGVudCBvYnNlcnZhdGlvbnMpDQpoaXN0KGRmJGRlcHZhcnMkZnJlcV9ydW4sIG1haW4gPSAiSGlzdG9ncmFtIG9mIFJ1bm5pbmcgRnJlcXVlbmN5IiwgeGxhYiA9ICJUaW1lcyBwZXIgd2VlayIsIHlsYWIgPSAiY291bnQiLCBjb2wgPSAiZ3JleSIsIGJvcmRlcj0gImJsYWNrIikNCg0KaGlzdChkZiRkZXB2YXJzJHRpbWVfcnVuLCBtYWluID0gIkhpc3RvZ3JhbSBvZiBSdW5uaW5nIFZvbHVtZSIsIHhsYWIgPSAiIiwgeWxhYiA9ICJjb3VudCIsIGNvbCA9ICJncmV5IiwgYm9yZGVyPSAiYmxhY2siKQ0KDQojIGRldmVsb3BtZW50IG1lYW4gb3ZlciB0aW1lDQpwbG90X21lYW5fZnJlcQ0KcGxvdF9tZWFuX3RpbWUNCmBgYA0KDQojIyMgey19DQoNCi0tLS0NCg0KIyMjIDIuIE90aGVyIGFjdGl2aXRpZXMgey50YWJzZXQgLnRhYnNldC1mYWRlfQ0KDQpXZSB3aWxsIGRlc2NyaWJlIG90aGVyIGFjdGl2aXRpZXMgYXMgd2VsbCAoZS5nLiwgY3ljbGluZyBhbmQgc3dpbW1pbmcpLg0KDQojIyMjIENsdWIgMQ0KYGBge3IgY2xhc3Muc291cmNlID0gJ2ZvbGQtaGlkZSd9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFbWzFdXSAjIGdyYWIgY2x1YiANCmRmMiA8LSBjbHViZGF0YVtbMV1dDQoNCiMgZGV2ZWxvcG1lbnQgb2YgdGhlIG1lYW4gb3ZlciB0aW1lDQoNCiMgcmV0cmlldmUgZ2VuZGVyDQptYWxlIDwtIGRmMiRtYWxlDQpmZW1hbGUgPC0gZGYyJGZlbWFsZQ0Kb3RoZXIgPC0gZGYyJG90aGVyDQoNCmdlbmRlciA8LSBOQQ0KZ2VuZGVyIDwtIGlmZWxzZShtYWxlID09IDEsICJNYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShmZW1hbGUgPT0gMSwgIkZlbWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2Uob3RoZXIgPT0gMSwgIk90aGVyIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShpcy5uYShnZW5kZXIpLCAiTWlzc2luZyIsIGdlbmRlcikgIyBtaXNzaW5nIGNhdGVnb3J5DQoNCiMgY3JlYXRlIHdpZGUgZGF0YWZyYW1lDQogIGRmMmxvbmcgPC0gZGF0YS5mcmFtZSAoDQogICAgaWQgPSAxOmxlbmd0aChkZiRub2RlU2V0cyRBY3RvcnMpLA0KICAgIGdlbmRlciA9IGdlbmRlciwNCiAgICBmcmVxMSA9IGRmMiRmcmVxX290aGVyWywsMV0sDQogICAgZnJlcTIgPSBkZjIkZnJlcV9vdGhlclssLDJdLA0KICAgIGZyZXEzID0gZGYyJGZyZXFfb3RoZXJbLCwzXSwNCiAgICBmcmVxNCA9IGRmMiRmcmVxX290aGVyWywsNF0sDQogICAgZnJlcTUgPSBkZjIkZnJlcV9vdGhlclssLDVdLA0KICAgIGZyZXE2ID0gZGYyJGZyZXFfb3RoZXJbLCw2XSwNCiAgICBmcmVxNyA9IGRmMiRmcmVxX290aGVyWywsN10sDQogICAgZnJlcTggPSBkZjIkZnJlcV9vdGhlclssLDhdLA0KICAgIGZyZXE5ID0gZGYyJGZyZXFfb3RoZXJbLCw5XSwNCiAgICBmcmVxMTAgPSBkZjIkZnJlcV9vdGhlclssLDEwXSwNCiAgICBmcmVxMTEgPSBkZjIkZnJlcV9vdGhlclssLDExXSwNCiAgICBmcmVxMTIgPSBkZjIkZnJlcV9vdGhlclssLDEyXSwNCiAgICB0aW1lMSA9IGRmMiR0aW1lX290aGVyWywsMV0sDQogICAgdGltZTIgPSBkZjIkdGltZV9vdGhlclssLDJdLA0KICAgIHRpbWUzID0gZGYyJHRpbWVfb3RoZXJbLCwzXSwNCiAgICB0aW1lNCA9IGRmMiR0aW1lX290aGVyWywsNF0sDQogICAgdGltZTUgPSBkZjIkdGltZV9vdGhlclssLDVdLA0KICAgIHRpbWU2ID0gZGYyJHRpbWVfb3RoZXJbLCw2XSwNCiAgICB0aW1lNyA9IGRmMiR0aW1lX290aGVyWywsN10sDQogICAgdGltZTggPSBkZjIkdGltZV9vdGhlclssLDhdLA0KICAgIHRpbWU5ID0gZGYyJHRpbWVfb3RoZXJbLCw5XSwNCiAgICB0aW1lMTAgPSBkZjIkdGltZV9vdGhlclssLDEwXSwNCiAgICB0aW1lMTEgPSBkZjIkdGltZV9vdGhlclssLDExXSwNCiAgICB0aW1lMTIgPSBkZjIkdGltZV9vdGhlclssLDEyXSkNCg0KIyByZXNoYXBlIHRvIGxvbmcgZGF0YWZyYW1lDQpkZl9sb25nIDwtIHJlc2hhcGUoZGYybG9uZywNCiAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICJsb25nIiwNCiAgICAgICAgICAgICAgICAgICAgIHZhcnlpbmcgPSBjKGxpc3QobmFtZXMoZGYybG9uZylbMzoxNF0pLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdChuYW1lcyhkZjJsb25nKVsxNToyNl0pKSwNCiAgICAgICAgICAgICAgICAgICAgIHYubmFtZXMgPSBjKCJvdGhlcl9mcmVxIiwgIm90aGVyX3RpbWUiKSwNCiAgICAgICAgICAgICAgICAgICAgIGlkdmFyID0gImlkIiwNCiAgICAgICAgICAgICAgICAgICAgIHRpbWV2YXIgPSAidGltZSIsDQogICAgICAgICAgICAgICAgICAgICB0aW1lcyA9IDE6MTIpDQoNCiMgUmVvcmRlciBkYXRhIGJhc2VkIG9uIHVzZXIgaWQNCmRmX2xvbmcgIDwtIGRmX2xvbmcgWyhvcmRlcihkZl9sb25nJGlkKSksIF0NCg0KIyBjcmVhdGUgZGF0YSB0byBwbG90LCBzZXBlcmF0ZWx5IGZvciBtZW4gYW5kIHdvbWVuDQogZGF0YV9hbGwgPC0gZGZfbG9uZyAlPiUNCiAgICBncm91cF9ieSh0aW1lKSAlPiUNCiAgICBzdW1tYXJpc2UobWVhbl9mcmVxID0gbWVhbihvdGhlcl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgbWVhbl90aW1lID0gbWVhbihvdGhlcl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2VfZnJlcSA9IDEuOTYgKiAoc2Qob3RoZXJfZnJlcSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKG90aGVyX2ZyZXEpKSkpLA0KICAgICAgICAgICAgICBzZV90aW1lID0gMS45NiAqIChzZChvdGhlcl90aW1lLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEob3RoZXJfdGltZSkpKSksDQogICAgICAgICAgICAgIHNkX2ZyZXEgPSBzZChvdGhlcl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2RfdGltZSA9IHNkKG90aGVyX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICB2YXJfZnJlcSA9IHZhcihvdGhlcl9mcmVxLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICB2YXJfdGltZSA9IHZhcihvdGhlcl90aW1lLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICBrdXJ0b3Npc19mcmVxID0ga3VydG9zaXMob3RoZXJfZnJlcSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGt1cnRvc2lzX3RpbWUgPSBrdXJ0b3NpcyhvdGhlcl90aW1lLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAgY2xhc3MgPSAiRnVsbCBTYW1wbGUiDQogICAgKQ0KIA0KIGRhdGFfbWVuIDwtIGRmX2xvbmdbd2hpY2goZGZfbG9uZyRnZW5kZXIgPT0gIk1hbGUiKSwgXQ0KICBkYXRhX21lbiA8LSBkYXRhX21lbiAlPiUNCiAgICBncm91cF9ieSh0aW1lKSAlPiUNCiAgICBzdW1tYXJpc2UobWVhbl9mcmVxID0gbWVhbihvdGhlcl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgbWVhbl90aW1lID0gbWVhbihvdGhlcl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2VfZnJlcSA9IDEuOTYgKiAoc2Qob3RoZXJfZnJlcSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKG90aGVyX2ZyZXEpKSkpLA0KICAgICAgICAgICAgICBzZV90aW1lID0gMS45NiAqIChzZChvdGhlcl90aW1lLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEob3RoZXJfdGltZSkpKSksDQogICAgICAgICAgICAgIHNkX2ZyZXEgPSBzZChvdGhlcl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2RfdGltZSA9IHNkKG90aGVyX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICB2YXJfZnJlcSA9IHZhcihvdGhlcl9mcmVxLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICB2YXJfdGltZSA9IHZhcihvdGhlcl90aW1lLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICBrdXJ0b3Npc19mcmVxID0ga3VydG9zaXMob3RoZXJfZnJlcSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGt1cnRvc2lzX3RpbWUgPSBrdXJ0b3NpcyhvdGhlcl90aW1lLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAgY2xhc3MgPSAiTWVuIg0KICAgICkNCiAgDQogIGRhdGFfd29tZW4gPC0gZGZfbG9uZ1t3aGljaChkZl9sb25nJGdlbmRlciA9PSAiRmVtYWxlIiksIF0NCiAgZGF0YV93b21lbiA8LSBkYXRhX3dvbWVuICU+JQ0KICAgIGdyb3VwX2J5KHRpbWUpICU+JQ0KICAgIHN1bW1hcmlzZShtZWFuX2ZyZXEgPSBtZWFuKG90aGVyX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBtZWFuX3RpbWUgPSBtZWFuKG90aGVyX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZV9mcmVxID0gMS45NiAqIChzZChvdGhlcl9mcmVxLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEob3RoZXJfZnJlcSkpKSksDQogICAgICAgICAgICAgIHNlX3RpbWUgPSAxLjk2ICogKHNkKG90aGVyX3RpbWUsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShvdGhlcl90aW1lKSkpKSwNCiAgICAgICAgICAgICAgc2RfZnJlcSA9IHNkKG90aGVyX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZF90aW1lID0gc2Qob3RoZXJfdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHZhcl9mcmVxID0gdmFyKG90aGVyX2ZyZXEsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIHZhcl90aW1lID0gdmFyKG90aGVyX3RpbWUsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIGt1cnRvc2lzX2ZyZXEgPSBrdXJ0b3NpcyhvdGhlcl9mcmVxLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAga3VydG9zaXNfdGltZSA9IGt1cnRvc2lzKG90aGVyX3RpbWUsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBjbGFzcyA9ICJXb21lbiINCiAgICApDQoNCiMgc3RhY2sgZGF0YSANCnBsb3QuZGF0YSA8LSByYmluZChkYXRhX2FsbCwgZGF0YV9tZW4sIGRhdGFfd29tZW4pDQpybShkYXRhX2FsbCwgZGF0YV9tZW4sIGRhdGFfd29tZW4pDQoNCiMgYWRkIG1vbnRocw0KcGxvdC5kYXRhJG1vbnRoIDwtIHJlcChjKCJKYW4iLCAiRmViIiwgIk1hciIsICJBcHIiLCAiTWF5IiwgIkp1biIsICJKdWwiLCAiQXVnIiwgIlNlcCIsICJPY3QiLCAiTm92IiwgIkRlYyIpLCAzKQ0KDQojIHBsb3QNCnBsb3RfbWVhbl9mcmVxIDwtIGdncGxvdChwbG90LmRhdGEsIGFlcyhtb250aCwgbWVhbl9mcmVxLCBncm91cCA9IGNsYXNzLCBjb2xvdXIgPSBjbGFzcykpICsNCiAgICBnZW9tX3BvaW50KCkgKw0KICAgIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsb2VzcyIsIHNpemU9MikgKw0KICAgIGdlb21fZXJyb3JiYXIoYWVzKHRpbWUsIG1lYW5fZnJlcSwgeW1pbiA9IG1lYW5fZnJlcSAtIHNlX2ZyZXEsIHltYXggPSBtZWFuX2ZyZXEgKyBzZV9mcmVxLA0KICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMC40KSkgKw0KICAgIHRoZW1lX2J3KGJhc2VfZmFtaWx5PSJzZXJpZiIsIGJhc2Vfc2l6ZT0xNikgKw0KICAgIHNjYWxlX2NvbG91cl9tYW51YWwodmFsdWVzPWMoIiMwMDAwMDAiLCAiI0U2OUYwMCIsICIjNTZCNEU5IikpICsNCiAgICBsYWJzKHkgPSAiT3RoZXIgZnJlcXVlbmN5IHBlciB3ZWVrIiwgeD0iTW9udGgiKSArDQogICAgc2NhbGVfeF9kaXNjcmV0ZShsaW1pdHM9YygiSmFuIiwgIkZlYiIsICJNYXIiLCAiQXByIiwgIk1heSIsICJKdW4iLCAiSnVsIiwgIkF1ZyIsICJTZXAiLCAiT2N0IiwgIk5vdiIsICJEZWMiKSkgKw0KICAgIHlsaW0oMCw1KSArDQogICAgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoZmFtaWx5PSJzZXJpZiIsIHNpemUgPSAxMCwgYW5nbGUgPSA0NSwgaGp1c3QgPSAxKSwgDQogICAgICAgICAgbGVnZW5kLnBvc2l0aW9uID0gInJpZ2h0IiwgbGVnZW5kLnRpdGxlPWVsZW1lbnRfYmxhbmsoKQ0KICAgICkNCiAgDQogIHBsb3RfbWVhbl90aW1lIDwtIGdncGxvdChwbG90LmRhdGEsIGFlcyhtb250aCwgbWVhbl90aW1lLCBncm91cCA9IGNsYXNzLCBjb2xvdXIgPSBjbGFzcykpICsNCiAgICBnZW9tX3BvaW50KCkgKw0KICAgIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsb2VzcyIsIHNpemU9MikgKw0KICAgIGdlb21fZXJyb3JiYXIoYWVzKHRpbWUsIG1lYW5fdGltZSwgeW1pbiA9IG1lYW5fdGltZSAtIHNlX3RpbWUsIHltYXggPSBtZWFuX3RpbWUgKyBzZV90aW1lLA0KICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMC40KSkgKw0KICAgIHRoZW1lX2J3KGJhc2VfZmFtaWx5PSJzZXJpZiIsIGJhc2Vfc2l6ZT0xNikgKw0KICAgIHNjYWxlX2NvbG91cl9tYW51YWwodmFsdWVzPWMoIiMwMDAwMDAiLCAiI0U2OUYwMCIsICIjNTZCNEU5IikpICsNCiAgICBsYWJzKHkgPSAiT3RoZXIgdm9sdW1lIHBlciBtb250aCIsIHg9Ik1vbnRoIikgKw0KICAgIHNjYWxlX3hfZGlzY3JldGUobGltaXRzPWMoIkphbiIsICJGZWIiLCAiTWFyIiwgIkFwciIsICJNYXkiLCAiSnVuIiwgIkp1bCIsICJBdWciLCAiU2VwIiwgIk9jdCIsICJOb3YiLCAiRGVjIikpICsNCiAgICB5bGltKDAsNykgKw0KICAgIHRoZW1lKGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KGZhbWlseT0ic2VyaWYiLCBzaXplID0gMTAsIGFuZ2xlID0gNDUsIGhqdXN0ID0gMSksIA0KICAgICAgICAgIGxlZ2VuZC5wb3NpdGlvbiA9ICJyaWdodCIsIGxlZ2VuZC50aXRsZT1lbGVtZW50X2JsYW5rKCkNCiAgICApDQoNCiMjIyBPdXRwdXQgIyMjDQoNCiMgaGlzdG9ncmFtIChhc3N1bWluZyBpbmRlcGVuZGVudCBvYnNlcnZhdGlvbnMpDQpoaXN0KGRmJHZDb3ZhciRmcmVxX290aGVyLCBtYWluID0gIkhpc3RvZ3JhbSBvZiBPdGhlciBGcmVxdWVuY3kiLCB4bGFiID0gIlRpbWVzIHBlciB3ZWVrIiwgeWxhYiA9ICJjb3VudCIsIGNvbCA9ICJncmV5IiwgYm9yZGVyPSAiYmxhY2siKQ0KDQpoaXN0KGRmJHZDb3ZhciR0aW1lX290aGVyLCBtYWluID0gIkhpc3RvZ3JhbSBvZiBPdGhlciBWb2x1bWUiLCB4bGFiID0gIiIsIHlsYWIgPSAiY291bnQiLCBjb2wgPSAiZ3JleSIsIGJvcmRlcj0gImJsYWNrIikNCg0KIyBkZXZlbG9wbWVudCBtZWFuIG92ZXIgdGltZQ0KcGxvdF9tZWFuX2ZyZXENCnBsb3RfbWVhbl90aW1lDQpgYGANCg0KIyMjIyBDbHViIDINCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1syXV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzJdXQ0KDQojIGRldmVsb3BtZW50IG9mIHRoZSBtZWFuIG92ZXIgdGltZQ0KDQojIHJldHJpZXZlIGdlbmRlcg0KbWFsZSA8LSBkZjIkbWFsZQ0KZmVtYWxlIDwtIGRmMiRmZW1hbGUNCm90aGVyIDwtIGRmMiRvdGhlcg0KDQpnZW5kZXIgPC0gTkENCmdlbmRlciA8LSBpZmVsc2UobWFsZSA9PSAxLCAiTWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoZmVtYWxlID09IDEsICJGZW1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKG90aGVyID09IDEsICJPdGhlciIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoaXMubmEoZ2VuZGVyKSwgIk1pc3NpbmciLCBnZW5kZXIpICMgbWlzc2luZyBjYXRlZ29yeQ0KDQojIGNyZWF0ZSB3aWRlIGRhdGFmcmFtZQ0KICBkZjJsb25nIDwtIGRhdGEuZnJhbWUgKA0KICAgIGlkID0gMTpsZW5ndGgoZGYkbm9kZVNldHMkQWN0b3JzKSwNCiAgICBnZW5kZXIgPSBnZW5kZXIsDQogICAgZnJlcTEgPSBkZjIkZnJlcV9vdGhlclssLDFdLA0KICAgIGZyZXEyID0gZGYyJGZyZXFfb3RoZXJbLCwyXSwNCiAgICBmcmVxMyA9IGRmMiRmcmVxX290aGVyWywsM10sDQogICAgZnJlcTQgPSBkZjIkZnJlcV9vdGhlclssLDRdLA0KICAgIGZyZXE1ID0gZGYyJGZyZXFfb3RoZXJbLCw1XSwNCiAgICBmcmVxNiA9IGRmMiRmcmVxX290aGVyWywsNl0sDQogICAgZnJlcTcgPSBkZjIkZnJlcV9vdGhlclssLDddLA0KICAgIGZyZXE4ID0gZGYyJGZyZXFfb3RoZXJbLCw4XSwNCiAgICBmcmVxOSA9IGRmMiRmcmVxX290aGVyWywsOV0sDQogICAgZnJlcTEwID0gZGYyJGZyZXFfb3RoZXJbLCwxMF0sDQogICAgZnJlcTExID0gZGYyJGZyZXFfb3RoZXJbLCwxMV0sDQogICAgZnJlcTEyID0gZGYyJGZyZXFfb3RoZXJbLCwxMl0sDQogICAgdGltZTEgPSBkZjIkdGltZV9vdGhlclssLDFdLA0KICAgIHRpbWUyID0gZGYyJHRpbWVfb3RoZXJbLCwyXSwNCiAgICB0aW1lMyA9IGRmMiR0aW1lX290aGVyWywsM10sDQogICAgdGltZTQgPSBkZjIkdGltZV9vdGhlclssLDRdLA0KICAgIHRpbWU1ID0gZGYyJHRpbWVfb3RoZXJbLCw1XSwNCiAgICB0aW1lNiA9IGRmMiR0aW1lX290aGVyWywsNl0sDQogICAgdGltZTcgPSBkZjIkdGltZV9vdGhlclssLDddLA0KICAgIHRpbWU4ID0gZGYyJHRpbWVfb3RoZXJbLCw4XSwNCiAgICB0aW1lOSA9IGRmMiR0aW1lX290aGVyWywsOV0sDQogICAgdGltZTEwID0gZGYyJHRpbWVfb3RoZXJbLCwxMF0sDQogICAgdGltZTExID0gZGYyJHRpbWVfb3RoZXJbLCwxMV0sDQogICAgdGltZTEyID0gZGYyJHRpbWVfb3RoZXJbLCwxMl0pDQoNCiMgcmVzaGFwZSB0byBsb25nIGRhdGFmcmFtZQ0KZGZfbG9uZyA8LSByZXNoYXBlKGRmMmxvbmcsDQogICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAibG9uZyIsDQogICAgICAgICAgICAgICAgICAgICB2YXJ5aW5nID0gYyhsaXN0KG5hbWVzKGRmMmxvbmcpWzM6MTRdKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QobmFtZXMoZGYybG9uZylbMTU6MjZdKSksDQogICAgICAgICAgICAgICAgICAgICB2Lm5hbWVzID0gYygib3RoZXJfZnJlcSIsICJvdGhlcl90aW1lIiksDQogICAgICAgICAgICAgICAgICAgICBpZHZhciA9ICJpZCIsDQogICAgICAgICAgICAgICAgICAgICB0aW1ldmFyID0gInRpbWUiLA0KICAgICAgICAgICAgICAgICAgICAgdGltZXMgPSAxOjEyKQ0KDQojIFJlb3JkZXIgZGF0YSBiYXNlZCBvbiB1c2VyIGlkDQpkZl9sb25nICA8LSBkZl9sb25nIFsob3JkZXIoZGZfbG9uZyRpZCkpLCBdDQoNCiMgY3JlYXRlIGRhdGEgdG8gcGxvdCwgc2VwZXJhdGVseSBmb3IgbWVuIGFuZCB3b21lbg0KIGRhdGFfYWxsIDwtIGRmX2xvbmcgJT4lDQogICAgZ3JvdXBfYnkodGltZSkgJT4lDQogICAgc3VtbWFyaXNlKG1lYW5fZnJlcSA9IG1lYW4ob3RoZXJfZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIG1lYW5fdGltZSA9IG1lYW4ob3RoZXJfdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNlX2ZyZXEgPSAxLjk2ICogKHNkKG90aGVyX2ZyZXEsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShvdGhlcl9mcmVxKSkpKSwNCiAgICAgICAgICAgICAgc2VfdGltZSA9IDEuOTYgKiAoc2Qob3RoZXJfdGltZSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKG90aGVyX3RpbWUpKSkpLA0KICAgICAgICAgICAgICBzZF9mcmVxID0gc2Qob3RoZXJfZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNkX3RpbWUgPSBzZChvdGhlcl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgdmFyX2ZyZXEgPSB2YXIob3RoZXJfZnJlcSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAgdmFyX3RpbWUgPSB2YXIob3RoZXJfdGltZSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAga3VydG9zaXNfZnJlcSA9IGt1cnRvc2lzKG90aGVyX2ZyZXEsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBrdXJ0b3Npc190aW1lID0ga3VydG9zaXMob3RoZXJfdGltZSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGNsYXNzID0gIkZ1bGwgU2FtcGxlIg0KICAgICkNCiANCiBkYXRhX21lbiA8LSBkZl9sb25nW3doaWNoKGRmX2xvbmckZ2VuZGVyID09ICJNYWxlIiksIF0NCiAgZGF0YV9tZW4gPC0gZGF0YV9tZW4gJT4lDQogICAgZ3JvdXBfYnkodGltZSkgJT4lDQogICAgc3VtbWFyaXNlKG1lYW5fZnJlcSA9IG1lYW4ob3RoZXJfZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIG1lYW5fdGltZSA9IG1lYW4ob3RoZXJfdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNlX2ZyZXEgPSAxLjk2ICogKHNkKG90aGVyX2ZyZXEsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShvdGhlcl9mcmVxKSkpKSwNCiAgICAgICAgICAgICAgc2VfdGltZSA9IDEuOTYgKiAoc2Qob3RoZXJfdGltZSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKG90aGVyX3RpbWUpKSkpLA0KICAgICAgICAgICAgICBzZF9mcmVxID0gc2Qob3RoZXJfZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNkX3RpbWUgPSBzZChvdGhlcl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgdmFyX2ZyZXEgPSB2YXIob3RoZXJfZnJlcSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAgdmFyX3RpbWUgPSB2YXIob3RoZXJfdGltZSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAga3VydG9zaXNfZnJlcSA9IGt1cnRvc2lzKG90aGVyX2ZyZXEsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBrdXJ0b3Npc190aW1lID0ga3VydG9zaXMob3RoZXJfdGltZSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGNsYXNzID0gIk1lbiINCiAgICApDQogIA0KICBkYXRhX3dvbWVuIDwtIGRmX2xvbmdbd2hpY2goZGZfbG9uZyRnZW5kZXIgPT0gIkZlbWFsZSIpLCBdDQogIGRhdGFfd29tZW4gPC0gZGF0YV93b21lbiAlPiUNCiAgICBncm91cF9ieSh0aW1lKSAlPiUNCiAgICBzdW1tYXJpc2UobWVhbl9mcmVxID0gbWVhbihvdGhlcl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgbWVhbl90aW1lID0gbWVhbihvdGhlcl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2VfZnJlcSA9IDEuOTYgKiAoc2Qob3RoZXJfZnJlcSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKG90aGVyX2ZyZXEpKSkpLA0KICAgICAgICAgICAgICBzZV90aW1lID0gMS45NiAqIChzZChvdGhlcl90aW1lLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEob3RoZXJfdGltZSkpKSksDQogICAgICAgICAgICAgIHNkX2ZyZXEgPSBzZChvdGhlcl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2RfdGltZSA9IHNkKG90aGVyX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICB2YXJfZnJlcSA9IHZhcihvdGhlcl9mcmVxLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICB2YXJfdGltZSA9IHZhcihvdGhlcl90aW1lLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICBrdXJ0b3Npc19mcmVxID0ga3VydG9zaXMob3RoZXJfZnJlcSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGt1cnRvc2lzX3RpbWUgPSBrdXJ0b3NpcyhvdGhlcl90aW1lLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAgY2xhc3MgPSAiV29tZW4iDQogICAgKQ0KDQojIHN0YWNrIGRhdGEgDQpwbG90LmRhdGEgPC0gcmJpbmQoZGF0YV9hbGwsIGRhdGFfbWVuLCBkYXRhX3dvbWVuKQ0Kcm0oZGF0YV9hbGwsIGRhdGFfbWVuLCBkYXRhX3dvbWVuKQ0KDQojIGFkZCBtb250aHMNCnBsb3QuZGF0YSRtb250aCA8LSByZXAoYygiSmFuIiwgIkZlYiIsICJNYXIiLCAiQXByIiwgIk1heSIsICJKdW4iLCAiSnVsIiwgIkF1ZyIsICJTZXAiLCAiT2N0IiwgIk5vdiIsICJEZWMiKSwgMykNCg0KIyBwbG90DQpwbG90X21lYW5fZnJlcSA8LSBnZ3Bsb3QocGxvdC5kYXRhLCBhZXMobW9udGgsIG1lYW5fZnJlcSwgZ3JvdXAgPSBjbGFzcywgY29sb3VyID0gY2xhc3MpKSArDQogICAgZ2VvbV9wb2ludCgpICsNCiAgICBnZW9tX3Ntb290aChtZXRob2QgPSAibG9lc3MiLCBzaXplPTIpICsNCiAgICBnZW9tX2Vycm9yYmFyKGFlcyh0aW1lLCBtZWFuX2ZyZXEsIHltaW4gPSBtZWFuX2ZyZXEgLSBzZV9mcmVxLCB5bWF4ID0gbWVhbl9mcmVxICsgc2VfZnJlcSwNCiAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDAuNCkpICsNCiAgICB0aGVtZV9idyhiYXNlX2ZhbWlseT0ic2VyaWYiLCBiYXNlX3NpemU9MTYpICsNCiAgICBzY2FsZV9jb2xvdXJfbWFudWFsKHZhbHVlcz1jKCIjMDAwMDAwIiwgIiNFNjlGMDAiLCAiIzU2QjRFOSIpKSArDQogICAgbGFicyh5ID0gIk90aGVyIGZyZXF1ZW5jeSBwZXIgd2VlayIsIHg9Ik1vbnRoIikgKw0KICAgIHNjYWxlX3hfZGlzY3JldGUobGltaXRzPWMoIkphbiIsICJGZWIiLCAiTWFyIiwgIkFwciIsICJNYXkiLCAiSnVuIiwgIkp1bCIsICJBdWciLCAiU2VwIiwgIk9jdCIsICJOb3YiLCAiRGVjIikpICsNCiAgICB5bGltKDAsNSkgKw0KICAgIHRoZW1lKGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KGZhbWlseT0ic2VyaWYiLCBzaXplID0gMTAsIGFuZ2xlID0gNDUsIGhqdXN0ID0gMSksIA0KICAgICAgICAgIGxlZ2VuZC5wb3NpdGlvbiA9ICJyaWdodCIsIGxlZ2VuZC50aXRsZT1lbGVtZW50X2JsYW5rKCkNCiAgICApDQogIA0KICBwbG90X21lYW5fdGltZSA8LSBnZ3Bsb3QocGxvdC5kYXRhLCBhZXMobW9udGgsIG1lYW5fdGltZSwgZ3JvdXAgPSBjbGFzcywgY29sb3VyID0gY2xhc3MpKSArDQogICAgZ2VvbV9wb2ludCgpICsNCiAgICBnZW9tX3Ntb290aChtZXRob2QgPSAibG9lc3MiLCBzaXplPTIpICsNCiAgICBnZW9tX2Vycm9yYmFyKGFlcyh0aW1lLCBtZWFuX3RpbWUsIHltaW4gPSBtZWFuX3RpbWUgLSBzZV90aW1lLCB5bWF4ID0gbWVhbl90aW1lICsgc2VfdGltZSwNCiAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDAuNCkpICsNCiAgICB0aGVtZV9idyhiYXNlX2ZhbWlseT0ic2VyaWYiLCBiYXNlX3NpemU9MTYpICsNCiAgICBzY2FsZV9jb2xvdXJfbWFudWFsKHZhbHVlcz1jKCIjMDAwMDAwIiwgIiNFNjlGMDAiLCAiIzU2QjRFOSIpKSArDQogICAgbGFicyh5ID0gIk90aGVyIHZvbHVtZSBwZXIgbW9udGgiLCB4PSJNb250aCIpICsNCiAgICBzY2FsZV94X2Rpc2NyZXRlKGxpbWl0cz1jKCJKYW4iLCAiRmViIiwgIk1hciIsICJBcHIiLCAiTWF5IiwgIkp1biIsICJKdWwiLCAiQXVnIiwgIlNlcCIsICJPY3QiLCAiTm92IiwgIkRlYyIpKSArDQogICAgeWxpbSgwLDcpICsNCiAgICB0aGVtZShheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChmYW1pbHk9InNlcmlmIiwgc2l6ZSA9IDEwLCBhbmdsZSA9IDQ1LCBoanVzdCA9IDEpLCANCiAgICAgICAgICBsZWdlbmQucG9zaXRpb24gPSAicmlnaHQiLCBsZWdlbmQudGl0bGU9ZWxlbWVudF9ibGFuaygpDQogICAgKQ0KDQojIyMgT3V0cHV0ICMjIw0KDQojIGhpc3RvZ3JhbSAoYXNzdW1pbmcgaW5kZXBlbmRlbnQgb2JzZXJ2YXRpb25zKQ0KaGlzdChkZiR2Q292YXIkZnJlcV9vdGhlciwgbWFpbiA9ICJIaXN0b2dyYW0gb2YgT3RoZXIgRnJlcXVlbmN5IiwgeGxhYiA9ICJUaW1lcyBwZXIgd2VlayIsIHlsYWIgPSAiY291bnQiLCBjb2wgPSAiZ3JleSIsIGJvcmRlcj0gImJsYWNrIikNCg0KaGlzdChkZiR2Q292YXIkdGltZV9vdGhlciwgbWFpbiA9ICJIaXN0b2dyYW0gb2YgT3RoZXIgVm9sdW1lIiwgeGxhYiA9ICIiLCB5bGFiID0gImNvdW50IiwgY29sID0gImdyZXkiLCBib3JkZXI9ICJibGFjayIpDQoNCiMgZGV2ZWxvcG1lbnQgbWVhbiBvdmVyIHRpbWUNCnBsb3RfbWVhbl9mcmVxDQpwbG90X21lYW5fdGltZQ0KYGBgDQoNCiMjIyMgQ2x1YiAzDQpgYGB7ciBjbGFzcy5zb3VyY2UgPSAnZm9sZC1oaWRlJ30NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYVtbM11dICMgZ3JhYiBjbHViIA0KZGYyIDwtIGNsdWJkYXRhW1szXV0NCg0KIyBkZXZlbG9wbWVudCBvZiB0aGUgbWVhbiBvdmVyIHRpbWUNCg0KIyByZXRyaWV2ZSBnZW5kZXINCm1hbGUgPC0gZGYyJG1hbGUNCmZlbWFsZSA8LSBkZjIkZmVtYWxlDQpvdGhlciA8LSBkZjIkb3RoZXINCg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBjcmVhdGUgd2lkZSBkYXRhZnJhbWUNCiAgZGYybG9uZyA8LSBkYXRhLmZyYW1lICgNCiAgICBpZCA9IDE6bGVuZ3RoKGRmJG5vZGVTZXRzJEFjdG9ycyksDQogICAgZ2VuZGVyID0gZ2VuZGVyLA0KICAgIGZyZXExID0gZGYyJGZyZXFfb3RoZXJbLCwxXSwNCiAgICBmcmVxMiA9IGRmMiRmcmVxX290aGVyWywsMl0sDQogICAgZnJlcTMgPSBkZjIkZnJlcV9vdGhlclssLDNdLA0KICAgIGZyZXE0ID0gZGYyJGZyZXFfb3RoZXJbLCw0XSwNCiAgICBmcmVxNSA9IGRmMiRmcmVxX290aGVyWywsNV0sDQogICAgZnJlcTYgPSBkZjIkZnJlcV9vdGhlclssLDZdLA0KICAgIGZyZXE3ID0gZGYyJGZyZXFfb3RoZXJbLCw3XSwNCiAgICBmcmVxOCA9IGRmMiRmcmVxX290aGVyWywsOF0sDQogICAgZnJlcTkgPSBkZjIkZnJlcV9vdGhlclssLDldLA0KICAgIGZyZXExMCA9IGRmMiRmcmVxX290aGVyWywsMTBdLA0KICAgIGZyZXExMSA9IGRmMiRmcmVxX290aGVyWywsMTFdLA0KICAgIGZyZXExMiA9IGRmMiRmcmVxX290aGVyWywsMTJdLA0KICAgIHRpbWUxID0gZGYyJHRpbWVfb3RoZXJbLCwxXSwNCiAgICB0aW1lMiA9IGRmMiR0aW1lX290aGVyWywsMl0sDQogICAgdGltZTMgPSBkZjIkdGltZV9vdGhlclssLDNdLA0KICAgIHRpbWU0ID0gZGYyJHRpbWVfb3RoZXJbLCw0XSwNCiAgICB0aW1lNSA9IGRmMiR0aW1lX290aGVyWywsNV0sDQogICAgdGltZTYgPSBkZjIkdGltZV9vdGhlclssLDZdLA0KICAgIHRpbWU3ID0gZGYyJHRpbWVfb3RoZXJbLCw3XSwNCiAgICB0aW1lOCA9IGRmMiR0aW1lX290aGVyWywsOF0sDQogICAgdGltZTkgPSBkZjIkdGltZV9vdGhlclssLDldLA0KICAgIHRpbWUxMCA9IGRmMiR0aW1lX290aGVyWywsMTBdLA0KICAgIHRpbWUxMSA9IGRmMiR0aW1lX290aGVyWywsMTFdLA0KICAgIHRpbWUxMiA9IGRmMiR0aW1lX290aGVyWywsMTJdKQ0KDQojIHJlc2hhcGUgdG8gbG9uZyBkYXRhZnJhbWUNCmRmX2xvbmcgPC0gcmVzaGFwZShkZjJsb25nLA0KICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gImxvbmciLA0KICAgICAgICAgICAgICAgICAgICAgdmFyeWluZyA9IGMobGlzdChuYW1lcyhkZjJsb25nKVszOjE0XSksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0KG5hbWVzKGRmMmxvbmcpWzE1OjI2XSkpLA0KICAgICAgICAgICAgICAgICAgICAgdi5uYW1lcyA9IGMoIm90aGVyX2ZyZXEiLCAib3RoZXJfdGltZSIpLA0KICAgICAgICAgICAgICAgICAgICAgaWR2YXIgPSAiaWQiLA0KICAgICAgICAgICAgICAgICAgICAgdGltZXZhciA9ICJ0aW1lIiwNCiAgICAgICAgICAgICAgICAgICAgIHRpbWVzID0gMToxMikNCg0KIyBSZW9yZGVyIGRhdGEgYmFzZWQgb24gdXNlciBpZA0KZGZfbG9uZyAgPC0gZGZfbG9uZyBbKG9yZGVyKGRmX2xvbmckaWQpKSwgXQ0KDQojIGNyZWF0ZSBkYXRhIHRvIHBsb3QsIHNlcGVyYXRlbHkgZm9yIG1lbiBhbmQgd29tZW4NCiBkYXRhX2FsbCA8LSBkZl9sb25nICU+JQ0KICAgIGdyb3VwX2J5KHRpbWUpICU+JQ0KICAgIHN1bW1hcmlzZShtZWFuX2ZyZXEgPSBtZWFuKG90aGVyX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBtZWFuX3RpbWUgPSBtZWFuKG90aGVyX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZV9mcmVxID0gMS45NiAqIChzZChvdGhlcl9mcmVxLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEob3RoZXJfZnJlcSkpKSksDQogICAgICAgICAgICAgIHNlX3RpbWUgPSAxLjk2ICogKHNkKG90aGVyX3RpbWUsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShvdGhlcl90aW1lKSkpKSwNCiAgICAgICAgICAgICAgc2RfZnJlcSA9IHNkKG90aGVyX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZF90aW1lID0gc2Qob3RoZXJfdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHZhcl9mcmVxID0gdmFyKG90aGVyX2ZyZXEsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIHZhcl90aW1lID0gdmFyKG90aGVyX3RpbWUsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIGt1cnRvc2lzX2ZyZXEgPSBrdXJ0b3NpcyhvdGhlcl9mcmVxLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAga3VydG9zaXNfdGltZSA9IGt1cnRvc2lzKG90aGVyX3RpbWUsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBjbGFzcyA9ICJGdWxsIFNhbXBsZSINCiAgICApDQogDQogZGF0YV9tZW4gPC0gZGZfbG9uZ1t3aGljaChkZl9sb25nJGdlbmRlciA9PSAiTWFsZSIpLCBdDQogIGRhdGFfbWVuIDwtIGRhdGFfbWVuICU+JQ0KICAgIGdyb3VwX2J5KHRpbWUpICU+JQ0KICAgIHN1bW1hcmlzZShtZWFuX2ZyZXEgPSBtZWFuKG90aGVyX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBtZWFuX3RpbWUgPSBtZWFuKG90aGVyX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZV9mcmVxID0gMS45NiAqIChzZChvdGhlcl9mcmVxLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEob3RoZXJfZnJlcSkpKSksDQogICAgICAgICAgICAgIHNlX3RpbWUgPSAxLjk2ICogKHNkKG90aGVyX3RpbWUsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShvdGhlcl90aW1lKSkpKSwNCiAgICAgICAgICAgICAgc2RfZnJlcSA9IHNkKG90aGVyX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZF90aW1lID0gc2Qob3RoZXJfdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHZhcl9mcmVxID0gdmFyKG90aGVyX2ZyZXEsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIHZhcl90aW1lID0gdmFyKG90aGVyX3RpbWUsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIGt1cnRvc2lzX2ZyZXEgPSBrdXJ0b3NpcyhvdGhlcl9mcmVxLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAga3VydG9zaXNfdGltZSA9IGt1cnRvc2lzKG90aGVyX3RpbWUsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBjbGFzcyA9ICJNZW4iDQogICAgKQ0KICANCiAgZGF0YV93b21lbiA8LSBkZl9sb25nW3doaWNoKGRmX2xvbmckZ2VuZGVyID09ICJGZW1hbGUiKSwgXQ0KICBkYXRhX3dvbWVuIDwtIGRhdGFfd29tZW4gJT4lDQogICAgZ3JvdXBfYnkodGltZSkgJT4lDQogICAgc3VtbWFyaXNlKG1lYW5fZnJlcSA9IG1lYW4ob3RoZXJfZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIG1lYW5fdGltZSA9IG1lYW4ob3RoZXJfdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNlX2ZyZXEgPSAxLjk2ICogKHNkKG90aGVyX2ZyZXEsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShvdGhlcl9mcmVxKSkpKSwNCiAgICAgICAgICAgICAgc2VfdGltZSA9IDEuOTYgKiAoc2Qob3RoZXJfdGltZSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKG90aGVyX3RpbWUpKSkpLA0KICAgICAgICAgICAgICBzZF9mcmVxID0gc2Qob3RoZXJfZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNkX3RpbWUgPSBzZChvdGhlcl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgdmFyX2ZyZXEgPSB2YXIob3RoZXJfZnJlcSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAgdmFyX3RpbWUgPSB2YXIob3RoZXJfdGltZSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAga3VydG9zaXNfZnJlcSA9IGt1cnRvc2lzKG90aGVyX2ZyZXEsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBrdXJ0b3Npc190aW1lID0ga3VydG9zaXMob3RoZXJfdGltZSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGNsYXNzID0gIldvbWVuIg0KICAgICkNCg0KIyBzdGFjayBkYXRhIA0KcGxvdC5kYXRhIDwtIHJiaW5kKGRhdGFfYWxsLCBkYXRhX21lbiwgZGF0YV93b21lbikNCnJtKGRhdGFfYWxsLCBkYXRhX21lbiwgZGF0YV93b21lbikNCg0KIyBhZGQgbW9udGhzDQpwbG90LmRhdGEkbW9udGggPC0gcmVwKGMoIkphbiIsICJGZWIiLCAiTWFyIiwgIkFwciIsICJNYXkiLCAiSnVuIiwgIkp1bCIsICJBdWciLCAiU2VwIiwgIk9jdCIsICJOb3YiLCAiRGVjIiksIDMpDQoNCiMgcGxvdA0KcGxvdF9tZWFuX2ZyZXEgPC0gZ2dwbG90KHBsb3QuZGF0YSwgYWVzKG1vbnRoLCBtZWFuX2ZyZXEsIGdyb3VwID0gY2xhc3MsIGNvbG91ciA9IGNsYXNzKSkgKw0KICAgIGdlb21fcG9pbnQoKSArDQogICAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxvZXNzIiwgc2l6ZT0yKSArDQogICAgZ2VvbV9lcnJvcmJhcihhZXModGltZSwgbWVhbl9mcmVxLCB5bWluID0gbWVhbl9mcmVxIC0gc2VfZnJlcSwgeW1heCA9IG1lYW5fZnJlcSArIHNlX2ZyZXEsDQogICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwLjQpKSArDQogICAgdGhlbWVfYncoYmFzZV9mYW1pbHk9InNlcmlmIiwgYmFzZV9zaXplPTE2KSArDQogICAgc2NhbGVfY29sb3VyX21hbnVhbCh2YWx1ZXM9YygiIzAwMDAwMCIsICIjRTY5RjAwIiwgIiM1NkI0RTkiKSkgKw0KICAgIGxhYnMoeSA9ICJPdGhlciBmcmVxdWVuY3kgcGVyIHdlZWsiLCB4PSJNb250aCIpICsNCiAgICBzY2FsZV94X2Rpc2NyZXRlKGxpbWl0cz1jKCJKYW4iLCAiRmViIiwgIk1hciIsICJBcHIiLCAiTWF5IiwgIkp1biIsICJKdWwiLCAiQXVnIiwgIlNlcCIsICJPY3QiLCAiTm92IiwgIkRlYyIpKSArDQogICAgeWxpbSgwLDUpICsNCiAgICB0aGVtZShheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChmYW1pbHk9InNlcmlmIiwgc2l6ZSA9IDEwLCBhbmdsZSA9IDQ1LCBoanVzdCA9IDEpLCANCiAgICAgICAgICBsZWdlbmQucG9zaXRpb24gPSAicmlnaHQiLCBsZWdlbmQudGl0bGU9ZWxlbWVudF9ibGFuaygpDQogICAgKQ0KICANCiAgcGxvdF9tZWFuX3RpbWUgPC0gZ2dwbG90KHBsb3QuZGF0YSwgYWVzKG1vbnRoLCBtZWFuX3RpbWUsIGdyb3VwID0gY2xhc3MsIGNvbG91ciA9IGNsYXNzKSkgKw0KICAgIGdlb21fcG9pbnQoKSArDQogICAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxvZXNzIiwgc2l6ZT0yKSArDQogICAgZ2VvbV9lcnJvcmJhcihhZXModGltZSwgbWVhbl90aW1lLCB5bWluID0gbWVhbl90aW1lIC0gc2VfdGltZSwgeW1heCA9IG1lYW5fdGltZSArIHNlX3RpbWUsDQogICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwLjQpKSArDQogICAgdGhlbWVfYncoYmFzZV9mYW1pbHk9InNlcmlmIiwgYmFzZV9zaXplPTE2KSArDQogICAgc2NhbGVfY29sb3VyX21hbnVhbCh2YWx1ZXM9YygiIzAwMDAwMCIsICIjRTY5RjAwIiwgIiM1NkI0RTkiKSkgKw0KICAgIGxhYnMoeSA9ICJPdGhlciB2b2x1bWUgcGVyIG1vbnRoIiwgeD0iTW9udGgiKSArDQogICAgc2NhbGVfeF9kaXNjcmV0ZShsaW1pdHM9YygiSmFuIiwgIkZlYiIsICJNYXIiLCAiQXByIiwgIk1heSIsICJKdW4iLCAiSnVsIiwgIkF1ZyIsICJTZXAiLCAiT2N0IiwgIk5vdiIsICJEZWMiKSkgKw0KICAgIHlsaW0oMCw3KSArDQogICAgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoZmFtaWx5PSJzZXJpZiIsIHNpemUgPSAxMCwgYW5nbGUgPSA0NSwgaGp1c3QgPSAxKSwgDQogICAgICAgICAgbGVnZW5kLnBvc2l0aW9uID0gInJpZ2h0IiwgbGVnZW5kLnRpdGxlPWVsZW1lbnRfYmxhbmsoKQ0KICAgICkNCg0KIyMjIE91dHB1dCAjIyMNCg0KIyBoaXN0b2dyYW0gKGFzc3VtaW5nIGluZGVwZW5kZW50IG9ic2VydmF0aW9ucykNCmhpc3QoZGYkdkNvdmFyJGZyZXFfb3RoZXIsIG1haW4gPSAiSGlzdG9ncmFtIG9mIE90aGVyIEZyZXF1ZW5jeSIsIHhsYWIgPSAiVGltZXMgcGVyIHdlZWsiLCB5bGFiID0gImNvdW50IiwgY29sID0gImdyZXkiLCBib3JkZXI9ICJibGFjayIpDQoNCmhpc3QoZGYkdkNvdmFyJHRpbWVfb3RoZXIsIG1haW4gPSAiSGlzdG9ncmFtIG9mIE90aGVyIFZvbHVtZSIsIHhsYWIgPSAiIiwgeWxhYiA9ICJjb3VudCIsIGNvbCA9ICJncmV5IiwgYm9yZGVyPSAiYmxhY2siKQ0KDQojIGRldmVsb3BtZW50IG1lYW4gb3ZlciB0aW1lDQpwbG90X21lYW5fZnJlcQ0KcGxvdF9tZWFuX3RpbWUNCmBgYA0KDQojIyMjIENsdWIgNA0KYGBge3IgY2xhc3Muc291cmNlID0gJ2ZvbGQtaGlkZSd9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFbWzRdXSAjIGdyYWIgY2x1YiANCmRmMiA8LSBjbHViZGF0YVtbNF1dDQoNCiMgZGV2ZWxvcG1lbnQgb2YgdGhlIG1lYW4gb3ZlciB0aW1lDQoNCiMgcmV0cmlldmUgZ2VuZGVyDQptYWxlIDwtIGRmMiRtYWxlDQpmZW1hbGUgPC0gZGYyJGZlbWFsZQ0Kb3RoZXIgPC0gZGYyJG90aGVyDQoNCmdlbmRlciA8LSBOQQ0KZ2VuZGVyIDwtIGlmZWxzZShtYWxlID09IDEsICJNYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShmZW1hbGUgPT0gMSwgIkZlbWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2Uob3RoZXIgPT0gMSwgIk90aGVyIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShpcy5uYShnZW5kZXIpLCAiTWlzc2luZyIsIGdlbmRlcikgIyBtaXNzaW5nIGNhdGVnb3J5DQoNCiMgY3JlYXRlIHdpZGUgZGF0YWZyYW1lDQogIGRmMmxvbmcgPC0gZGF0YS5mcmFtZSAoDQogICAgaWQgPSAxOmxlbmd0aChkZiRub2RlU2V0cyRBY3RvcnMpLA0KICAgIGdlbmRlciA9IGdlbmRlciwNCiAgICBmcmVxMSA9IGRmMiRmcmVxX290aGVyWywsMV0sDQogICAgZnJlcTIgPSBkZjIkZnJlcV9vdGhlclssLDJdLA0KICAgIGZyZXEzID0gZGYyJGZyZXFfb3RoZXJbLCwzXSwNCiAgICBmcmVxNCA9IGRmMiRmcmVxX290aGVyWywsNF0sDQogICAgZnJlcTUgPSBkZjIkZnJlcV9vdGhlclssLDVdLA0KICAgIGZyZXE2ID0gZGYyJGZyZXFfb3RoZXJbLCw2XSwNCiAgICBmcmVxNyA9IGRmMiRmcmVxX290aGVyWywsN10sDQogICAgZnJlcTggPSBkZjIkZnJlcV9vdGhlclssLDhdLA0KICAgIGZyZXE5ID0gZGYyJGZyZXFfb3RoZXJbLCw5XSwNCiAgICBmcmVxMTAgPSBkZjIkZnJlcV9vdGhlclssLDEwXSwNCiAgICBmcmVxMTEgPSBkZjIkZnJlcV9vdGhlclssLDExXSwNCiAgICBmcmVxMTIgPSBkZjIkZnJlcV9vdGhlclssLDEyXSwNCiAgICB0aW1lMSA9IGRmMiR0aW1lX290aGVyWywsMV0sDQogICAgdGltZTIgPSBkZjIkdGltZV9vdGhlclssLDJdLA0KICAgIHRpbWUzID0gZGYyJHRpbWVfb3RoZXJbLCwzXSwNCiAgICB0aW1lNCA9IGRmMiR0aW1lX290aGVyWywsNF0sDQogICAgdGltZTUgPSBkZjIkdGltZV9vdGhlclssLDVdLA0KICAgIHRpbWU2ID0gZGYyJHRpbWVfb3RoZXJbLCw2XSwNCiAgICB0aW1lNyA9IGRmMiR0aW1lX290aGVyWywsN10sDQogICAgdGltZTggPSBkZjIkdGltZV9vdGhlclssLDhdLA0KICAgIHRpbWU5ID0gZGYyJHRpbWVfb3RoZXJbLCw5XSwNCiAgICB0aW1lMTAgPSBkZjIkdGltZV9vdGhlclssLDEwXSwNCiAgICB0aW1lMTEgPSBkZjIkdGltZV9vdGhlclssLDExXSwNCiAgICB0aW1lMTIgPSBkZjIkdGltZV9vdGhlclssLDEyXSkNCg0KIyByZXNoYXBlIHRvIGxvbmcgZGF0YWZyYW1lDQpkZl9sb25nIDwtIHJlc2hhcGUoZGYybG9uZywNCiAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICJsb25nIiwNCiAgICAgICAgICAgICAgICAgICAgIHZhcnlpbmcgPSBjKGxpc3QobmFtZXMoZGYybG9uZylbMzoxNF0pLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdChuYW1lcyhkZjJsb25nKVsxNToyNl0pKSwNCiAgICAgICAgICAgICAgICAgICAgIHYubmFtZXMgPSBjKCJvdGhlcl9mcmVxIiwgIm90aGVyX3RpbWUiKSwNCiAgICAgICAgICAgICAgICAgICAgIGlkdmFyID0gImlkIiwNCiAgICAgICAgICAgICAgICAgICAgIHRpbWV2YXIgPSAidGltZSIsDQogICAgICAgICAgICAgICAgICAgICB0aW1lcyA9IDE6MTIpDQoNCiMgUmVvcmRlciBkYXRhIGJhc2VkIG9uIHVzZXIgaWQNCmRmX2xvbmcgIDwtIGRmX2xvbmcgWyhvcmRlcihkZl9sb25nJGlkKSksIF0NCg0KIyBjcmVhdGUgZGF0YSB0byBwbG90LCBzZXBlcmF0ZWx5IGZvciBtZW4gYW5kIHdvbWVuDQogZGF0YV9hbGwgPC0gZGZfbG9uZyAlPiUNCiAgICBncm91cF9ieSh0aW1lKSAlPiUNCiAgICBzdW1tYXJpc2UobWVhbl9mcmVxID0gbWVhbihvdGhlcl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgbWVhbl90aW1lID0gbWVhbihvdGhlcl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2VfZnJlcSA9IDEuOTYgKiAoc2Qob3RoZXJfZnJlcSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKG90aGVyX2ZyZXEpKSkpLA0KICAgICAgICAgICAgICBzZV90aW1lID0gMS45NiAqIChzZChvdGhlcl90aW1lLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEob3RoZXJfdGltZSkpKSksDQogICAgICAgICAgICAgIHNkX2ZyZXEgPSBzZChvdGhlcl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2RfdGltZSA9IHNkKG90aGVyX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICB2YXJfZnJlcSA9IHZhcihvdGhlcl9mcmVxLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICB2YXJfdGltZSA9IHZhcihvdGhlcl90aW1lLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICBrdXJ0b3Npc19mcmVxID0ga3VydG9zaXMob3RoZXJfZnJlcSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGt1cnRvc2lzX3RpbWUgPSBrdXJ0b3NpcyhvdGhlcl90aW1lLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAgY2xhc3MgPSAiRnVsbCBTYW1wbGUiDQogICAgKQ0KIA0KIGRhdGFfbWVuIDwtIGRmX2xvbmdbd2hpY2goZGZfbG9uZyRnZW5kZXIgPT0gIk1hbGUiKSwgXQ0KICBkYXRhX21lbiA8LSBkYXRhX21lbiAlPiUNCiAgICBncm91cF9ieSh0aW1lKSAlPiUNCiAgICBzdW1tYXJpc2UobWVhbl9mcmVxID0gbWVhbihvdGhlcl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgbWVhbl90aW1lID0gbWVhbihvdGhlcl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2VfZnJlcSA9IDEuOTYgKiAoc2Qob3RoZXJfZnJlcSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKG90aGVyX2ZyZXEpKSkpLA0KICAgICAgICAgICAgICBzZV90aW1lID0gMS45NiAqIChzZChvdGhlcl90aW1lLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEob3RoZXJfdGltZSkpKSksDQogICAgICAgICAgICAgIHNkX2ZyZXEgPSBzZChvdGhlcl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2RfdGltZSA9IHNkKG90aGVyX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICB2YXJfZnJlcSA9IHZhcihvdGhlcl9mcmVxLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICB2YXJfdGltZSA9IHZhcihvdGhlcl90aW1lLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICBrdXJ0b3Npc19mcmVxID0ga3VydG9zaXMob3RoZXJfZnJlcSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGt1cnRvc2lzX3RpbWUgPSBrdXJ0b3NpcyhvdGhlcl90aW1lLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAgY2xhc3MgPSAiTWVuIg0KICAgICkNCiAgDQogIGRhdGFfd29tZW4gPC0gZGZfbG9uZ1t3aGljaChkZl9sb25nJGdlbmRlciA9PSAiRmVtYWxlIiksIF0NCiAgZGF0YV93b21lbiA8LSBkYXRhX3dvbWVuICU+JQ0KICAgIGdyb3VwX2J5KHRpbWUpICU+JQ0KICAgIHN1bW1hcmlzZShtZWFuX2ZyZXEgPSBtZWFuKG90aGVyX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBtZWFuX3RpbWUgPSBtZWFuKG90aGVyX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZV9mcmVxID0gMS45NiAqIChzZChvdGhlcl9mcmVxLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEob3RoZXJfZnJlcSkpKSksDQogICAgICAgICAgICAgIHNlX3RpbWUgPSAxLjk2ICogKHNkKG90aGVyX3RpbWUsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShvdGhlcl90aW1lKSkpKSwNCiAgICAgICAgICAgICAgc2RfZnJlcSA9IHNkKG90aGVyX2ZyZXEsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICBzZF90aW1lID0gc2Qob3RoZXJfdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHZhcl9mcmVxID0gdmFyKG90aGVyX2ZyZXEsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIHZhcl90aW1lID0gdmFyKG90aGVyX3RpbWUsIG5hLnJtID0gVCksDQogICAgICAgICAgICAgIGt1cnRvc2lzX2ZyZXEgPSBrdXJ0b3NpcyhvdGhlcl9mcmVxLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAga3VydG9zaXNfdGltZSA9IGt1cnRvc2lzKG90aGVyX3RpbWUsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBjbGFzcyA9ICJXb21lbiINCiAgICApDQoNCiMgc3RhY2sgZGF0YSANCnBsb3QuZGF0YSA8LSByYmluZChkYXRhX2FsbCwgZGF0YV9tZW4sIGRhdGFfd29tZW4pDQpybShkYXRhX2FsbCwgZGF0YV9tZW4sIGRhdGFfd29tZW4pDQoNCiMgYWRkIG1vbnRocw0KcGxvdC5kYXRhJG1vbnRoIDwtIHJlcChjKCJKYW4iLCAiRmViIiwgIk1hciIsICJBcHIiLCAiTWF5IiwgIkp1biIsICJKdWwiLCAiQXVnIiwgIlNlcCIsICJPY3QiLCAiTm92IiwgIkRlYyIpLCAzKQ0KDQojIHBsb3QNCnBsb3RfbWVhbl9mcmVxIDwtIGdncGxvdChwbG90LmRhdGEsIGFlcyhtb250aCwgbWVhbl9mcmVxLCBncm91cCA9IGNsYXNzLCBjb2xvdXIgPSBjbGFzcykpICsNCiAgICBnZW9tX3BvaW50KCkgKw0KICAgIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsb2VzcyIsIHNpemU9MikgKw0KICAgIGdlb21fZXJyb3JiYXIoYWVzKHRpbWUsIG1lYW5fZnJlcSwgeW1pbiA9IG1lYW5fZnJlcSAtIHNlX2ZyZXEsIHltYXggPSBtZWFuX2ZyZXEgKyBzZV9mcmVxLA0KICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMC40KSkgKw0KICAgIHRoZW1lX2J3KGJhc2VfZmFtaWx5PSJzZXJpZiIsIGJhc2Vfc2l6ZT0xNikgKw0KICAgIHNjYWxlX2NvbG91cl9tYW51YWwodmFsdWVzPWMoIiMwMDAwMDAiLCAiI0U2OUYwMCIsICIjNTZCNEU5IikpICsNCiAgICBsYWJzKHkgPSAiT3RoZXIgZnJlcXVlbmN5IHBlciB3ZWVrIiwgeD0iTW9udGgiKSArDQogICAgc2NhbGVfeF9kaXNjcmV0ZShsaW1pdHM9YygiSmFuIiwgIkZlYiIsICJNYXIiLCAiQXByIiwgIk1heSIsICJKdW4iLCAiSnVsIiwgIkF1ZyIsICJTZXAiLCAiT2N0IiwgIk5vdiIsICJEZWMiKSkgKw0KICAgIHlsaW0oMCw1KSArDQogICAgdGhlbWUoYXhpcy50ZXh0LnggPSBlbGVtZW50X3RleHQoZmFtaWx5PSJzZXJpZiIsIHNpemUgPSAxMCwgYW5nbGUgPSA0NSwgaGp1c3QgPSAxKSwgDQogICAgICAgICAgbGVnZW5kLnBvc2l0aW9uID0gInJpZ2h0IiwgbGVnZW5kLnRpdGxlPWVsZW1lbnRfYmxhbmsoKQ0KICAgICkNCiAgDQogIHBsb3RfbWVhbl90aW1lIDwtIGdncGxvdChwbG90LmRhdGEsIGFlcyhtb250aCwgbWVhbl90aW1lLCBncm91cCA9IGNsYXNzLCBjb2xvdXIgPSBjbGFzcykpICsNCiAgICBnZW9tX3BvaW50KCkgKw0KICAgIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsb2VzcyIsIHNpemU9MikgKw0KICAgIGdlb21fZXJyb3JiYXIoYWVzKHRpbWUsIG1lYW5fdGltZSwgeW1pbiA9IG1lYW5fdGltZSAtIHNlX3RpbWUsIHltYXggPSBtZWFuX3RpbWUgKyBzZV90aW1lLA0KICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMC40KSkgKw0KICAgIHRoZW1lX2J3KGJhc2VfZmFtaWx5PSJzZXJpZiIsIGJhc2Vfc2l6ZT0xNikgKw0KICAgIHNjYWxlX2NvbG91cl9tYW51YWwodmFsdWVzPWMoIiMwMDAwMDAiLCAiI0U2OUYwMCIsICIjNTZCNEU5IikpICsNCiAgICBsYWJzKHkgPSAiT3RoZXIgdm9sdW1lIHBlciBtb250aCIsIHg9Ik1vbnRoIikgKw0KICAgIHNjYWxlX3hfZGlzY3JldGUobGltaXRzPWMoIkphbiIsICJGZWIiLCAiTWFyIiwgIkFwciIsICJNYXkiLCAiSnVuIiwgIkp1bCIsICJBdWciLCAiU2VwIiwgIk9jdCIsICJOb3YiLCAiRGVjIikpICsNCiAgICB5bGltKDAsNykgKw0KICAgIHRoZW1lKGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KGZhbWlseT0ic2VyaWYiLCBzaXplID0gMTAsIGFuZ2xlID0gNDUsIGhqdXN0ID0gMSksIA0KICAgICAgICAgIGxlZ2VuZC5wb3NpdGlvbiA9ICJyaWdodCIsIGxlZ2VuZC50aXRsZT1lbGVtZW50X2JsYW5rKCkNCiAgICApDQoNCiMjIyBPdXRwdXQgIyMjDQoNCiMgaGlzdG9ncmFtIChhc3N1bWluZyBpbmRlcGVuZGVudCBvYnNlcnZhdGlvbnMpDQpoaXN0KGRmJHZDb3ZhciRmcmVxX290aGVyLCBtYWluID0gIkhpc3RvZ3JhbSBvZiBPdGhlciBGcmVxdWVuY3kiLCB4bGFiID0gIlRpbWVzIHBlciB3ZWVrIiwgeWxhYiA9ICJjb3VudCIsIGNvbCA9ICJncmV5IiwgYm9yZGVyPSAiYmxhY2siKQ0KDQpoaXN0KGRmJHZDb3ZhciR0aW1lX290aGVyLCBtYWluID0gIkhpc3RvZ3JhbSBvZiBPdGhlciBWb2x1bWUiLCB4bGFiID0gIiIsIHlsYWIgPSAiY291bnQiLCBjb2wgPSAiZ3JleSIsIGJvcmRlcj0gImJsYWNrIikNCg0KIyBkZXZlbG9wbWVudCBtZWFuIG92ZXIgdGltZQ0KcGxvdF9tZWFuX2ZyZXENCnBsb3RfbWVhbl90aW1lDQpgYGANCg0KIyMjIyBDbHViIDUNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1s1XV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzVdXQ0KDQojIGRldmVsb3BtZW50IG9mIHRoZSBtZWFuIG92ZXIgdGltZQ0KDQojIHJldHJpZXZlIGdlbmRlcg0KbWFsZSA8LSBkZjIkbWFsZQ0KZmVtYWxlIDwtIGRmMiRmZW1hbGUNCm90aGVyIDwtIGRmMiRvdGhlcg0KDQpnZW5kZXIgPC0gTkENCmdlbmRlciA8LSBpZmVsc2UobWFsZSA9PSAxLCAiTWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoZmVtYWxlID09IDEsICJGZW1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKG90aGVyID09IDEsICJPdGhlciIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoaXMubmEoZ2VuZGVyKSwgIk1pc3NpbmciLCBnZW5kZXIpICMgbWlzc2luZyBjYXRlZ29yeQ0KDQojIGNyZWF0ZSB3aWRlIGRhdGFmcmFtZQ0KICBkZjJsb25nIDwtIGRhdGEuZnJhbWUgKA0KICAgIGlkID0gMTpsZW5ndGgoZGYkbm9kZVNldHMkQWN0b3JzKSwNCiAgICBnZW5kZXIgPSBnZW5kZXIsDQogICAgZnJlcTEgPSBkZjIkZnJlcV9vdGhlclssLDFdLA0KICAgIGZyZXEyID0gZGYyJGZyZXFfb3RoZXJbLCwyXSwNCiAgICBmcmVxMyA9IGRmMiRmcmVxX290aGVyWywsM10sDQogICAgZnJlcTQgPSBkZjIkZnJlcV9vdGhlclssLDRdLA0KICAgIGZyZXE1ID0gZGYyJGZyZXFfb3RoZXJbLCw1XSwNCiAgICBmcmVxNiA9IGRmMiRmcmVxX290aGVyWywsNl0sDQogICAgZnJlcTcgPSBkZjIkZnJlcV9vdGhlclssLDddLA0KICAgIGZyZXE4ID0gZGYyJGZyZXFfb3RoZXJbLCw4XSwNCiAgICBmcmVxOSA9IGRmMiRmcmVxX290aGVyWywsOV0sDQogICAgZnJlcTEwID0gZGYyJGZyZXFfb3RoZXJbLCwxMF0sDQogICAgZnJlcTExID0gZGYyJGZyZXFfb3RoZXJbLCwxMV0sDQogICAgZnJlcTEyID0gZGYyJGZyZXFfb3RoZXJbLCwxMl0sDQogICAgdGltZTEgPSBkZjIkdGltZV9vdGhlclssLDFdLA0KICAgIHRpbWUyID0gZGYyJHRpbWVfb3RoZXJbLCwyXSwNCiAgICB0aW1lMyA9IGRmMiR0aW1lX290aGVyWywsM10sDQogICAgdGltZTQgPSBkZjIkdGltZV9vdGhlclssLDRdLA0KICAgIHRpbWU1ID0gZGYyJHRpbWVfb3RoZXJbLCw1XSwNCiAgICB0aW1lNiA9IGRmMiR0aW1lX290aGVyWywsNl0sDQogICAgdGltZTcgPSBkZjIkdGltZV9vdGhlclssLDddLA0KICAgIHRpbWU4ID0gZGYyJHRpbWVfb3RoZXJbLCw4XSwNCiAgICB0aW1lOSA9IGRmMiR0aW1lX290aGVyWywsOV0sDQogICAgdGltZTEwID0gZGYyJHRpbWVfb3RoZXJbLCwxMF0sDQogICAgdGltZTExID0gZGYyJHRpbWVfb3RoZXJbLCwxMV0sDQogICAgdGltZTEyID0gZGYyJHRpbWVfb3RoZXJbLCwxMl0pDQoNCiMgcmVzaGFwZSB0byBsb25nIGRhdGFmcmFtZQ0KZGZfbG9uZyA8LSByZXNoYXBlKGRmMmxvbmcsDQogICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAibG9uZyIsDQogICAgICAgICAgICAgICAgICAgICB2YXJ5aW5nID0gYyhsaXN0KG5hbWVzKGRmMmxvbmcpWzM6MTRdKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QobmFtZXMoZGYybG9uZylbMTU6MjZdKSksDQogICAgICAgICAgICAgICAgICAgICB2Lm5hbWVzID0gYygib3RoZXJfZnJlcSIsICJvdGhlcl90aW1lIiksDQogICAgICAgICAgICAgICAgICAgICBpZHZhciA9ICJpZCIsDQogICAgICAgICAgICAgICAgICAgICB0aW1ldmFyID0gInRpbWUiLA0KICAgICAgICAgICAgICAgICAgICAgdGltZXMgPSAxOjEyKQ0KDQojIFJlb3JkZXIgZGF0YSBiYXNlZCBvbiB1c2VyIGlkDQpkZl9sb25nICA8LSBkZl9sb25nIFsob3JkZXIoZGZfbG9uZyRpZCkpLCBdDQoNCiMgY3JlYXRlIGRhdGEgdG8gcGxvdCwgc2VwZXJhdGVseSBmb3IgbWVuIGFuZCB3b21lbg0KIGRhdGFfYWxsIDwtIGRmX2xvbmcgJT4lDQogICAgZ3JvdXBfYnkodGltZSkgJT4lDQogICAgc3VtbWFyaXNlKG1lYW5fZnJlcSA9IG1lYW4ob3RoZXJfZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIG1lYW5fdGltZSA9IG1lYW4ob3RoZXJfdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNlX2ZyZXEgPSAxLjk2ICogKHNkKG90aGVyX2ZyZXEsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShvdGhlcl9mcmVxKSkpKSwNCiAgICAgICAgICAgICAgc2VfdGltZSA9IDEuOTYgKiAoc2Qob3RoZXJfdGltZSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKG90aGVyX3RpbWUpKSkpLA0KICAgICAgICAgICAgICBzZF9mcmVxID0gc2Qob3RoZXJfZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNkX3RpbWUgPSBzZChvdGhlcl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgdmFyX2ZyZXEgPSB2YXIob3RoZXJfZnJlcSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAgdmFyX3RpbWUgPSB2YXIob3RoZXJfdGltZSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAga3VydG9zaXNfZnJlcSA9IGt1cnRvc2lzKG90aGVyX2ZyZXEsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBrdXJ0b3Npc190aW1lID0ga3VydG9zaXMob3RoZXJfdGltZSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGNsYXNzID0gIkZ1bGwgU2FtcGxlIg0KICAgICkNCiANCiBkYXRhX21lbiA8LSBkZl9sb25nW3doaWNoKGRmX2xvbmckZ2VuZGVyID09ICJNYWxlIiksIF0NCiAgZGF0YV9tZW4gPC0gZGF0YV9tZW4gJT4lDQogICAgZ3JvdXBfYnkodGltZSkgJT4lDQogICAgc3VtbWFyaXNlKG1lYW5fZnJlcSA9IG1lYW4ob3RoZXJfZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIG1lYW5fdGltZSA9IG1lYW4ob3RoZXJfdGltZSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNlX2ZyZXEgPSAxLjk2ICogKHNkKG90aGVyX2ZyZXEsIG5hLnJtPVQpL3NxcnQoc3VtKCFpcy5uYShvdGhlcl9mcmVxKSkpKSwNCiAgICAgICAgICAgICAgc2VfdGltZSA9IDEuOTYgKiAoc2Qob3RoZXJfdGltZSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKG90aGVyX3RpbWUpKSkpLA0KICAgICAgICAgICAgICBzZF9mcmVxID0gc2Qob3RoZXJfZnJlcSwgbmEucm09VCksDQogICAgICAgICAgICAgIHNkX3RpbWUgPSBzZChvdGhlcl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgdmFyX2ZyZXEgPSB2YXIob3RoZXJfZnJlcSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAgdmFyX3RpbWUgPSB2YXIob3RoZXJfdGltZSwgbmEucm0gPSBUKSwNCiAgICAgICAgICAgICAga3VydG9zaXNfZnJlcSA9IGt1cnRvc2lzKG90aGVyX2ZyZXEsIG5hLnJtID0gVCkgLSAzLA0KICAgICAgICAgICAgICBrdXJ0b3Npc190aW1lID0ga3VydG9zaXMob3RoZXJfdGltZSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGNsYXNzID0gIk1lbiINCiAgICApDQogIA0KICBkYXRhX3dvbWVuIDwtIGRmX2xvbmdbd2hpY2goZGZfbG9uZyRnZW5kZXIgPT0gIkZlbWFsZSIpLCBdDQogIGRhdGFfd29tZW4gPC0gZGF0YV93b21lbiAlPiUNCiAgICBncm91cF9ieSh0aW1lKSAlPiUNCiAgICBzdW1tYXJpc2UobWVhbl9mcmVxID0gbWVhbihvdGhlcl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgbWVhbl90aW1lID0gbWVhbihvdGhlcl90aW1lLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2VfZnJlcSA9IDEuOTYgKiAoc2Qob3RoZXJfZnJlcSwgbmEucm09VCkvc3FydChzdW0oIWlzLm5hKG90aGVyX2ZyZXEpKSkpLA0KICAgICAgICAgICAgICBzZV90aW1lID0gMS45NiAqIChzZChvdGhlcl90aW1lLCBuYS5ybT1UKS9zcXJ0KHN1bSghaXMubmEob3RoZXJfdGltZSkpKSksDQogICAgICAgICAgICAgIHNkX2ZyZXEgPSBzZChvdGhlcl9mcmVxLCBuYS5ybT1UKSwNCiAgICAgICAgICAgICAgc2RfdGltZSA9IHNkKG90aGVyX3RpbWUsIG5hLnJtPVQpLA0KICAgICAgICAgICAgICB2YXJfZnJlcSA9IHZhcihvdGhlcl9mcmVxLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICB2YXJfdGltZSA9IHZhcihvdGhlcl90aW1lLCBuYS5ybSA9IFQpLA0KICAgICAgICAgICAgICBrdXJ0b3Npc19mcmVxID0ga3VydG9zaXMob3RoZXJfZnJlcSwgbmEucm0gPSBUKSAtIDMsDQogICAgICAgICAgICAgIGt1cnRvc2lzX3RpbWUgPSBrdXJ0b3NpcyhvdGhlcl90aW1lLCBuYS5ybSA9IFQpIC0gMywNCiAgICAgICAgICAgICAgY2xhc3MgPSAiV29tZW4iDQogICAgKQ0KDQojIHN0YWNrIGRhdGEgDQpwbG90LmRhdGEgPC0gcmJpbmQoZGF0YV9hbGwsIGRhdGFfbWVuLCBkYXRhX3dvbWVuKQ0Kcm0oZGF0YV9hbGwsIGRhdGFfbWVuLCBkYXRhX3dvbWVuKQ0KDQojIGFkZCBtb250aHMNCnBsb3QuZGF0YSRtb250aCA8LSByZXAoYygiSmFuIiwgIkZlYiIsICJNYXIiLCAiQXByIiwgIk1heSIsICJKdW4iLCAiSnVsIiwgIkF1ZyIsICJTZXAiLCAiT2N0IiwgIk5vdiIsICJEZWMiKSwgMykNCg0KIyBwbG90DQpwbG90X21lYW5fZnJlcSA8LSBnZ3Bsb3QocGxvdC5kYXRhLCBhZXMobW9udGgsIG1lYW5fZnJlcSwgZ3JvdXAgPSBjbGFzcywgY29sb3VyID0gY2xhc3MpKSArDQogICAgZ2VvbV9wb2ludCgpICsNCiAgICBnZW9tX3Ntb290aChtZXRob2QgPSAibG9lc3MiLCBzaXplPTIpICsNCiAgICBnZW9tX2Vycm9yYmFyKGFlcyh0aW1lLCBtZWFuX2ZyZXEsIHltaW4gPSBtZWFuX2ZyZXEgLSBzZV9mcmVxLCB5bWF4ID0gbWVhbl9mcmVxICsgc2VfZnJlcSwNCiAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDAuNCkpICsNCiAgICB0aGVtZV9idyhiYXNlX2ZhbWlseT0ic2VyaWYiLCBiYXNlX3NpemU9MTYpICsNCiAgICBzY2FsZV9jb2xvdXJfbWFudWFsKHZhbHVlcz1jKCIjMDAwMDAwIiwgIiNFNjlGMDAiLCAiIzU2QjRFOSIpKSArDQogICAgbGFicyh5ID0gIk90aGVyIGZyZXF1ZW5jeSBwZXIgd2VlayIsIHg9Ik1vbnRoIikgKw0KICAgIHNjYWxlX3hfZGlzY3JldGUobGltaXRzPWMoIkphbiIsICJGZWIiLCAiTWFyIiwgIkFwciIsICJNYXkiLCAiSnVuIiwgIkp1bCIsICJBdWciLCAiU2VwIiwgIk9jdCIsICJOb3YiLCAiRGVjIikpICsNCiAgICB5bGltKDAsNSkgKw0KICAgIHRoZW1lKGF4aXMudGV4dC54ID0gZWxlbWVudF90ZXh0KGZhbWlseT0ic2VyaWYiLCBzaXplID0gMTAsIGFuZ2xlID0gNDUsIGhqdXN0ID0gMSksIA0KICAgICAgICAgIGxlZ2VuZC5wb3NpdGlvbiA9ICJyaWdodCIsIGxlZ2VuZC50aXRsZT1lbGVtZW50X2JsYW5rKCkNCiAgICApDQogIA0KICBwbG90X21lYW5fdGltZSA8LSBnZ3Bsb3QocGxvdC5kYXRhLCBhZXMobW9udGgsIG1lYW5fdGltZSwgZ3JvdXAgPSBjbGFzcywgY29sb3VyID0gY2xhc3MpKSArDQogICAgZ2VvbV9wb2ludCgpICsNCiAgICBnZW9tX3Ntb290aChtZXRob2QgPSAibG9lc3MiLCBzaXplPTIpICsNCiAgICBnZW9tX2Vycm9yYmFyKGFlcyh0aW1lLCBtZWFuX3RpbWUsIHltaW4gPSBtZWFuX3RpbWUgLSBzZV90aW1lLCB5bWF4ID0gbWVhbl90aW1lICsgc2VfdGltZSwNCiAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDAuNCkpICsNCiAgICB0aGVtZV9idyhiYXNlX2ZhbWlseT0ic2VyaWYiLCBiYXNlX3NpemU9MTYpICsNCiAgICBzY2FsZV9jb2xvdXJfbWFudWFsKHZhbHVlcz1jKCIjMDAwMDAwIiwgIiNFNjlGMDAiLCAiIzU2QjRFOSIpKSArDQogICAgbGFicyh5ID0gIk90aGVyIHZvbHVtZSBwZXIgbW9udGgiLCB4PSJNb250aCIpICsNCiAgICBzY2FsZV94X2Rpc2NyZXRlKGxpbWl0cz1jKCJKYW4iLCAiRmViIiwgIk1hciIsICJBcHIiLCAiTWF5IiwgIkp1biIsICJKdWwiLCAiQXVnIiwgIlNlcCIsICJPY3QiLCAiTm92IiwgIkRlYyIpKSArDQogICAgeWxpbSgwLDcpICsNCiAgICB0aGVtZShheGlzLnRleHQueCA9IGVsZW1lbnRfdGV4dChmYW1pbHk9InNlcmlmIiwgc2l6ZSA9IDEwLCBhbmdsZSA9IDQ1LCBoanVzdCA9IDEpLCANCiAgICAgICAgICBsZWdlbmQucG9zaXRpb24gPSAicmlnaHQiLCBsZWdlbmQudGl0bGU9ZWxlbWVudF9ibGFuaygpDQogICAgKQ0KDQojIyMgT3V0cHV0ICMjIw0KDQojIGhpc3RvZ3JhbSAoYXNzdW1pbmcgaW5kZXBlbmRlbnQgb2JzZXJ2YXRpb25zKQ0KaGlzdChkZiR2Q292YXIkZnJlcV9vdGhlciwgbWFpbiA9ICJIaXN0b2dyYW0gb2YgT3RoZXIgRnJlcXVlbmN5IiwgeGxhYiA9ICJUaW1lcyBwZXIgd2VlayIsIHlsYWIgPSAiY291bnQiLCBjb2wgPSAiZ3JleSIsIGJvcmRlcj0gImJsYWNrIikNCg0KaGlzdChkZiR2Q292YXIkdGltZV9vdGhlciwgbWFpbiA9ICJIaXN0b2dyYW0gb2YgT3RoZXIgVm9sdW1lIiwgeGxhYiA9ICIiLCB5bGFiID0gImNvdW50IiwgY29sID0gImdyZXkiLCBib3JkZXI9ICJibGFjayIpDQoNCiMgZGV2ZWxvcG1lbnQgbWVhbiBvdmVyIHRpbWUNCnBsb3RfbWVhbl9mcmVxDQpwbG90X21lYW5fdGltZQ0KYGBgDQoNCiMjIyB7LX0NCg0KLS0tLQ0KDQo8YnI+DQoNCiMjIFdpdGhpbi1wZXJzb24gY2hhbmdlDQoNCiMjIyB7LnRhYnNldCAudGFic2V0LWZhZGV9DQpXZSBoYXZlIGlsbHVzdHJhdGVkIHRoZSBkZXZlbG9wbWVudCBvZiB0aGUgbWVhbiBvZiB0aGUgZGVwZW5kZW50IGJlaGF2aW9yYWwgdmFyaWFibGUgb3ZlciB0aW1lLCBhbmQgdGhlIGV4dGVudCB0byB3aGljaCBpdCBkaWZmZXJlZCBhY3Jvc3MgdGhlIGdlbmRlcnMuIE5vdyBsZXQncyBhbHNvIGNoZWNrIGlmIGJlaGF2aW9yIHZhcmllZCBvdmVyIHRpbWUgd2l0aGluIGluZGl2aWR1YWxzLiBXaXRoaW4tcGVyc29uIHZhcmlhdGlvbiBpcyBhIHByZXJlcXVpc2l0ZSBmb3IgaWRlbnRpZnlpbmcgaW5mbHVlbmNlIGVmZmVjdHMgb24gYmVoYXZpb3IuIERvd24gYmVsb3cgd2UgZGVtb25zdHJhdGUgaG93IHJ1bm5pbmcgYWN0aXZpdHkgdmFyaWVzIHdpdGhpbiBpbmRpdmlkdWFscyBvdmVyIHRpbWUsIGluIGFic29sdXRlIHNjb3JlcyAoaS5lLiBpbiB0aW1lcyBwZXIgd2VlaykuDQoNCiMjIyMgQ2x1YiAxDQoNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFbWzFdXSAjIGdyYWIgY2x1Yg0KDQojIGNoZWNrIHdpdGhpbi1wZXJzb24gdmFyaWFiaWxpdHkgb2YgcnVubmluZyBmcmVxdWVuY3kNCiMgYWJzb2x1dGUgc2NvcmVzDQpzaXplIDwtIGRmJG5ldHNpemUNCnkgPC0gYXJyYXkoYyhkZiRmcmVxX3J1blssLF0pKQ0KeCA8LSByZXAoMToxMiwgc2l6ZSkNCmRmIDwtIGRhdGEuZnJhbWUoeSwgeCkNCmRmICA8LSBkZiBbKG9yZGVyKGRmJHgpKSwgXQ0KZGYkaWQgPC0gcmVwKDE6c2l6ZSwgMTIpDQoNCiMgZ2V0IHJhbmRvbSBzYW1wbGUgb2YgOSBwZXJzb25zDQpzYW1wbGUgPC0gc2FtcGxlKGMoMTpzaXplKSwgc2l6ZT05LCByZXBsYWNlPUYpDQpkZl9uZXcgPC0gZHBseXI6OmZpbHRlcihkZiwgaWQgJWluJSBzYW1wbGUpDQoNCiMgcGxvdCBncm93dGggdHJhamVjdG9yaWVzIG9mIHJhbmRvbSBzYW1wbGUgb2YgOSBvZiBhbGwgY2x1YiBtZW1iZXJzDQpwIDwtIGdncGxvdChkYXRhID0gZGZfbmV3LCBhZXMoeCwgeSkpICsgZ2VvbV9saW5lKCkrDQogIGZhY2V0X3dyYXAofmlkKQ0KcCArIHNjYWxlX3hfY29udGludW91cyhicmVha3MgPSBzZXEoMSwgMTIsIDEpKSArIHNjYWxlX3lfY29udGludW91cyhicmVha3MgPSBzZXEoMCwgOCwgMSkpICsgDQogZ2d0aXRsZSgiR3Jvd3RoIHRyYWplY3RvcmllcyBpbiBydW5uaW5nIGZyZXF1ZW5jeSBvdmVyIHRpbWUgb2YgYSByYW5kb20gc2FtcGxlIG9mIDkgYWN0b3JzIikgKw0KICB4bGFiKCJUaW1lIGluIG1vbnRocyIpICsgeWxhYigiUnVubmluZyBmcmVxdWVuY3kgaW4gdGltZXMgcGVyIHdlZWsiKQ0KDQpgYGANCg0KIyMjIyBDbHViIDINCg0KYGBge3IgY2xhc3Muc291cmNlID0gJ2ZvbGQtaGlkZSd9DQpkZiA8LSBjbHViZGF0YVtbMl1dICMgZ3JhYiBjbHViDQoNCiMgY2hlY2sgd2l0aGluLXBlcnNvbiB2YXJpYWJpbGl0eSBvZiBydW5uaW5nIGZyZXF1ZW5jeQ0KIyBhYnNvbHV0ZSBzY29yZXMNCnNpemUgPC0gZGYkbmV0c2l6ZQ0KeSA8LSBhcnJheShjKGRmJGZyZXFfcnVuWywsXSkpDQp4IDwtIHJlcCgxOjEyLCBzaXplKQ0KZGYgPC0gZGF0YS5mcmFtZSh5LCB4KQ0KZGYgIDwtIGRmIFsob3JkZXIoZGYkeCkpLCBdDQpkZiRpZCA8LSByZXAoMTpzaXplLCAxMikNCg0KIyBnZXQgcmFuZG9tIHNhbXBsZSBvZiA5IHBlcnNvbnMNCnNhbXBsZSA8LSBzYW1wbGUoYygxOnNpemUpLCBzaXplPTksIHJlcGxhY2U9RikNCmRmX25ldyA8LSBkcGx5cjo6ZmlsdGVyKGRmLCBpZCAlaW4lIHNhbXBsZSkNCg0KIyBwbG90IGdyb3d0aCB0cmFqZWN0b3JpZXMgb2YgcmFuZG9tIHNhbXBsZSBvZiA5IG9mIGFsbCBjbHViIG1lbWJlcnMNCnAgPC0gZ2dwbG90KGRhdGEgPSBkZl9uZXcsIGFlcyh4LCB5KSkgKyBnZW9tX2xpbmUoKSsNCiAgZmFjZXRfd3JhcCh+aWQpDQpwICsgc2NhbGVfeF9jb250aW51b3VzKGJyZWFrcyA9IHNlcSgxLCAxMiwgMSkpICsgc2NhbGVfeV9jb250aW51b3VzKGJyZWFrcyA9IHNlcSgwLCA4LCAxKSkgKyANCiBnZ3RpdGxlKCJHcm93dGggdHJhamVjdG9yaWVzIGluIHJ1bm5pbmcgZnJlcXVlbmN5IG92ZXIgdGltZSBvZiBhIHJhbmRvbSBzYW1wbGUgb2YgOSBhY3RvcnMiKSArDQogIHhsYWIoIlRpbWUgaW4gbW9udGhzIikgKyB5bGFiKCJSdW5uaW5nIGZyZXF1ZW5jeSBpbiB0aW1lcyBwZXIgd2VlayIpDQoNCmBgYA0KDQoNCiMjIyMgQ2x1YiAzDQoNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFbWzNdXSAjIGdyYWIgY2x1Yg0KDQojIGNoZWNrIHdpdGhpbi1wZXJzb24gdmFyaWFiaWxpdHkgb2YgcnVubmluZyBmcmVxdWVuY3kNCiMgYWJzb2x1dGUgc2NvcmVzDQpzaXplIDwtIGRmJG5ldHNpemUNCnkgPC0gYXJyYXkoYyhkZiRmcmVxX3J1blssLF0pKQ0KeCA8LSByZXAoMToxMiwgc2l6ZSkNCmRmIDwtIGRhdGEuZnJhbWUoeSwgeCkNCmRmICA8LSBkZiBbKG9yZGVyKGRmJHgpKSwgXQ0KZGYkaWQgPC0gcmVwKDE6c2l6ZSwgMTIpDQoNCiMgZ2V0IHJhbmRvbSBzYW1wbGUgb2YgOSBwZXJzb25zDQpzYW1wbGUgPC0gc2FtcGxlKGMoMTpzaXplKSwgc2l6ZT05LCByZXBsYWNlPUYpDQpkZl9uZXcgPC0gZHBseXI6OmZpbHRlcihkZiwgaWQgJWluJSBzYW1wbGUpDQoNCiMgcGxvdCBncm93dGggdHJhamVjdG9yaWVzIG9mIHJhbmRvbSBzYW1wbGUgb2YgOSBvZiBhbGwgY2x1YiBtZW1iZXJzDQpwIDwtIGdncGxvdChkYXRhID0gZGZfbmV3LCBhZXMoeCwgeSkpICsgZ2VvbV9saW5lKCkrDQogIGZhY2V0X3dyYXAofmlkKQ0KcCArIHNjYWxlX3hfY29udGludW91cyhicmVha3MgPSBzZXEoMSwgMTIsIDEpKSArIHNjYWxlX3lfY29udGludW91cyhicmVha3MgPSBzZXEoMCwgOCwgMSkpICsgDQogICBnZ3RpdGxlKCJHcm93dGggdHJhamVjdG9yaWVzIGluIHJ1bm5pbmcgZnJlcXVlbmN5IG92ZXIgdGltZSBvZiBhIHJhbmRvbSBzYW1wbGUgb2YgOSBhY3RvcnMiKSArDQogIHhsYWIoIlRpbWUgaW4gbW9udGhzIikgKyB5bGFiKCJSdW5uaW5nIGZyZXF1ZW5jeSBpbiB0aW1lcyBwZXIgd2VlayIpDQoNCmBgYA0KDQojIyMjIENsdWIgNA0KDQpgYGB7ciBjbGFzcy5zb3VyY2UgPSAnZm9sZC1oaWRlJ30NCmRmIDwtIGNsdWJkYXRhW1s0XV0gIyBncmFiIGNsdWINCg0KIyBjaGVjayB3aXRoaW4tcGVyc29uIHZhcmlhYmlsaXR5IG9mIHJ1bm5pbmcgZnJlcXVlbmN5DQojIGFic29sdXRlIHNjb3Jlcw0Kc2l6ZSA8LSBkZiRuZXRzaXplDQp5IDwtIGFycmF5KGMoZGYkZnJlcV9ydW5bLCxdKSkNCnggPC0gcmVwKDE6MTIsIHNpemUpDQpkZiA8LSBkYXRhLmZyYW1lKHksIHgpDQpkZiAgPC0gZGYgWyhvcmRlcihkZiR4KSksIF0NCmRmJGlkIDwtIHJlcCgxOnNpemUsIDEyKQ0KDQojIGdldCByYW5kb20gc2FtcGxlIG9mIDkgcGVyc29ucw0Kc2FtcGxlIDwtIHNhbXBsZShjKDE6c2l6ZSksIHNpemU9OSwgcmVwbGFjZT1GKQ0KZGZfbmV3IDwtIGRwbHlyOjpmaWx0ZXIoZGYsIGlkICVpbiUgc2FtcGxlKQ0KDQojIHBsb3QgZ3Jvd3RoIHRyYWplY3RvcmllcyBvZiByYW5kb20gc2FtcGxlIG9mIDkgb2YgYWxsIGNsdWIgbWVtYmVycw0KcCA8LSBnZ3Bsb3QoZGF0YSA9IGRmX25ldywgYWVzKHgsIHkpKSArIGdlb21fbGluZSgpKw0KICBmYWNldF93cmFwKH5pZCkNCnAgKyBzY2FsZV94X2NvbnRpbnVvdXMoYnJlYWtzID0gc2VxKDEsIDEyLCAxKSkgKyBzY2FsZV95X2NvbnRpbnVvdXMoYnJlYWtzID0gc2VxKDAsIDgsIDEpKSArIA0KIGdndGl0bGUoIkdyb3d0aCB0cmFqZWN0b3JpZXMgaW4gcnVubmluZyBmcmVxdWVuY3kgb3ZlciB0aW1lIG9mIGEgcmFuZG9tIHNhbXBsZSBvZiA5IGFjdG9ycyIpICsNCiAgeGxhYigiVGltZSBpbiBtb250aHMiKSArIHlsYWIoIlJ1bm5pbmcgZnJlcXVlbmN5IGluIHRpbWVzIHBlciB3ZWVrIikNCg0KYGBgDQoNCg0KIyMjIyBDbHViIDUNCg0KYGBge3IgY2xhc3Muc291cmNlID0gJ2ZvbGQtaGlkZSd9DQpkZiA8LSBjbHViZGF0YVtbNV1dICMgZ3JhYiBjbHViDQoNCiMgY2hlY2sgd2l0aGluLXBlcnNvbiB2YXJpYWJpbGl0eSBvZiBydW5uaW5nIGZyZXF1ZW5jeQ0KIyBhYnNvbHV0ZSBzY29yZXMNCnNpemUgPC0gZGYkbmV0c2l6ZQ0KeSA8LSBhcnJheShjKGRmJGZyZXFfcnVuWywsXSkpDQp4IDwtIHJlcCgxOjEyLCBzaXplKQ0KZGYgPC0gZGF0YS5mcmFtZSh5LCB4KQ0KZGYgIDwtIGRmIFsob3JkZXIoZGYkeCkpLCBdDQpkZiRpZCA8LSByZXAoMTpzaXplLCAxMikNCg0KIyBnZXQgcmFuZG9tIHNhbXBsZSBvZiA5IHBlcnNvbnMNCnNhbXBsZSA8LSBzYW1wbGUoYygxOnNpemUpLCBzaXplPTksIHJlcGxhY2U9RikNCmRmX25ldyA8LSBkcGx5cjo6ZmlsdGVyKGRmLCBpZCAlaW4lIHNhbXBsZSkNCg0KIyBwbG90IGdyb3d0aCB0cmFqZWN0b3JpZXMgb2YgcmFuZG9tIHNhbXBsZSBvZiA5IG9mIGFsbCBjbHViIG1lbWJlcnMNCnAgPC0gZ2dwbG90KGRhdGEgPSBkZl9uZXcsIGFlcyh4LCB5KSkgKyBnZW9tX2xpbmUoKSsNCiAgZmFjZXRfd3JhcCh+aWQpDQpwICsgc2NhbGVfeF9jb250aW51b3VzKGJyZWFrcyA9IHNlcSgxLCAxMiwgMSkpICsgc2NhbGVfeV9jb250aW51b3VzKGJyZWFrcyA9IHNlcSgwLCA4LCAxKSkgKyANCiAgZ2d0aXRsZSgiR3Jvd3RoIHRyYWplY3RvcmllcyBpbiBydW5uaW5nIGZyZXF1ZW5jeSBvdmVyIHRpbWUgb2YgYSByYW5kb20gc2FtcGxlIG9mIDkgYWN0b3JzIikgKw0KICB4bGFiKCJUaW1lIGluIG1vbnRocyIpICsgeWxhYigiUnVubmluZyBmcmVxdWVuY3kgaW4gdGltZXMgcGVyIHdlZWsiKQ0KDQpgYGANCg0KIyMjIHstfQ0KDQpUaGVyZSBzZWVtcyB0byBiZSAnc3VmZmljaWVudCcgd2l0aGluLXBlcnNvbiB2YXJpYWJpbGl0eSBpbiBydW5uaW5nIGJlaGF2aW9yLCBhdCBsZWFzdCBpbiBmcmVxdWVuY3kuDQoNCi0tLS0NCg0KPGJyPg0KDQojIyBOZXR3b3JrIGF1dG9jb3JyZWxhdGlvbg0KDQojIyMgey50YWJzZXQgLnRhYnNldC1mYWRlfQ0KV2UgaGF2ZSBub3cgY292ZXJlZCB0aGUgc3BvcnQgYWN0aXZpdHkgbGV2ZWxzIG9mIG91ciBjbHViLWF0aGxldGVzLCBhbmQgdGhlIGV4dGVudCB0byB3aGljaCBmcmllbmRzaGlwLSBhbmQgS3Vkby1hc3NvY2lhdGlvbnMgYXJlIHNlZ3JlZ2F0ZWQgYWxvbmcgZ2VuZGVyLiBMYXN0LCB3ZSB3aWxsIGV4cGxvcmUgaWYgZnJpZW5kc2hpcC0gYW5kIEt1ZG8tYXNzb2NpYXRpb25zIGFyZSBhbHNvIHNlZ3JlZ2F0ZWQgYWxvbmcgYWN0aXZpdHkgbGV2ZWxzLiBPciBpbiBvdGhlciB3b3JkczogZG8gcGVvcGxlIHdpdGggc2ltaWxhciBhY3Rpdml0eSBsZXZlbHMgdGVuZCB0byBzb2NpYWxpemUgdG8gYSBncmVhdGVyIGV4dGVudCAtIGJ5IGJlZnJpZW5kaW5nIG9uZSBhbm90aGVyIGFuZCBieSBleGNoYW5naW5nIEt1ZG9zIC0gZXZlbiB3aGVuIHRha2luZyBpbnRvIGFjY291bnQgdGhlIG9wcG9ydHVuaXR5IHN0cnVjdHVyZXMgZm9yICdpbnRlcmFjdGluZycgd2l0aCAoZGlzKXNpbWlsYXIgb3RoZXJzPyANCg0KV2UgdXNlIE1vcmFuJ3MgSSBzcGF0aWFsIGF1dG9jb3JyZWxhdGlvbiBtZWFzdXJlIGZvciB0aGlzLCB3aGljaCBpcyB0aGUgY29ycmVsYXRpb24gYmV0d2VlbiB0aGUgYmVoYXZpb3JhbCBzY29yZSBvZiBhY3RvciAqaSogYW5kIHRoZSAodG90YWwvbWVhbikgYmVoYXZpb3JhbCBzY29yZSBvZiBhbHRlcnMgKmoqIHRvIHdob20gKmkqIGlzIGNvbm5lY3RlZCAqKmRpcmVjdGx5KiouIFdlIGluY2x1ZGVkIHRoZSBiZWhhdmlvcmFsIHNjb3JlcyBvZiB0aGUgYWN0b3JzICpoKiB0byB3aG9tICppKiBpcyBpbmRpcmVjdGx5IHRpZWQsIGFuZCB1c2VkIHRoZSBuZWdhdGl2ZSBleHBvbmVudGlhbCBmdW5jdGlvbiBhcyBkZXNjcmliZWQgYnkgQGNoZW4yMDEzIGFzIGEgZGlzdGFuY2UtZGVjYXkgZnVuY3Rpb24gZm9yIGFzc2lnbmluZyB3ZWlnaHRzLg0KDQojIyMjIENsdWIgMQ0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFbWzFdXSAjIGdyYWIgY2x1YiANCmRmMiA8LSBjbHViZGF0YVtbMV1dICMgZ3JhYiBjbHViIA0KDQpmbmV0IDwtIG5ldHdvcms6OmFzLm5ldHdvcmsoZGYkZHljQ292YXJzJGZyaWVuZHNoaXApICMgdGFrZSBmcmllbmRzaGlwIG5ldHdvcmsNCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBrdWRvIG5ldHdvcmsNCmtuZXQxIDwtIG5ldHdvcms6OmFzLm5ldHdvcmsoa25ldFssLDFdKSAjIGxldCdzIHRha2Ugd2F2ZSAxDQoNCiMgZ2V0IGJlaGF2aW9yYWwgZGF0YQ0KZnJlcTEgPC0gZGYyJGZyZXFfcnVuWywsMV0gIyBydW5uaW5nIGZyZXF1ZW5jaWVzIHdhdmUgMQ0Kdm9sMSA8LSBkZjIkdGltZV9ydW5bLCwxXSAjIHJ1bm5pbmcgdm9sdW1lIHdhdmUgMQ0KDQojIHdlIGluY2x1ZGUgZ2VvZGlzdGFuY2VzOiBzaG9ydGVzdCBwYXRoIGxlbmd0aHMgZnJvbSBpIHRvIGoNCmZfZ2VvZGlzdGFuY2VzIDwtIHNuYTo6Z2VvZGlzdChmbmV0LCBjb3VudC5wYXRocz1UKQ0KZl9nZW9kaXN0YW5jZXMgPC0gZl9nZW9kaXN0YW5jZXMkZ2Rpc3QgDQprX2dlb2Rpc3RhbmNlcyA8LSBzbmE6Omdlb2Rpc3Qoa25ldDEsIGNvdW50LnBhdGhzPVQpDQprX2dlb2Rpc3RhbmNlcyA8LSBrX2dlb2Rpc3RhbmNlcyRnZGlzdCANCg0KIyBzZXQgdGhlIGRpc3RhbmNlICd0byB5b3Vyc2VsZicgdG8gJ0luZicNCmRpYWcoZl9nZW9kaXN0YW5jZXMpIDwtIEluZg0KZGlhZyhrX2dlb2Rpc3RhbmNlcykgPC0gSW5mDQoNCiMgYW5kIHVzZSB0aGUgbmVnYXRpdmUgZXhwb25lbnRpYWwgZGlzdGFuY2UtZGVjYXkgZnVuY3Rpb24NCmZfd2VpZ2h0czIgPC0gZXhwKC1mX2dlb2Rpc3RhbmNlcykNCmtfd2VpZ2h0czIgPC0gZXhwKC1rX2dlb2Rpc3RhbmNlcykNCg0KIyBjYWxjdWxhdGUgTW9yYW4ncyBJDQojIHdlIGRvIG5vdCByb3cgc3RhbmRhcmRpemUhDQpmX2ZyZXEgPC0gZk1vcmFuLkkoZnJlcTEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBmX3dlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQpmX3ZvbCA8LSBmTW9yYW4uSSh2b2wxLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gZl93ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0Ka19mcmVxIDwtIGZNb3Jhbi5JKGZyZXExLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0ga193ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0Ka192b2wgPC0gZk1vcmFuLkkodm9sMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGtfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCg0KIyBtYWtlIG9iamVjdCB0byBzdG9yZSByZXN1bHRzDQojIDEuIGZyZXF1ZW5jeQ0KbWF0IDwtIG1hdHJpeChOQSwgbnJvdz0yLCBuY29sPTQpDQptYXRbMSwxXSA8LSBmX2ZyZXEkb2JzZXJ2ZWQNCm1hdFsxLDJdIDwtIGZfZnJlcSRleHBlY3RlZA0KbWF0WzEsM10gPC0gZl9mcmVxJHNkDQptYXRbMSw0XSA8LSBmX2ZyZXEkcC52YWx1ZQ0KbWF0WzIsMV0gPC0ga19mcmVxJG9ic2VydmVkDQptYXRbMiwyXSA8LSBrX2ZyZXEkZXhwZWN0ZWQNCm1hdFsyLDNdIDwtIGtfZnJlcSRzZA0KbWF0WzIsNF0gPC0ga19mcmVxJHAudmFsdWUNCg0KIyAyLiB2b2x1bWUNCm1hdDIgPC0gbWF0cml4KE5BLCBucm93PTIsIG5jb2w9NCkNCm1hdDJbMSwxXSA8LSBmX3ZvbCRvYnNlcnZlZA0KbWF0MlsxLDJdIDwtIGZfdm9sJGV4cGVjdGVkDQptYXQyWzEsM10gPC0gZl92b2wkc2QNCm1hdDJbMSw0XSA8LSBmX3ZvbCRwLnZhbHVlDQptYXQyWzIsMV0gPC0ga192b2wkb2JzZXJ2ZWQNCm1hdDJbMiwyXSA8LSBrX3ZvbCRleHBlY3RlZA0KbWF0MlsyLDNdIDwtIGtfdm9sJHNkDQptYXQyWzIsNF0gPC0ga192b2wkcC52YWx1ZQ0KDQpjb2xuYW1lcyhtYXQpIDwtIGNvbG5hbWVzKG1hdDIpIDwtIGMoIm9ic2VydmVkIiwgImV4cGVjdGVkIiwgInNkIiwgInAtdmFsdWUiKQ0Kcm93bmFtZXMobWF0KSA8LSByb3duYW1lcyhtYXQyKSA8LSBjKCJmcmllbmRzaGlwIG5ldHdvcmsiLCAia3VkbyBuZXR3b3JrIikNCg0Ka25pdHI6OmthYmxlKG1hdCwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iTW9yYW4ncyBJIHN0YXRpc3RpYyBmb3Igc3BhdGlhbCBhdXRvY29ycmVsYXRpb24gYmFzZWQgb24gZ2VvZGlzdGFuY2VzIGFuZCB3ZWVrbHkgcnVubmluZyBmcmVxdWVuY3kiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQoNCmtuaXRyOjprYWJsZShtYXQyLCBkaWdpdHM9MiwgImh0bWwiLCBjYXB0aW9uPSJNb3JhbidzIEkgc3RhdGlzdGljIGZvciBzcGF0aWFsIGF1dG9jb3JyZWxhdGlvbiBiYXNlZCBvbiBnZW9kaXN0YW5jZXMgYW5kIG1vbnRobHkgcnVubmluZyB2b2x1bWUiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQpgYGANCg0KIyMjIyBDbHViIDINCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1syXV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzJdXSAjIGdyYWIgY2x1YiANCg0KZm5ldCA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGRmJGR5Y0NvdmFycyRmcmllbmRzaGlwKSAjIHRha2UgZnJpZW5kc2hpcCBuZXR3b3JrDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2Uga3VkbyBuZXR3b3JrDQprbmV0MSA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGtuZXRbLCwxXSkgIyBsZXQncyB0YWtlIHdhdmUgMQ0KDQojIGdldCBiZWhhdmlvcmFsIGRhdGENCmZyZXExIDwtIGRmMiRmcmVxX3J1blssLDFdICMgcnVubmluZyBmcmVxdWVuY2llcyB3YXZlIDENCnZvbDEgPC0gZGYyJHRpbWVfcnVuWywsMV0gIyBydW5uaW5nIHZvbHVtZSB3YXZlIDENCg0KIyB3ZSBpbmNsdWRlIGdlb2Rpc3RhbmNlczogc2hvcnRlc3QgcGF0aCBsZW5ndGhzIGZyb20gaSB0byBqDQpmX2dlb2Rpc3RhbmNlcyA8LSBzbmE6Omdlb2Rpc3QoZm5ldCwgY291bnQucGF0aHM9VCkNCmZfZ2VvZGlzdGFuY2VzIDwtIGZfZ2VvZGlzdGFuY2VzJGdkaXN0IA0Ka19nZW9kaXN0YW5jZXMgPC0gc25hOjpnZW9kaXN0KGtuZXQxLCBjb3VudC5wYXRocz1UKQ0Ka19nZW9kaXN0YW5jZXMgPC0ga19nZW9kaXN0YW5jZXMkZ2Rpc3QgDQoNCiMgc2V0IHRoZSBkaXN0YW5jZSAndG8geW91cnNlbGYnIHRvICdJbmYnDQpkaWFnKGZfZ2VvZGlzdGFuY2VzKSA8LSBJbmYNCmRpYWcoa19nZW9kaXN0YW5jZXMpIDwtIEluZg0KDQojIGFuZCB1c2UgdGhlIG5lZ2F0aXZlIGV4cG9uZW50aWFsIGRpc3RhbmNlLWRlY2F5IGZ1bmN0aW9uDQpmX3dlaWdodHMyIDwtIGV4cCgtZl9nZW9kaXN0YW5jZXMpDQprX3dlaWdodHMyIDwtIGV4cCgta19nZW9kaXN0YW5jZXMpDQoNCiMgY2FsY3VsYXRlIE1vcmFuJ3MgSQ0KIyB3ZSBkbyBub3Qgcm93IHN0YW5kYXJkaXplIQ0KZl9mcmVxIDwtIGZNb3Jhbi5JKGZyZXExLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gZl93ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KZl92b2wgPC0gZk1vcmFuLkkodm9sMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGZfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmtfZnJlcSA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGtfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmtfdm9sIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBrX3dlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KIyAxLiBmcmVxdWVuY3kNCm1hdCA8LSBtYXRyaXgoTkEsIG5yb3c9MiwgbmNvbD00KQ0KbWF0WzEsMV0gPC0gZl9mcmVxJG9ic2VydmVkDQptYXRbMSwyXSA8LSBmX2ZyZXEkZXhwZWN0ZWQNCm1hdFsxLDNdIDwtIGZfZnJlcSRzZA0KbWF0WzEsNF0gPC0gZl9mcmVxJHAudmFsdWUNCm1hdFsyLDFdIDwtIGtfZnJlcSRvYnNlcnZlZA0KbWF0WzIsMl0gPC0ga19mcmVxJGV4cGVjdGVkDQptYXRbMiwzXSA8LSBrX2ZyZXEkc2QNCm1hdFsyLDRdIDwtIGtfZnJlcSRwLnZhbHVlDQoNCiMgMi4gdm9sdW1lDQptYXQyIDwtIG1hdHJpeChOQSwgbnJvdz0yLCBuY29sPTQpDQptYXQyWzEsMV0gPC0gZl92b2wkb2JzZXJ2ZWQNCm1hdDJbMSwyXSA8LSBmX3ZvbCRleHBlY3RlZA0KbWF0MlsxLDNdIDwtIGZfdm9sJHNkDQptYXQyWzEsNF0gPC0gZl92b2wkcC52YWx1ZQ0KbWF0MlsyLDFdIDwtIGtfdm9sJG9ic2VydmVkDQptYXQyWzIsMl0gPC0ga192b2wkZXhwZWN0ZWQNCm1hdDJbMiwzXSA8LSBrX3ZvbCRzZA0KbWF0MlsyLDRdIDwtIGtfdm9sJHAudmFsdWUNCg0KY29sbmFtZXMobWF0KSA8LSBjb2xuYW1lcyhtYXQyKSA8LSBjKCJvYnNlcnZlZCIsICJleHBlY3RlZCIsICJzZCIsICJwLXZhbHVlIikNCnJvd25hbWVzKG1hdCkgPC0gcm93bmFtZXMobWF0MikgPC0gYygiZnJpZW5kc2hpcCBuZXR3b3JrIiwgImt1ZG8gbmV0d29yayIpDQoNCmtuaXRyOjprYWJsZShtYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249Ik1vcmFuJ3MgSSBzdGF0aXN0aWMgZm9yIHNwYXRpYWwgYXV0b2NvcnJlbGF0aW9uIGJhc2VkIG9uIGdlb2Rpc3RhbmNlcyBhbmQgd2Vla2x5IHJ1bm5pbmcgZnJlcXVlbmN5IikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KDQprbml0cjo6a2FibGUobWF0MiwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iTW9yYW4ncyBJIHN0YXRpc3RpYyBmb3Igc3BhdGlhbCBhdXRvY29ycmVsYXRpb24gYmFzZWQgb24gZ2VvZGlzdGFuY2VzIGFuZCBtb250aGx5IHJ1bm5pbmcgdm9sdW1lIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCg0KIyMjIyBDbHViIDMNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1szXV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzNdXSAjIGdyYWIgY2x1YiANCg0KZm5ldCA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGRmJGR5Y0NvdmFycyRmcmllbmRzaGlwKSAjIHRha2UgZnJpZW5kc2hpcCBuZXR3b3JrDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2Uga3VkbyBuZXR3b3JrDQprbmV0MSA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGtuZXRbLCwxXSkgIyBsZXQncyB0YWtlIHdhdmUgMQ0KDQojIGdldCBiZWhhdmlvcmFsIGRhdGENCmZyZXExIDwtIGRmMiRmcmVxX3J1blssLDFdICMgcnVubmluZyBmcmVxdWVuY2llcyB3YXZlIDENCnZvbDEgPC0gZGYyJHRpbWVfcnVuWywsMV0gIyBydW5uaW5nIHZvbHVtZSB3YXZlIDENCg0KIyB3ZSBpbmNsdWRlIGdlb2Rpc3RhbmNlczogc2hvcnRlc3QgcGF0aCBsZW5ndGhzIGZyb20gaSB0byBqDQpmX2dlb2Rpc3RhbmNlcyA8LSBzbmE6Omdlb2Rpc3QoZm5ldCwgY291bnQucGF0aHM9VCkNCmZfZ2VvZGlzdGFuY2VzIDwtIGZfZ2VvZGlzdGFuY2VzJGdkaXN0IA0Ka19nZW9kaXN0YW5jZXMgPC0gc25hOjpnZW9kaXN0KGtuZXQxLCBjb3VudC5wYXRocz1UKQ0Ka19nZW9kaXN0YW5jZXMgPC0ga19nZW9kaXN0YW5jZXMkZ2Rpc3QgDQoNCiMgc2V0IHRoZSBkaXN0YW5jZSAndG8geW91cnNlbGYnIHRvICdJbmYnDQpkaWFnKGZfZ2VvZGlzdGFuY2VzKSA8LSBJbmYNCmRpYWcoa19nZW9kaXN0YW5jZXMpIDwtIEluZg0KDQojIGFuZCB1c2UgdGhlIG5lZ2F0aXZlIGV4cG9uZW50aWFsIGRpc3RhbmNlLWRlY2F5IGZ1bmN0aW9uDQpmX3dlaWdodHMyIDwtIGV4cCgtZl9nZW9kaXN0YW5jZXMpDQprX3dlaWdodHMyIDwtIGV4cCgta19nZW9kaXN0YW5jZXMpDQoNCiMgY2FsY3VsYXRlIE1vcmFuJ3MgSQ0KIyB3ZSBkbyBub3Qgcm93IHN0YW5kYXJkaXplIQ0KZl9mcmVxIDwtIGZNb3Jhbi5JKGZyZXExLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gZl93ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KZl92b2wgPC0gZk1vcmFuLkkodm9sMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGZfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmtfZnJlcSA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGtfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmtfdm9sIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBrX3dlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KIyAxLiBmcmVxdWVuY3kNCm1hdCA8LSBtYXRyaXgoTkEsIG5yb3c9MiwgbmNvbD00KQ0KbWF0WzEsMV0gPC0gZl9mcmVxJG9ic2VydmVkDQptYXRbMSwyXSA8LSBmX2ZyZXEkZXhwZWN0ZWQNCm1hdFsxLDNdIDwtIGZfZnJlcSRzZA0KbWF0WzEsNF0gPC0gZl9mcmVxJHAudmFsdWUNCm1hdFsyLDFdIDwtIGtfZnJlcSRvYnNlcnZlZA0KbWF0WzIsMl0gPC0ga19mcmVxJGV4cGVjdGVkDQptYXRbMiwzXSA8LSBrX2ZyZXEkc2QNCm1hdFsyLDRdIDwtIGtfZnJlcSRwLnZhbHVlDQoNCiMgMi4gdm9sdW1lDQptYXQyIDwtIG1hdHJpeChOQSwgbnJvdz0yLCBuY29sPTQpDQptYXQyWzEsMV0gPC0gZl92b2wkb2JzZXJ2ZWQNCm1hdDJbMSwyXSA8LSBmX3ZvbCRleHBlY3RlZA0KbWF0MlsxLDNdIDwtIGZfdm9sJHNkDQptYXQyWzEsNF0gPC0gZl92b2wkcC52YWx1ZQ0KbWF0MlsyLDFdIDwtIGtfdm9sJG9ic2VydmVkDQptYXQyWzIsMl0gPC0ga192b2wkZXhwZWN0ZWQNCm1hdDJbMiwzXSA8LSBrX3ZvbCRzZA0KbWF0MlsyLDRdIDwtIGtfdm9sJHAudmFsdWUNCg0KY29sbmFtZXMobWF0KSA8LSBjb2xuYW1lcyhtYXQyKSA8LSBjKCJvYnNlcnZlZCIsICJleHBlY3RlZCIsICJzZCIsICJwLXZhbHVlIikNCnJvd25hbWVzKG1hdCkgPC0gcm93bmFtZXMobWF0MikgPC0gYygiZnJpZW5kc2hpcCBuZXR3b3JrIiwgImt1ZG8gbmV0d29yayIpDQoNCmtuaXRyOjprYWJsZShtYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249Ik1vcmFuJ3MgSSBzdGF0aXN0aWMgZm9yIHNwYXRpYWwgYXV0b2NvcnJlbGF0aW9uIGJhc2VkIG9uIGdlb2Rpc3RhbmNlcyBhbmQgd2Vla2x5IHJ1bm5pbmcgZnJlcXVlbmN5IikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KDQprbml0cjo6a2FibGUobWF0MiwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iTW9yYW4ncyBJIHN0YXRpc3RpYyBmb3Igc3BhdGlhbCBhdXRvY29ycmVsYXRpb24gYmFzZWQgb24gZ2VvZGlzdGFuY2VzIGFuZCBtb250aGx5IHJ1bm5pbmcgdm9sdW1lIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCg0KIyMjIyBDbHViIDQNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hW1s0XV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzRdXSAjIGdyYWIgY2x1YiANCg0KZm5ldCA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGRmJGR5Y0NvdmFycyRmcmllbmRzaGlwKSAjIHRha2UgZnJpZW5kc2hpcCBuZXR3b3JrDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2Uga3VkbyBuZXR3b3JrDQprbmV0MSA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGtuZXRbLCwxXSkgIyBsZXQncyB0YWtlIHdhdmUgMQ0KDQojIGdldCBiZWhhdmlvcmFsIGRhdGENCmZyZXExIDwtIGRmMiRmcmVxX3J1blssLDFdICMgcnVubmluZyBmcmVxdWVuY2llcyB3YXZlIDENCnZvbDEgPC0gZGYyJHRpbWVfcnVuWywsMV0gIyBydW5uaW5nIHZvbHVtZSB3YXZlIDENCg0KIyB3ZSBpbmNsdWRlIGdlb2Rpc3RhbmNlczogc2hvcnRlc3QgcGF0aCBsZW5ndGhzIGZyb20gaSB0byBqDQpmX2dlb2Rpc3RhbmNlcyA8LSBzbmE6Omdlb2Rpc3QoZm5ldCwgY291bnQucGF0aHM9VCkNCmZfZ2VvZGlzdGFuY2VzIDwtIGZfZ2VvZGlzdGFuY2VzJGdkaXN0IA0Ka19nZW9kaXN0YW5jZXMgPC0gc25hOjpnZW9kaXN0KGtuZXQxLCBjb3VudC5wYXRocz1UKQ0Ka19nZW9kaXN0YW5jZXMgPC0ga19nZW9kaXN0YW5jZXMkZ2Rpc3QgDQoNCiMgc2V0IHRoZSBkaXN0YW5jZSAndG8geW91cnNlbGYnIHRvICdJbmYnDQpkaWFnKGZfZ2VvZGlzdGFuY2VzKSA8LSBJbmYNCmRpYWcoa19nZW9kaXN0YW5jZXMpIDwtIEluZg0KDQojIGFuZCB1c2UgdGhlIG5lZ2F0aXZlIGV4cG9uZW50aWFsIGRpc3RhbmNlLWRlY2F5IGZ1bmN0aW9uDQpmX3dlaWdodHMyIDwtIGV4cCgtZl9nZW9kaXN0YW5jZXMpDQprX3dlaWdodHMyIDwtIGV4cCgta19nZW9kaXN0YW5jZXMpDQoNCiMgY2FsY3VsYXRlIE1vcmFuJ3MgSQ0KIyB3ZSBkbyBub3Qgcm93IHN0YW5kYXJkaXplIQ0KZl9mcmVxIDwtIGZNb3Jhbi5JKGZyZXExLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gZl93ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KZl92b2wgPC0gZk1vcmFuLkkodm9sMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGZfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmtfZnJlcSA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGtfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmtfdm9sIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBrX3dlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KIyAxLiBmcmVxdWVuY3kNCm1hdCA8LSBtYXRyaXgoTkEsIG5yb3c9MiwgbmNvbD00KQ0KbWF0WzEsMV0gPC0gZl9mcmVxJG9ic2VydmVkDQptYXRbMSwyXSA8LSBmX2ZyZXEkZXhwZWN0ZWQNCm1hdFsxLDNdIDwtIGZfZnJlcSRzZA0KbWF0WzEsNF0gPC0gZl9mcmVxJHAudmFsdWUNCm1hdFsyLDFdIDwtIGtfZnJlcSRvYnNlcnZlZA0KbWF0WzIsMl0gPC0ga19mcmVxJGV4cGVjdGVkDQptYXRbMiwzXSA8LSBrX2ZyZXEkc2QNCm1hdFsyLDRdIDwtIGtfZnJlcSRwLnZhbHVlDQoNCiMgMi4gdm9sdW1lDQptYXQyIDwtIG1hdHJpeChOQSwgbnJvdz0yLCBuY29sPTQpDQptYXQyWzEsMV0gPC0gZl92b2wkb2JzZXJ2ZWQNCm1hdDJbMSwyXSA8LSBmX3ZvbCRleHBlY3RlZA0KbWF0MlsxLDNdIDwtIGZfdm9sJHNkDQptYXQyWzEsNF0gPC0gZl92b2wkcC52YWx1ZQ0KbWF0MlsyLDFdIDwtIGtfdm9sJG9ic2VydmVkDQptYXQyWzIsMl0gPC0ga192b2wkZXhwZWN0ZWQNCm1hdDJbMiwzXSA8LSBrX3ZvbCRzZA0KbWF0MlsyLDRdIDwtIGtfdm9sJHAudmFsdWUNCg0KY29sbmFtZXMobWF0KSA8LSBjb2xuYW1lcyhtYXQyKSA8LSBjKCJvYnNlcnZlZCIsICJleHBlY3RlZCIsICJzZCIsICJwLXZhbHVlIikNCnJvd25hbWVzKG1hdCkgPC0gcm93bmFtZXMobWF0MikgPC0gYygiZnJpZW5kc2hpcCBuZXR3b3JrIiwgImt1ZG8gbmV0d29yayIpDQoNCmtuaXRyOjprYWJsZShtYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249Ik1vcmFuJ3MgSSBzdGF0aXN0aWMgZm9yIHNwYXRpYWwgYXV0b2NvcnJlbGF0aW9uIGJhc2VkIG9uIGdlb2Rpc3RhbmNlcyBhbmQgd2Vla2x5IHJ1bm5pbmcgZnJlcXVlbmN5IikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KDQprbml0cjo6a2FibGUobWF0MiwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iTW9yYW4ncyBJIHN0YXRpc3RpYyBmb3Igc3BhdGlhbCBhdXRvY29ycmVsYXRpb24gYmFzZWQgb24gZ2VvZGlzdGFuY2VzIGFuZCBtb250aGx5IHJ1bm5pbmcgdm9sdW1lIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCiMjIyMgQ2x1YiA1DQpgYGB7cn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYVtbNV1dICMgZ3JhYiBjbHViIA0KZGYyIDwtIGNsdWJkYXRhW1s1XV0gIyBncmFiIGNsdWIgDQoNCmZuZXQgPC0gbmV0d29yazo6YXMubmV0d29yayhkZiRkeWNDb3ZhcnMkZnJpZW5kc2hpcCkgIyB0YWtlIGZyaWVuZHNoaXAgbmV0d29yaw0Ka25ldCA8LSBkZiRkZXB2YXJzJGt1ZG9uZXQgIyB0YWtlIGt1ZG8gbmV0d29yaw0Ka25ldDEgPC0gbmV0d29yazo6YXMubmV0d29yayhrbmV0WywsMV0pICMgbGV0J3MgdGFrZSB3YXZlIDENCg0KIyBnZXQgYmVoYXZpb3JhbCBkYXRhDQpmcmVxMSA8LSBkZjIkZnJlcV9ydW5bLCwxXSAjIHJ1bm5pbmcgZnJlcXVlbmNpZXMgd2F2ZSAxDQp2b2wxIDwtIGRmMiR0aW1lX3J1blssLDFdICMgcnVubmluZyB2b2x1bWUgd2F2ZSAxDQoNCiMgd2UgaW5jbHVkZSBnZW9kaXN0YW5jZXM6IHNob3J0ZXN0IHBhdGggbGVuZ3RocyBmcm9tIGkgdG8gag0KZl9nZW9kaXN0YW5jZXMgPC0gc25hOjpnZW9kaXN0KGZuZXQsIGNvdW50LnBhdGhzPVQpDQpmX2dlb2Rpc3RhbmNlcyA8LSBmX2dlb2Rpc3RhbmNlcyRnZGlzdCANCmtfZ2VvZGlzdGFuY2VzIDwtIHNuYTo6Z2VvZGlzdChrbmV0MSwgY291bnQucGF0aHM9VCkNCmtfZ2VvZGlzdGFuY2VzIDwtIGtfZ2VvZGlzdGFuY2VzJGdkaXN0IA0KDQojIHNldCB0aGUgZGlzdGFuY2UgJ3RvIHlvdXJzZWxmJyB0byAnSW5mJw0KZGlhZyhmX2dlb2Rpc3RhbmNlcykgPC0gSW5mDQpkaWFnKGtfZ2VvZGlzdGFuY2VzKSA8LSBJbmYNCg0KIyBhbmQgdXNlIHRoZSBuZWdhdGl2ZSBleHBvbmVudGlhbCBkaXN0YW5jZS1kZWNheSBmdW5jdGlvbg0KZl93ZWlnaHRzMiA8LSBleHAoLWZfZ2VvZGlzdGFuY2VzKQ0Ka193ZWlnaHRzMiA8LSBleHAoLWtfZ2VvZGlzdGFuY2VzKQ0KDQojIGNhbGN1bGF0ZSBNb3JhbidzIEkNCiMgd2UgZG8gbm90IHJvdyBzdGFuZGFyZGl6ZSENCmZfZnJlcSA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGZfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmZfdm9sIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBmX3dlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQprX2ZyZXEgPC0gZk1vcmFuLkkoZnJlcTEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBrX3dlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQprX3ZvbCA8LSBmTW9yYW4uSSh2b2wxLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0ga193ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KDQojIG1ha2Ugb2JqZWN0IHRvIHN0b3JlIHJlc3VsdHMNCiMgMS4gZnJlcXVlbmN5DQptYXQgPC0gbWF0cml4KE5BLCBucm93PTIsIG5jb2w9NCkNCm1hdFsxLDFdIDwtIGZfZnJlcSRvYnNlcnZlZA0KbWF0WzEsMl0gPC0gZl9mcmVxJGV4cGVjdGVkDQptYXRbMSwzXSA8LSBmX2ZyZXEkc2QNCm1hdFsxLDRdIDwtIGZfZnJlcSRwLnZhbHVlDQptYXRbMiwxXSA8LSBrX2ZyZXEkb2JzZXJ2ZWQNCm1hdFsyLDJdIDwtIGtfZnJlcSRleHBlY3RlZA0KbWF0WzIsM10gPC0ga19mcmVxJHNkDQptYXRbMiw0XSA8LSBrX2ZyZXEkcC52YWx1ZQ0KDQojIDIuIHZvbHVtZQ0KbWF0MiA8LSBtYXRyaXgoTkEsIG5yb3c9MiwgbmNvbD00KQ0KbWF0MlsxLDFdIDwtIGZfdm9sJG9ic2VydmVkDQptYXQyWzEsMl0gPC0gZl92b2wkZXhwZWN0ZWQNCm1hdDJbMSwzXSA8LSBmX3ZvbCRzZA0KbWF0MlsxLDRdIDwtIGZfdm9sJHAudmFsdWUNCm1hdDJbMiwxXSA8LSBrX3ZvbCRvYnNlcnZlZA0KbWF0MlsyLDJdIDwtIGtfdm9sJGV4cGVjdGVkDQptYXQyWzIsM10gPC0ga192b2wkc2QNCm1hdDJbMiw0XSA8LSBrX3ZvbCRwLnZhbHVlDQoNCmNvbG5hbWVzKG1hdCkgPC0gY29sbmFtZXMobWF0MikgPC0gYygib2JzZXJ2ZWQiLCAiZXhwZWN0ZWQiLCAic2QiLCAicC12YWx1ZSIpDQpyb3duYW1lcyhtYXQpIDwtIHJvd25hbWVzKG1hdDIpIDwtIGMoImZyaWVuZHNoaXAgbmV0d29yayIsICJrdWRvIG5ldHdvcmsiKQ0KDQprbml0cjo6a2FibGUobWF0LCBkaWdpdHM9MiwgImh0bWwiLCBjYXB0aW9uPSJNb3JhbidzIEkgc3RhdGlzdGljIGZvciBzcGF0aWFsIGF1dG9jb3JyZWxhdGlvbiBiYXNlZCBvbiBnZW9kaXN0YW5jZXMgYW5kIHdlZWtseSBydW5uaW5nIGZyZXF1ZW5jeSIpICU+JSANCiAga2FibGVFeHRyYTo6a2FibGVfc3R5bGluZyhib290c3RyYXBfb3B0aW9ucyA9IGMoInN0cmlwZWQiLCAiaG92ZXIiKSkNCg0Ka25pdHI6OmthYmxlKG1hdDIsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249Ik1vcmFuJ3MgSSBzdGF0aXN0aWMgZm9yIHNwYXRpYWwgYXV0b2NvcnJlbGF0aW9uIGJhc2VkIG9uIGdlb2Rpc3RhbmNlcyBhbmQgbW9udGhseSBydW5uaW5nIHZvbHVtZSIpICU+JSANCiAga2FibGVFeHRyYTo6a2FibGVfc3R5bGluZyhib290c3RyYXBfb3B0aW9ucyA9IGMoInN0cmlwZWQiLCAiaG92ZXIiKSkNCmBgYA0KDQojIyMgey19DQoNCkhlcmUsIHRoZSBNb3JhbidzIEkgc3RhdGlzdGljIHRlc3RzIHdoZXRoZXIgY2x1YiBtZW1iZXJzIHRoYXQgYXJlICpjbG9zZXIgdG8gb25lIGFub3RoZXIqIChpLmUuLCBoYXZpbmcgYSBzaG9ydGVyIGdlb2Rlc2ljL3BhdGggbGVuZ3RoKSwgYXJlIG1vcmUgYSBzaW1pbGFyIHdpdGggcmVzcGVjdCB0byB0aGVpciBiZWhhdmlvciwgdW5kZXIgdGhlIG51bGwgaHlwb3RoZXNpcyB0aGF0IGJlaGF2aW9yIGlzICdyYW5kb21seSBkaXN0cmlidXRlZCcgYW1vbmcgdGhlIGNsdWIgbWVtYmVycy4NCg0KV2Ugb2JzZXJ2ZSB0aGF0LCBpbmRlZWQsIGZyaWVuZHMgdGhhdCBhcmUgY2xvc2VyIHRvIG9uZSBhbm90aGVyIGFyZSBtb3JlIGFsaWtlLCBhbmQgZXNwZWNpYWxseSAic3Ryb25nIHRpZSIgZnJpZW5kcyAoaW5kaWNhdGVkIGJ5IHRoZSBzdHJvbmdseSBzaWduaWZpY2FudCBNb3JhbidzIEkgc3RhdGlzdGljcyBvbiB0aGUgS3VkbyBuZXR3b3JrcykuIEFkZGl0aW9uYWwgYW5hbHlzZXMgKG5vdCBzaG93biBoZXJlKSByZXZlYWxlZCB0aGF0IGF1dG9jb3JyZWxhdGlvbiB3YXMgZXZlbiBzdHJvbmdlciB3aXRob3V0IHRoZSBkaXN0YW5jZS1kZWNheSBmdW5jdGlvbiwgd2hpY2ggc3VnZ2VzdHMgdGhhdCBlc3BlY2lhbGx5IGNsb3NlIGFsdGVycyAod2l0aCBwYXRoIGxlbmd0aCBvbmUpIGFyZSBzaW1pbGFyLiANCg0KLS0tLQ0KDQo8YnI+DQoNCiMgRWdvcyB7I2Vnb3N9DQoNCkZvciB0aGUgZWdvbmV0cywgd2Ugd2VudCB0d28gbGV2ZWxzIGRlZXA6IDEpIHdlIG1hcHBlZCBhbGwgdGhlIG90aGVycyBTdHJhdmEgdXNlcnMgdGhhdCBhcmUgZm9sbG93ZWQgYnkgZWdvLCAyKSBhbmQgYWxsIHRoZSBTdHJhdmEgdXNlcnMgdGhhdCBhcmUgZm9sbG93ZWQgYnkgZWdvJ3MgYWx0ZXJzIChpLmUuICJmcmllbmRzIG9mIGZyaWVuZHMiKTsgd2UgbWFwcGVkIGFsbCB0aWVzIGRlZmluZWQgb24gdGhpcyBzZXQgKHdoaWNoIHdlIGRlZmluZSBhcyBhIDIuNSBkZWdyZWUgZWdvLWNlbnRlcmVkIG5ldHdvcmspLiANCg0KDQpMZXQncyBzZWUgd2hhdCAgdGhlIHJlc3VsdGluZyBuZXR3b3JrcyBsb29rIGxpa2UuDQoNCiMjIDIuNSBkZWdyZWUNCg0KIyMjIHsudGFic2V0IC50YWJzZXQtZmFkZX0NCg0KIyMjIyBFMQ0KYGBge3IgZmlnLmhlaWdodCA9IDEyLCBmaWcud2lkdGggPSAxMn0NCmRmIDwtIGVnb2RhdGEyLjVbWzFdXSAjZ3JhYiBlZ29uZXQgDQpmbmV0IDwtIFJTaWVuYTo6Y29EeWFkQ292YXIoZGF0YS5tYXRyaXgoZGYkZnJpZW5kc2hpcCkpICN0YWtlIGZyaWVuZHNoaXAgbWF0cml4DQpHIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGZuZXQsIG1vZGUgPSAiZGlyZWN0ZWQiLCBkaWFnID0gRkFMU0UpICNtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KDQojIGlkZW50aWZ5IGVnbydzIGFsdGVycyAoMS4wKQ0KZSA8LSBhcy5kYXRhLmZyYW1lKGdldC5lZGdlbGlzdChHKSkNCmNvbG5hbWVzKGUpIDwtIGMoImkiLCAiaiIpDQplJGFsdGVyIDwtIGlmZWxzZShlJGkgPT0gdmVydGV4X2F0dHIoRykkbmFtZVsxXSwgMSwgMCkgI2lmIGVnbyBpIGZvbGxvd3MgYWN0b3IgaiwgaiBpcyBlZ28ncyBhbHRlcg0KDQojIG1ha2UgYWN0b3JzIChlZ28sIDEuMC1hbHRlcjsgMi4wLWFsdGVycykgaWRlbnRpZmlhYmxlDQp2ZXJ0ZXhfYXR0cihHKSRzaGFwZSA8LSBjKCJzcXVhcmUiLCByZXAoImNpcmNsZSIsIChucm93KGZuZXQpIC0gMSkpKSAjIGVnbyA9IHNxdWFyZWQNCnZlcnRleF9hdHRyKEcpJHNpemUgPC0gYyg4LCByZXAoNCwgKG5yb3coZm5ldCkgLSAxKSkpICMgYW5kIGJpZ2dlcg0KdmVydGV4X2F0dHIoRykkY29sb3IgPC0gaWZlbHNlKHZlcnRleF9hdHRyKEcpJG5hbWUgPT0gdmVydGV4X2F0dHIoRykkbmFtZVsxXSwgIiNCRUJBREEiLCBpZmVsc2UodmVydGV4X2F0dHIoRykkbmFtZSAlaW4lIGUkaltlJGFsdGVyPT0xXSwgIiNGRkZGQjMiLCAiIzhERDNDNyIpKQ0KDQoNCiMgcGxvdA0KcGFyKGJnPSJ3aGl0ZSIpDQpwbG90KHNpbXBsaWZ5KEcpLA0KICAgICANCiAgICAgbWFpbiA9ICIyLjUgZWdvLWNlbnRlcmVkIG5ldHdvcmsgb2YgZGlyZWN0ZWQgU1RSQVZBIGZyaWVuZHNoaXBzIiwNCiAgICAgc3ViID0gImVnbyBpcyBwdXJwbGUgc3F1YXJlZCBub2RlLCB0aGVpciBhbHRlcnMgKDEuMCkgYXJlIHllbGxvdyBub2RlcywgYWx0ZXJzIG9mIGFsdGVycyAoMi4wKSBhcmUgZ3JlZW4gbm9kZXMiLA0KICAgICANCiAgICAgDQogICAgICMgPT09IHZlcnRleA0KICAgICB2ZXJ0ZXguZnJhbWUuY29sb3IgPSJibGFjayIsICAgICAgICAgIA0KICAgICB2ZXJ0ZXguc2hhcGU9dmVydGV4X2F0dHIoRykkc2hhcGUsICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LnNpemU9dmVydGV4X2F0dHIoRykkc2l6ZSwNCiAgICAgdmVydGV4LnNpemUyPU5BLCAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgDQogICAgICMgPT09IHZlcnRleCBsYWJlbA0KICAgICB2ZXJ0ZXgubGFiZWw9TkEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmZhbWlseT0iVGltZXMiLCAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5mb250PTIsICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5jZXg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmRpc3Q9MCwgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmRlZ3JlZT0wICwgICAgICAgICAgICAgICAgICAgICAgDQogICAgIA0KICAgICAjID09PSBFZGdlDQogICAgIGVkZ2UuY29sb3I9ImJsYWNrIiwgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS53aWR0aD0xLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2UuYXJyb3cuc2l6ZT0wLCAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS5hcnJvdy53aWR0aD0wLCAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS5sdHk9InNvbGlkIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLmN1cnZlZD0wKQ0KYGBgDQoNCiMjIyMgRTINCmBgYHtyIGZpZy5oZWlnaHQgPSAxMiwgZmlnLndpZHRoID0gMTJ9DQpkZiA8LSBlZ29kYXRhMi41W1syXV0gI2dyYWIgZWdvbmV0IA0KZm5ldCA8LSBSU2llbmE6OmNvRHlhZENvdmFyKGRhdGEubWF0cml4KGRmJGZyaWVuZHNoaXApKSAjdGFrZSBmcmllbmRzaGlwIG1hdHJpeA0KRyA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChmbmV0LCBtb2RlID0gImRpcmVjdGVkIiwgZGlhZyA9IEZBTFNFKSAjbWFrZSBhbiAnaWdyYXBoIG9iamVjdCcNCg0KIyBpZGVudGlmeSBlZ28ncyBhbHRlcnMgKDEuMCkNCmUgPC0gYXMuZGF0YS5mcmFtZShnZXQuZWRnZWxpc3QoRykpDQpjb2xuYW1lcyhlKSA8LSBjKCJpIiwgImoiKQ0KZSRhbHRlciA8LSBpZmVsc2UoZSRpID09IHZlcnRleF9hdHRyKEcpJG5hbWVbMV0sIDEsIDApICNpZiBlZ28gaSBmb2xsb3dzIGFjdG9yIGosIGogaXMgZWdvJ3MgYWx0ZXINCg0KIyBtYWtlIGFjdG9ycyAoZWdvLCAxLjAtYWx0ZXI7IDIuMC1hbHRlcnMpIGlkZW50aWZpYWJsZQ0KdmVydGV4X2F0dHIoRykkc2hhcGUgPC0gYygic3F1YXJlIiwgcmVwKCJjaXJjbGUiLCAobnJvdyhmbmV0KSAtIDEpKSkgIyBlZ28gPSBzcXVhcmVkDQp2ZXJ0ZXhfYXR0cihHKSRzaXplIDwtIGMoOCwgcmVwKDQsIChucm93KGZuZXQpIC0gMSkpKSAjIGFuZCBiaWdnZXINCnZlcnRleF9hdHRyKEcpJGNvbG9yIDwtIGlmZWxzZSh2ZXJ0ZXhfYXR0cihHKSRuYW1lID09IHZlcnRleF9hdHRyKEcpJG5hbWVbMV0sICIjQkVCQURBIiwgaWZlbHNlKHZlcnRleF9hdHRyKEcpJG5hbWUgJWluJSBlJGpbZSRhbHRlcj09MV0sICIjRkZGRkIzIiwgIiM4REQzQzciKSkNCg0KDQojIHBsb3QNCnBhcihiZz0id2hpdGUiKQ0KcGxvdChzaW1wbGlmeShHKSwNCiAgICAgDQogICAgIG1haW4gPSAiMi41IGVnby1jZW50ZXJlZCBuZXR3b3JrIG9mIGRpcmVjdGVkIFNUUkFWQSBmcmllbmRzaGlwcyIsDQogICAgIHN1YiA9ICJlZ28gaXMgcHVycGxlIHNxdWFyZWQgbm9kZSwgdGhlaXIgYWx0ZXJzICgxLjApIGFyZSB5ZWxsb3cgbm9kZXMsIGFsdGVycyBvZiBhbHRlcnMgKDIuMCkgYXJlIGdyZWVuIG5vZGVzIiwNCiAgICAgDQogICAgIA0KICAgICAjID09PSB2ZXJ0ZXgNCiAgICAgdmVydGV4LmZyYW1lLmNvbG9yID0iYmxhY2siLCAgICAgICAgICANCiAgICAgdmVydGV4LnNoYXBlPXZlcnRleF9hdHRyKEcpJHNoYXBlLCAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5zaXplPXZlcnRleF9hdHRyKEcpJHNpemUsDQogICAgIHZlcnRleC5zaXplMj1OQSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIA0KICAgICAjID09PSB2ZXJ0ZXggbGFiZWwNCiAgICAgdmVydGV4LmxhYmVsPU5BLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5mYW1pbHk9IlRpbWVzIiwgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuZm9udD0yLCAgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuY2V4PTEsICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5kaXN0PTAsICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5kZWdyZWU9MCAsICAgICAgICAgICAgICAgICAgICAgIA0KICAgICANCiAgICAgIyA9PT0gRWRnZQ0KICAgICBlZGdlLmNvbG9yPSJibGFjayIsICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2Uud2lkdGg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLmFycm93LnNpemU9MCwgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2UuYXJyb3cud2lkdGg9MCwgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2UubHR5PSJzb2xpZCIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS5jdXJ2ZWQ9MCkNCmBgYA0KDQojIyMjIEUzDQoNCmBgYHtyIGZpZy5oZWlnaHQgPSAxMiwgZmlnLndpZHRoID0gMTJ9DQpkZiA8LSBlZ29kYXRhMi41W1szXV0gI2dyYWIgZWdvbmV0IA0KZm5ldCA8LSBSU2llbmE6OmNvRHlhZENvdmFyKGRhdGEubWF0cml4KGRmJGZyaWVuZHNoaXApKSAjdGFrZSBmcmllbmRzaGlwIG1hdHJpeA0KRyA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChmbmV0LCBtb2RlID0gImRpcmVjdGVkIiwgZGlhZyA9IEZBTFNFKSAjbWFrZSBhbiAnaWdyYXBoIG9iamVjdCcNCg0KIyBpZGVudGlmeSBlZ28gKHRoZSBmaXJzdCBub2RlKQ0KdmVydGV4X2F0dHIoRykkbmFtZVsxXSA8LSAiZWdvIg0KDQojIGlkZW50aWZ5IGVnbydzIGFsdGVycyAoMS4wKQ0KZSA8LSBhcy5kYXRhLmZyYW1lKGdldC5lZGdlbGlzdChHKSkNCmNvbG5hbWVzKGUpIDwtIGMoImkiLCAiaiIpDQplJGFsdGVyIDwtIGlmZWxzZShlJGkgPT0gdmVydGV4X2F0dHIoRykkbmFtZVsxXSwgMSwgMCkgI2lmIGVnbyBpIGZvbGxvd3MgYWN0b3IgaiwgaiBpcyBlZ28ncyBhbHRlcg0KDQojIG1ha2UgYWN0b3JzIChlZ28sIDEuMC1hbHRlcjsgMi4wLWFsdGVycykgaWRlbnRpZmlhYmxlDQp2ZXJ0ZXhfYXR0cihHKSRzaGFwZSA8LSBjKCJzcXVhcmUiLCByZXAoImNpcmNsZSIsIChucm93KGZuZXQpIC0gMSkpKSAjIGVnbyA9IHNxdWFyZWQNCnZlcnRleF9hdHRyKEcpJHNpemUgPC0gYyg4LCByZXAoNCwgKG5yb3coZm5ldCkgLSAxKSkpICMgYW5kIGJpZ2dlcg0KdmVydGV4X2F0dHIoRykkY29sb3IgPC0gaWZlbHNlKHZlcnRleF9hdHRyKEcpJG5hbWUgPT0gdmVydGV4X2F0dHIoRykkbmFtZVsxXSwgIiNCRUJBREEiLCBpZmVsc2UodmVydGV4X2F0dHIoRykkbmFtZSAlaW4lIGUkaltlJGFsdGVyPT0xXSwgIiNGRkZGQjMiLCAiIzhERDNDNyIpKQ0KDQoNCiMgcGxvdA0KcGFyKGJnPSJ3aGl0ZSIpDQpwbG90KHNpbXBsaWZ5KEcpLA0KICAgICANCiAgICAgbWFpbiA9ICIyLjUgZWdvLWNlbnRlcmVkIG5ldHdvcmsgb2YgZGlyZWN0ZWQgU1RSQVZBIGZyaWVuZHNoaXBzIiwNCiAgICAgc3ViID0gImVnbyBpcyBwdXJwbGUgc3F1YXJlZCBub2RlLCB0aGVpciBhbHRlcnMgKDEuMCkgYXJlIHllbGxvdyBub2RlcywgYWx0ZXJzIG9mIGFsdGVycyAoMi4wKSBhcmUgZ3JlZW4gbm9kZXMiLA0KICAgICANCiAgICAgDQogICAgICMgPT09IHZlcnRleA0KICAgICB2ZXJ0ZXguZnJhbWUuY29sb3IgPSJibGFjayIsICAgICAgICAgIA0KICAgICB2ZXJ0ZXguc2hhcGU9dmVydGV4X2F0dHIoRykkc2hhcGUsICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LnNpemU9dmVydGV4X2F0dHIoRykkc2l6ZSwNCiAgICAgdmVydGV4LnNpemUyPU5BLCAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgDQogICAgICMgPT09IHZlcnRleCBsYWJlbA0KICAgICB2ZXJ0ZXgubGFiZWw9TkEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmZhbWlseT0iVGltZXMiLCAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5mb250PTIsICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5jZXg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmRpc3Q9MCwgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmRlZ3JlZT0wICwgICAgICAgICAgICAgICAgICAgICAgDQogICAgIA0KICAgICAjID09PSBFZGdlDQogICAgIGVkZ2UuY29sb3I9ImJsYWNrIiwgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS53aWR0aD0xLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2UuYXJyb3cuc2l6ZT0wLCAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS5hcnJvdy53aWR0aD0wLCAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS5sdHk9InNvbGlkIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLmN1cnZlZD0wKQ0KYGBgDQoNCiMjIyMgRTQNCmBgYHtyIGZpZy5oZWlnaHQgPSAxMiwgZmlnLndpZHRoID0gMTJ9DQpkZiA8LSBlZ29kYXRhMi41W1s0XV0gI2dyYWIgZWdvbmV0IA0KZm5ldCA8LSBSU2llbmE6OmNvRHlhZENvdmFyKGRhdGEubWF0cml4KGRmJGZyaWVuZHNoaXApKSAjdGFrZSBmcmllbmRzaGlwIG1hdHJpeA0KRyA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChmbmV0LCBtb2RlID0gImRpcmVjdGVkIiwgZGlhZyA9IEZBTFNFKSAjbWFrZSBhbiAnaWdyYXBoIG9iamVjdCcNCg0KIyBpZGVudGlmeSBlZ28ncyBhbHRlcnMgKDEuMCkNCmUgPC0gYXMuZGF0YS5mcmFtZShnZXQuZWRnZWxpc3QoRykpDQpjb2xuYW1lcyhlKSA8LSBjKCJpIiwgImoiKQ0KZSRhbHRlciA8LSBpZmVsc2UoZSRpID09IHZlcnRleF9hdHRyKEcpJG5hbWVbMV0sIDEsIDApICNpZiBlZ28gaSBmb2xsb3dzIGFjdG9yIGosIGogaXMgZWdvJ3MgYWx0ZXINCg0KIyBtYWtlIGFjdG9ycyAoZWdvLCAxLjAtYWx0ZXI7IDIuMC1hbHRlcnMpIGlkZW50aWZpYWJsZQ0KdmVydGV4X2F0dHIoRykkc2hhcGUgPC0gYygic3F1YXJlIiwgcmVwKCJjaXJjbGUiLCAobnJvdyhmbmV0KSAtIDEpKSkgIyBlZ28gPSBzcXVhcmVkDQp2ZXJ0ZXhfYXR0cihHKSRzaXplIDwtIGMoOCwgcmVwKDQsIChucm93KGZuZXQpIC0gMSkpKSAjIGFuZCBiaWdnZXINCnZlcnRleF9hdHRyKEcpJGNvbG9yIDwtIGlmZWxzZSh2ZXJ0ZXhfYXR0cihHKSRuYW1lID09IHZlcnRleF9hdHRyKEcpJG5hbWVbMV0sICIjQkVCQURBIiwgaWZlbHNlKHZlcnRleF9hdHRyKEcpJG5hbWUgJWluJSBlJGpbZSRhbHRlcj09MV0sICIjRkZGRkIzIiwgIiM4REQzQzciKSkNCg0KDQojIHBsb3QNCnBhcihiZz0id2hpdGUiKQ0KcGxvdChzaW1wbGlmeShHKSwNCiAgICAgDQogICAgIG1haW4gPSAiMi41IGVnby1jZW50ZXJlZCBuZXR3b3JrIG9mIGRpcmVjdGVkIFNUUkFWQSBmcmllbmRzaGlwcyIsDQogICAgIHN1YiA9ICJlZ28gaXMgcHVycGxlIHNxdWFyZWQgbm9kZSwgdGhlaXIgYWx0ZXJzICgxLjApIGFyZSB5ZWxsb3cgbm9kZXMsIGFsdGVycyBvZiBhbHRlcnMgKDIuMCkgYXJlIGdyZWVuIG5vZGVzIiwNCiAgICAgDQogICAgIA0KICAgICAjID09PSB2ZXJ0ZXgNCiAgICAgdmVydGV4LmZyYW1lLmNvbG9yID0iYmxhY2siLCAgICAgICAgICANCiAgICAgdmVydGV4LnNoYXBlPXZlcnRleF9hdHRyKEcpJHNoYXBlLCAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5zaXplPXZlcnRleF9hdHRyKEcpJHNpemUsDQogICAgIHZlcnRleC5zaXplMj1OQSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIA0KICAgICAjID09PSB2ZXJ0ZXggbGFiZWwNCiAgICAgdmVydGV4LmxhYmVsPU5BLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5mYW1pbHk9IlRpbWVzIiwgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuZm9udD0yLCAgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuY2V4PTEsICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5kaXN0PTAsICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5kZWdyZWU9MCAsICAgICAgICAgICAgICAgICAgICAgIA0KICAgICANCiAgICAgIyA9PT0gRWRnZQ0KICAgICBlZGdlLmNvbG9yPSJibGFjayIsICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2Uud2lkdGg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLmFycm93LnNpemU9MCwgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2UuYXJyb3cud2lkdGg9MCwgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2UubHR5PSJzb2xpZCIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS5jdXJ2ZWQ9MCkNCmBgYA0KDQojIyMjIEU1DQoNCmBgYHtyIGZpZy5oZWlnaHQgPSAxMiwgZmlnLndpZHRoID0gMTJ9DQpkZiA8LSBlZ29kYXRhMi41W1s1XV0gI2dyYWIgZWdvbmV0IA0KZm5ldCA8LSBSU2llbmE6OmNvRHlhZENvdmFyKGRhdGEubWF0cml4KGRmJGZyaWVuZHNoaXApKSAjdGFrZSBmcmllbmRzaGlwIG1hdHJpeA0KRyA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChmbmV0LCBtb2RlID0gImRpcmVjdGVkIiwgZGlhZyA9IEZBTFNFKSAjbWFrZSBhbiAnaWdyYXBoIG9iamVjdCcNCg0KIyBpZGVudGlmeSBlZ28ncyBhbHRlcnMgKDEuMCkNCmUgPC0gYXMuZGF0YS5mcmFtZShnZXQuZWRnZWxpc3QoRykpDQpjb2xuYW1lcyhlKSA8LSBjKCJpIiwgImoiKQ0KZSRhbHRlciA8LSBpZmVsc2UoZSRpID09IHZlcnRleF9hdHRyKEcpJG5hbWVbMV0sIDEsIDApICNpZiBlZ28gaSBmb2xsb3dzIGFjdG9yIGosIGogaXMgZWdvJ3MgYWx0ZXINCg0KIyBtYWtlIGFjdG9ycyAoZWdvLCAxLjAtYWx0ZXI7IDIuMC1hbHRlcnMpIGlkZW50aWZpYWJsZQ0KdmVydGV4X2F0dHIoRykkc2hhcGUgPC0gYygic3F1YXJlIiwgcmVwKCJjaXJjbGUiLCAobnJvdyhmbmV0KSAtIDEpKSkgIyBlZ28gPSBzcXVhcmVkDQp2ZXJ0ZXhfYXR0cihHKSRzaXplIDwtIGMoOCwgcmVwKDQsIChucm93KGZuZXQpIC0gMSkpKSAjIGFuZCBiaWdnZXINCnZlcnRleF9hdHRyKEcpJGNvbG9yIDwtIGlmZWxzZSh2ZXJ0ZXhfYXR0cihHKSRuYW1lID09IHZlcnRleF9hdHRyKEcpJG5hbWVbMV0sICIjQkVCQURBIiwgaWZlbHNlKHZlcnRleF9hdHRyKEcpJG5hbWUgJWluJSBlJGpbZSRhbHRlcj09MV0sICIjRkZGRkIzIiwgIiM4REQzQzciKSkNCg0KDQojIHBsb3QNCnBhcihiZz0id2hpdGUiKQ0KcGxvdChzaW1wbGlmeShHKSwNCiAgICAgDQogICAgIG1haW4gPSAiMi41IGVnby1jZW50ZXJlZCBuZXR3b3JrIG9mIGRpcmVjdGVkIFNUUkFWQSBmcmllbmRzaGlwcyIsDQogICAgIHN1YiA9ICJlZ28gaXMgcHVycGxlIHNxdWFyZWQgbm9kZSwgdGhlaXIgYWx0ZXJzICgxLjApIGFyZSB5ZWxsb3cgbm9kZXMsIGFsdGVycyBvZiBhbHRlcnMgKDIuMCkgYXJlIGdyZWVuIG5vZGVzIiwNCiAgICAgDQogICAgIA0KICAgICAjID09PSB2ZXJ0ZXgNCiAgICAgdmVydGV4LmZyYW1lLmNvbG9yID0iYmxhY2siLCAgICAgICAgICANCiAgICAgdmVydGV4LnNoYXBlPXZlcnRleF9hdHRyKEcpJHNoYXBlLCAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5zaXplPXZlcnRleF9hdHRyKEcpJHNpemUsDQogICAgIHZlcnRleC5zaXplMj1OQSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIA0KICAgICAjID09PSB2ZXJ0ZXggbGFiZWwNCiAgICAgdmVydGV4LmxhYmVsPU5BLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5mYW1pbHk9IlRpbWVzIiwgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuZm9udD0yLCAgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuY2V4PTEsICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5kaXN0PTAsICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5kZWdyZWU9MCAsICAgICAgICAgICAgICAgICAgICAgIA0KICAgICANCiAgICAgIyA9PT0gRWRnZQ0KICAgICBlZGdlLmNvbG9yPSJibGFjayIsICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2Uud2lkdGg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLmFycm93LnNpemU9MCwgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2UuYXJyb3cud2lkdGg9MCwgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2UubHR5PSJzb2xpZCIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS5jdXJ2ZWQ9MCkNCmBgYA0KDQojIyMjIEU2DQpgYGB7ciBmaWcuaGVpZ2h0ID0gMTIsIGZpZy53aWR0aCA9IDEyfQ0KZGYgPC0gZWdvZGF0YTIuNVtbNl1dICNncmFiIGVnb25ldCANCmZuZXQgPC0gUlNpZW5hOjpjb0R5YWRDb3ZhcihkYXRhLm1hdHJpeChkZiRmcmllbmRzaGlwKSkgI3Rha2UgZnJpZW5kc2hpcCBtYXRyaXgNCkcgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoZm5ldCwgbW9kZSA9ICJkaXJlY3RlZCIsIGRpYWcgPSBGQUxTRSkgI21ha2UgYW4gJ2lncmFwaCBvYmplY3QnDQoNCiMgaWRlbnRpZnkgZWdvJ3MgYWx0ZXJzICgxLjApDQplIDwtIGFzLmRhdGEuZnJhbWUoZ2V0LmVkZ2VsaXN0KEcpKQ0KY29sbmFtZXMoZSkgPC0gYygiaSIsICJqIikNCmUkYWx0ZXIgPC0gaWZlbHNlKGUkaSA9PSB2ZXJ0ZXhfYXR0cihHKSRuYW1lWzFdLCAxLCAwKSAjaWYgZWdvIGkgZm9sbG93cyBhY3RvciBqLCBqIGlzIGVnbydzIGFsdGVyDQoNCiMgbWFrZSBhY3RvcnMgKGVnbywgMS4wLWFsdGVyOyAyLjAtYWx0ZXJzKSBpZGVudGlmaWFibGUNCnZlcnRleF9hdHRyKEcpJHNoYXBlIDwtIGMoInNxdWFyZSIsIHJlcCgiY2lyY2xlIiwgKG5yb3coZm5ldCkgLSAxKSkpICMgZWdvID0gc3F1YXJlZA0KdmVydGV4X2F0dHIoRykkc2l6ZSA8LSBjKDgsIHJlcCg0LCAobnJvdyhmbmV0KSAtIDEpKSkgIyBhbmQgYmlnZ2VyDQp2ZXJ0ZXhfYXR0cihHKSRjb2xvciA8LSBpZmVsc2UodmVydGV4X2F0dHIoRykkbmFtZSA9PSB2ZXJ0ZXhfYXR0cihHKSRuYW1lWzFdLCAiI0JFQkFEQSIsIGlmZWxzZSh2ZXJ0ZXhfYXR0cihHKSRuYW1lICVpbiUgZSRqW2UkYWx0ZXI9PTFdLCAiI0ZGRkZCMyIsICIjOEREM0M3IikpDQoNCg0KIyBwbG90DQpwYXIoYmc9IndoaXRlIikNCnBsb3Qoc2ltcGxpZnkoRyksDQogICAgIA0KICAgICBtYWluID0gIjIuNSBlZ28tY2VudGVyZWQgbmV0d29yayBvZiBkaXJlY3RlZCBTVFJBVkEgZnJpZW5kc2hpcHMiLA0KICAgICBzdWIgPSAiZWdvIGlzIHB1cnBsZSBzcXVhcmVkIG5vZGUsIHRoZWlyIGFsdGVycyAoMS4wKSBhcmUgeWVsbG93IG5vZGVzLCBhbHRlcnMgb2YgYWx0ZXJzICgyLjApIGFyZSBncmVlbiBub2RlcyIsDQogICAgIA0KICAgICANCiAgICAgIyA9PT0gdmVydGV4DQogICAgIHZlcnRleC5mcmFtZS5jb2xvciA9ImJsYWNrIiwgICAgICAgICAgDQogICAgIHZlcnRleC5zaGFwZT12ZXJ0ZXhfYXR0cihHKSRzaGFwZSwgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXguc2l6ZT12ZXJ0ZXhfYXR0cihHKSRzaXplLA0KICAgICB2ZXJ0ZXguc2l6ZTI9TkEsICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICANCiAgICAgIyA9PT0gdmVydGV4IGxhYmVsDQogICAgIHZlcnRleC5sYWJlbD1OQSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuZmFtaWx5PSJUaW1lcyIsICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmZvbnQ9MiwgICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmNleD0xLCAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuZGlzdD0wLCAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuZGVncmVlPTAgLCAgICAgICAgICAgICAgICAgICAgICANCiAgICAgDQogICAgICMgPT09IEVkZ2UNCiAgICAgZWRnZS5jb2xvcj0iYmxhY2siLCAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLndpZHRoPTEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS5hcnJvdy5zaXplPTAsICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLmFycm93LndpZHRoPTAsICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLmx0eT0ic29saWQiLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2UuY3VydmVkPTApDQpgYGANCg0KDQojIyMjIEU4DQoNCmBgYHtyIGZpZy5oZWlnaHQgPSAxMiwgZmlnLndpZHRoID0gMTJ9DQpkZiA8LSBlZ29kYXRhMi41W1s4XV0gI2dyYWIgZWdvbmV0IA0KZm5ldCA8LSBSU2llbmE6OmNvRHlhZENvdmFyKGRhdGEubWF0cml4KGRmJGZyaWVuZHNoaXApKSAjdGFrZSBmcmllbmRzaGlwIG1hdHJpeA0KRyA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChmbmV0LCBtb2RlID0gImRpcmVjdGVkIiwgZGlhZyA9IEZBTFNFKSAjbWFrZSBhbiAnaWdyYXBoIG9iamVjdCcNCg0KIyBpZGVudGlmeSBlZ28ncyBhbHRlcnMgKDEuMCkNCmUgPC0gYXMuZGF0YS5mcmFtZShnZXQuZWRnZWxpc3QoRykpDQpjb2xuYW1lcyhlKSA8LSBjKCJpIiwgImoiKQ0KZSRhbHRlciA8LSBpZmVsc2UoZSRpID09IHZlcnRleF9hdHRyKEcpJG5hbWVbMV0sIDEsIDApICNpZiBlZ28gaSBmb2xsb3dzIGFjdG9yIGosIGogaXMgZWdvJ3MgYWx0ZXINCg0KIyBtYWtlIGFjdG9ycyAoZWdvLCAxLjAtYWx0ZXI7IDIuMC1hbHRlcnMpIGlkZW50aWZpYWJsZQ0KdmVydGV4X2F0dHIoRykkc2hhcGUgPC0gYygic3F1YXJlIiwgcmVwKCJjaXJjbGUiLCAobnJvdyhmbmV0KSAtIDEpKSkgIyBlZ28gPSBzcXVhcmVkDQp2ZXJ0ZXhfYXR0cihHKSRzaXplIDwtIGMoOCwgcmVwKDQsIChucm93KGZuZXQpIC0gMSkpKSAjIGFuZCBiaWdnZXINCnZlcnRleF9hdHRyKEcpJGNvbG9yIDwtIGlmZWxzZSh2ZXJ0ZXhfYXR0cihHKSRuYW1lID09IHZlcnRleF9hdHRyKEcpJG5hbWVbMV0sICIjQkVCQURBIiwgaWZlbHNlKHZlcnRleF9hdHRyKEcpJG5hbWUgJWluJSBlJGpbZSRhbHRlcj09MV0sICIjRkZGRkIzIiwgIiM4REQzQzciKSkNCg0KIyBwbG90DQpwYXIoYmc9IndoaXRlIikNCnBsb3Qoc2ltcGxpZnkoRyksDQogICAgIA0KICAgICBtYWluID0gIjIuNSBlZ28tY2VudGVyZWQgbmV0d29yayBvZiBkaXJlY3RlZCBTVFJBVkEgZnJpZW5kc2hpcHMiLA0KICAgICBzdWIgPSAiZWdvIGlzIHB1cnBsZSBzcXVhcmVkIG5vZGUsIHRoZWlyIGFsdGVycyAoMS4wKSBhcmUgeWVsbG93IG5vZGVzLCBhbHRlcnMgb2YgYWx0ZXJzICgyLjApIGFyZSBncmVlbiBub2RlcyIsDQogICAgIA0KICAgICANCiAgICAgIyA9PT0gdmVydGV4DQogICAgIHZlcnRleC5mcmFtZS5jb2xvciA9ImJsYWNrIiwgICAgICAgICAgDQogICAgIHZlcnRleC5zaGFwZT12ZXJ0ZXhfYXR0cihHKSRzaGFwZSwgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXguc2l6ZT12ZXJ0ZXhfYXR0cihHKSRzaXplLA0KICAgICB2ZXJ0ZXguc2l6ZTI9TkEsICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICANCiAgICAgIyA9PT0gdmVydGV4IGxhYmVsDQogICAgIHZlcnRleC5sYWJlbD1OQSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuZmFtaWx5PSJUaW1lcyIsICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmZvbnQ9MiwgICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmNleD0xLCAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuZGlzdD0wLCAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuZGVncmVlPTAgLCAgICAgICAgICAgICAgICAgICAgICANCiAgICAgDQogICAgICMgPT09IEVkZ2UNCiAgICAgZWRnZS5jb2xvcj0iYmxhY2siLCAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLndpZHRoPTEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS5hcnJvdy5zaXplPTAsICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLmFycm93LndpZHRoPTAsICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLmx0eT0ic29saWQiLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2UuY3VydmVkPTApDQpgYGANCg0KIyMjIyBFOQ0KDQpgYGB7ciBmaWcuaGVpZ2h0ID0gMTIsIGZpZy53aWR0aCA9IDEyfQ0KZGYgPC0gZWdvZGF0YTIuNVtbOV1dICNncmFiIGVnb25ldCANCmZuZXQgPC0gUlNpZW5hOjpjb0R5YWRDb3ZhcihkYXRhLm1hdHJpeChkZiRmcmllbmRzaGlwKSkgI3Rha2UgZnJpZW5kc2hpcCBtYXRyaXgNCkcgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoZm5ldCwgbW9kZSA9ICJkaXJlY3RlZCIsIGRpYWcgPSBGQUxTRSkgI21ha2UgYW4gJ2lncmFwaCBvYmplY3QnDQoNCiMgaWRlbnRpZnkgZWdvJ3MgYWx0ZXJzICgxLjApDQplIDwtIGFzLmRhdGEuZnJhbWUoZ2V0LmVkZ2VsaXN0KEcpKQ0KY29sbmFtZXMoZSkgPC0gYygiaSIsICJqIikNCmUkYWx0ZXIgPC0gaWZlbHNlKGUkaSA9PSB2ZXJ0ZXhfYXR0cihHKSRuYW1lWzFdLCAxLCAwKSAjaWYgZWdvIGkgZm9sbG93cyBhY3RvciBqLCBqIGlzIGVnbydzIGFsdGVyDQoNCiMgbWFrZSBhY3RvcnMgKGVnbywgMS4wLWFsdGVyOyAyLjAtYWx0ZXJzKSBpZGVudGlmaWFibGUNCnZlcnRleF9hdHRyKEcpJHNoYXBlIDwtIGMoInNxdWFyZSIsIHJlcCgiY2lyY2xlIiwgKG5yb3coZm5ldCkgLSAxKSkpICMgZWdvID0gc3F1YXJlZA0KdmVydGV4X2F0dHIoRykkc2l6ZSA8LSBjKDgsIHJlcCg0LCAobnJvdyhmbmV0KSAtIDEpKSkgIyBhbmQgYmlnZ2VyDQp2ZXJ0ZXhfYXR0cihHKSRjb2xvciA8LSBpZmVsc2UodmVydGV4X2F0dHIoRykkbmFtZSA9PSB2ZXJ0ZXhfYXR0cihHKSRuYW1lWzFdLCAiI0JFQkFEQSIsIGlmZWxzZSh2ZXJ0ZXhfYXR0cihHKSRuYW1lICVpbiUgZSRqW2UkYWx0ZXI9PTFdLCAiI0ZGRkZCMyIsICIjOEREM0M3IikpDQoNCiMgcGxvdA0KcGFyKGJnPSJ3aGl0ZSIpDQpwbG90KHNpbXBsaWZ5KEcpLA0KICAgICANCiAgICAgbWFpbiA9ICIyLjUgZWdvLWNlbnRlcmVkIG5ldHdvcmsgb2YgZGlyZWN0ZWQgU1RSQVZBIGZyaWVuZHNoaXBzIiwNCiAgICAgc3ViID0gImVnbyBpcyBwdXJwbGUgc3F1YXJlZCBub2RlLCB0aGVpciBhbHRlcnMgKDEuMCkgYXJlIHllbGxvdyBub2RlcywgYWx0ZXJzIG9mIGFsdGVycyAoMi4wKSBhcmUgZ3JlZW4gbm9kZXMiLA0KICAgICANCiAgICAgDQogICAgICMgPT09IHZlcnRleA0KICAgICB2ZXJ0ZXguZnJhbWUuY29sb3IgPSJibGFjayIsICAgICAgICAgIA0KICAgICB2ZXJ0ZXguc2hhcGU9dmVydGV4X2F0dHIoRykkc2hhcGUsICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LnNpemU9dmVydGV4X2F0dHIoRykkc2l6ZSwNCiAgICAgdmVydGV4LnNpemUyPU5BLCAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgDQogICAgICMgPT09IHZlcnRleCBsYWJlbA0KICAgICB2ZXJ0ZXgubGFiZWw9TkEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmZhbWlseT0iVGltZXMiLCAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5mb250PTIsICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5jZXg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmRpc3Q9MCwgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmRlZ3JlZT0wICwgICAgICAgICAgICAgICAgICAgICAgDQogICAgIA0KICAgICAjID09PSBFZGdlDQogICAgIGVkZ2UuY29sb3I9ImJsYWNrIiwgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS53aWR0aD0xLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2UuYXJyb3cuc2l6ZT0wLCAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS5hcnJvdy53aWR0aD0wLCAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS5sdHk9InNvbGlkIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLmN1cnZlZD0wKQ0KYGBgDQoNCiMjIyMgRTEwDQpgYGB7ciBmaWcuaGVpZ2h0ID0gMTIsIGZpZy53aWR0aCA9IDEyfQ0KZGYgPC0gZWdvZGF0YTIuNVtbMTBdXSAjZ3JhYiBlZ29uZXQgDQpmbmV0IDwtIFJTaWVuYTo6Y29EeWFkQ292YXIoZGF0YS5tYXRyaXgoZGYkZnJpZW5kc2hpcCkpICN0YWtlIGZyaWVuZHNoaXAgbWF0cml4DQpHIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGZuZXQsIG1vZGUgPSAiZGlyZWN0ZWQiLCBkaWFnID0gRkFMU0UpICNtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KDQojIGlkZW50aWZ5IGVnbydzIGFsdGVycyAoMS4wKQ0KZSA8LSBhcy5kYXRhLmZyYW1lKGdldC5lZGdlbGlzdChHKSkNCmNvbG5hbWVzKGUpIDwtIGMoImkiLCAiaiIpDQplJGFsdGVyIDwtIGlmZWxzZShlJGkgPT0gdmVydGV4X2F0dHIoRykkbmFtZVsxXSwgMSwgMCkgI2lmIGVnbyBpIGZvbGxvd3MgYWN0b3IgaiwgaiBpcyBlZ28ncyBhbHRlcg0KDQojIG1ha2UgYWN0b3JzIChlZ28sIDEuMC1hbHRlcjsgMi4wLWFsdGVycykgaWRlbnRpZmlhYmxlDQp2ZXJ0ZXhfYXR0cihHKSRzaGFwZSA8LSBjKCJzcXVhcmUiLCByZXAoImNpcmNsZSIsIChucm93KGZuZXQpIC0gMSkpKSAjIGVnbyA9IHNxdWFyZWQNCnZlcnRleF9hdHRyKEcpJHNpemUgPC0gYyg4LCByZXAoNCwgKG5yb3coZm5ldCkgLSAxKSkpICMgYW5kIGJpZ2dlcg0KdmVydGV4X2F0dHIoRykkY29sb3IgPC0gaWZlbHNlKHZlcnRleF9hdHRyKEcpJG5hbWUgPT0gdmVydGV4X2F0dHIoRykkbmFtZVsxXSwgIiNCRUJBREEiLCBpZmVsc2UodmVydGV4X2F0dHIoRykkbmFtZSAlaW4lIGUkaltlJGFsdGVyPT0xXSwgIiNGRkZGQjMiLCAiIzhERDNDNyIpKQ0KDQojIHBsb3QNCnBhcihiZz0id2hpdGUiKQ0KcGxvdChzaW1wbGlmeShHKSwNCiAgICAgDQogICAgIG1haW4gPSAiMi41IGVnby1jZW50ZXJlZCBuZXR3b3JrIG9mIGRpcmVjdGVkIFNUUkFWQSBmcmllbmRzaGlwcyIsDQogICAgIHN1YiA9ICJlZ28gaXMgcHVycGxlIHNxdWFyZWQgbm9kZSwgdGhlaXIgYWx0ZXJzICgxLjApIGFyZSB5ZWxsb3cgbm9kZXMsIGFsdGVycyBvZiBhbHRlcnMgKDIuMCkgYXJlIGdyZWVuIG5vZGVzIiwNCiAgICAgDQogICAgIA0KICAgICAjID09PSB2ZXJ0ZXgNCiAgICAgdmVydGV4LmZyYW1lLmNvbG9yID0iYmxhY2siLCAgICAgICAgICANCiAgICAgdmVydGV4LnNoYXBlPXZlcnRleF9hdHRyKEcpJHNoYXBlLCAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5zaXplPXZlcnRleF9hdHRyKEcpJHNpemUsDQogICAgIHZlcnRleC5zaXplMj1OQSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIA0KICAgICAjID09PSB2ZXJ0ZXggbGFiZWwNCiAgICAgdmVydGV4LmxhYmVsPU5BLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5mYW1pbHk9IlRpbWVzIiwgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuZm9udD0yLCAgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuY2V4PTEsICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5kaXN0PTAsICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIHZlcnRleC5sYWJlbC5kZWdyZWU9MCAsICAgICAgICAgICAgICAgICAgICAgIA0KICAgICANCiAgICAgIyA9PT0gRWRnZQ0KICAgICBlZGdlLmNvbG9yPSJibGFjayIsICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2Uud2lkdGg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLmFycm93LnNpemU9MCwgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2UuYXJyb3cud2lkdGg9MCwgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2UubHR5PSJzb2xpZCIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS5jdXJ2ZWQ9MCkNCmBgYA0KDQojIyMjIEUxMQ0KYGBge3IgZmlnLmhlaWdodCA9IDEyLCBmaWcud2lkdGggPSAxMn0NCmRmIDwtIGVnb2RhdGEyLjVbWzExXV0gI2dyYWIgZWdvbmV0IA0KZm5ldCA8LSBSU2llbmE6OmNvRHlhZENvdmFyKGRhdGEubWF0cml4KGRmJGZyaWVuZHNoaXApKSAjdGFrZSBmcmllbmRzaGlwIG1hdHJpeA0KRyA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChmbmV0LCBtb2RlID0gImRpcmVjdGVkIiwgZGlhZyA9IEZBTFNFKSAjbWFrZSBhbiAnaWdyYXBoIG9iamVjdCcNCg0KIyBpZGVudGlmeSBlZ28ncyBhbHRlcnMgKDEuMCkNCmUgPC0gYXMuZGF0YS5mcmFtZShnZXQuZWRnZWxpc3QoRykpDQpjb2xuYW1lcyhlKSA8LSBjKCJpIiwgImoiKQ0KZSRhbHRlciA8LSBpZmVsc2UoZSRpID09IHZlcnRleF9hdHRyKEcpJG5hbWVbMV0sIDEsIDApICNpZiBlZ28gaSBmb2xsb3dzIGFjdG9yIGosIGogaXMgZWdvJ3MgYWx0ZXINCg0KIyBtYWtlIGFjdG9ycyAoZWdvLCAxLjAtYWx0ZXI7IDIuMC1hbHRlcnMpIGlkZW50aWZpYWJsZQ0KdmVydGV4X2F0dHIoRykkc2hhcGUgPC0gYygic3F1YXJlIiwgcmVwKCJjaXJjbGUiLCAobnJvdyhmbmV0KSAtIDEpKSkgIyBlZ28gPSBzcXVhcmVkDQp2ZXJ0ZXhfYXR0cihHKSRzaXplIDwtIGMoOCwgcmVwKDQsIChucm93KGZuZXQpIC0gMSkpKSAjIGFuZCBiaWdnZXINCnZlcnRleF9hdHRyKEcpJGNvbG9yIDwtIGlmZWxzZSh2ZXJ0ZXhfYXR0cihHKSRuYW1lID09IHZlcnRleF9hdHRyKEcpJG5hbWVbMV0sICIjQkVCQURBIiwgaWZlbHNlKHZlcnRleF9hdHRyKEcpJG5hbWUgJWluJSBlJGpbZSRhbHRlcj09MV0sICIjRkZGRkIzIiwgIiM4REQzQzciKSkNCg0KIyBwbG90DQpwYXIoYmc9IndoaXRlIikNCnBsb3Qoc2ltcGxpZnkoRyksDQogICAgIA0KICAgICBtYWluID0gIjIuNSBlZ28tY2VudGVyZWQgbmV0d29yayBvZiBkaXJlY3RlZCBTVFJBVkEgZnJpZW5kc2hpcHMiLA0KICAgICBzdWIgPSAiZWdvIGlzIHB1cnBsZSBzcXVhcmVkIG5vZGUsIHRoZWlyIGFsdGVycyAoMS4wKSBhcmUgeWVsbG93IG5vZGVzLCBhbHRlcnMgb2YgYWx0ZXJzICgyLjApIGFyZSBncmVlbiBub2RlcyIsDQogICAgIA0KICAgICANCiAgICAgIyA9PT0gdmVydGV4DQogICAgIHZlcnRleC5mcmFtZS5jb2xvciA9ImJsYWNrIiwgICAgICAgICAgDQogICAgIHZlcnRleC5zaGFwZT12ZXJ0ZXhfYXR0cihHKSRzaGFwZSwgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXguc2l6ZT12ZXJ0ZXhfYXR0cihHKSRzaXplLA0KICAgICB2ZXJ0ZXguc2l6ZTI9TkEsICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICANCiAgICAgIyA9PT0gdmVydGV4IGxhYmVsDQogICAgIHZlcnRleC5sYWJlbD1OQSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuZmFtaWx5PSJUaW1lcyIsICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmZvbnQ9MiwgICAgICAgICAgICAgICAgICAgICANCiAgICAgdmVydGV4LmxhYmVsLmNleD0xLCAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuZGlzdD0wLCAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICB2ZXJ0ZXgubGFiZWwuZGVncmVlPTAgLCAgICAgICAgICAgICAgICAgICAgICANCiAgICAgDQogICAgICMgPT09IEVkZ2UNCiAgICAgZWRnZS5jb2xvcj0iYmxhY2siLCAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLndpZHRoPTEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgZWRnZS5hcnJvdy5zaXplPTAsICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLmFycm93LndpZHRoPTAsICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICBlZGdlLmx0eT0ic29saWQiLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgIGVkZ2UuY3VydmVkPTApDQpgYGANCg0KDQoNCiMjIyB7LX0NCg0KVGhlc2UgYXJlIHZlcnkgYmlnIG5ldHdvcmtzLCBzbyB3ZSB3aWxsIHN0YXJ0IHdpdGggZGVzY3JpYmluZyAxLjUgZGVncmVlIGVnby1jZW50ZXJlZCBuZXR3b3Jrcywgd2hpY2ggd2UgZGVmaW5lIGFzIHRoZSBuZXR3b3JrIGNvbnNpc3Rpbmcgb2YgZWdvLCBlZ28ncyBhbHRlcnMsIGFuZCB0aGUgdGllcyBkZWZpbmVkIG9uIHRoaXMgc2V0Lg0KDQotLS0tDQoNCjxicj4NCg0KIyMgMS41IGRlZ3JlZQ0KDQojIyMgey50YWJzZXQgLnRhYnNldC1mYWRlfQ0KDQojIyMjIEUxDQoNCmBgYHtyIH0NCmRmIDwtIGVnb2RhdGExLjVbWzFdXSAjZ3JhYiBlZ29uZXQgDQpmbmV0IDwtIFJTaWVuYTo6Y29EeWFkQ292YXIoZGF0YS5tYXRyaXgoZGYkZnJpZW5kc2hpcCkpICN0YWtlIGZyaWVuZHNoaXAgbWF0cml4DQpHIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGZuZXQsIG1vZGUgPSAiZGlyZWN0ZWQiLCBkaWFnID0gRkFMU0UpICNtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KDQojIGFjdG9yIGF0dHJpYnV0ZXM6IHNoYXBlIGFuZCBjb2xvdXINCnZlcnRleF9hdHRyKEcpJHNoYXBlIDwtIGMoInNxdWFyZSIsIHJlcCgiY2lyY2xlIiwgKG5yb3coZm5ldCkgLSAxKSkpDQp2ZXJ0ZXhfYXR0cihHKSRjb2xvciA8LSBpZmVsc2UodmVydGV4X2F0dHIoRykkbmFtZSA9PSB2ZXJ0ZXhfYXR0cihHKSRuYW1lWzFdLCAiI0JFQkFEQSIsIiNGRkZGQjMiKQ0KDQojIHBsb3QNCnsNCiAgcGxvdChzaW1wbGlmeShHKSwNCiAgICAgICBtYWluID0gIjEuNSBlZ28tY2VudGVyZWQgbmV0d29yayBvZiBkaXJlY3RlZCBTVFJBVkEgZnJpZW5kc2hpcHMiLA0KDQogICAgICAgIyA9PT0gdmVydGV4DQogICAgICAgdmVydGV4LmZyYW1lLmNvbG9yID0iYmxhY2siLCAgICAgICAgICANCiAgICAgICB2ZXJ0ZXguc2l6ZTI9TkEsICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIA0KICAgICAgICMgPT09IHZlcnRleCBsYWJlbA0KICAgICAgIHZlcnRleC5sYWJlbD1OQSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5mYW1pbHk9IlRpbWVzIiwgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5mb250PTIsICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmNleD0xLCAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5kaXN0PTAsICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmRlZ3JlZT0wICwgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgDQogICAgICAgIyA9PT0gRWRnZQ0KICAgICAgIGVkZ2UuY29sb3I9ImJsYWNrIiwgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLndpZHRoPTEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLmFycm93LnNpemU9LjQsICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2UuYXJyb3cud2lkdGg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS5sdHk9InNvbGlkIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2UuY3VydmVkPTApDQogIA0KICAjIEFkZCBhIGxlZ2VuZA0KICBsZWdlbmQoImJvdHRvbWxlZnQiLCBsZWdlbmQ9YygiZWdvIiwgImFsdGVyIiksDQogICAgICAgICBjb2wgPSB2ZXJ0ZXguYXR0cmlidXRlcyhHKSRjb2xvciwgYnR5ID0gIm4iLCBwdC5jZXggPSAyLjUsIHBjaCA9IGMoMTUsIDE5KSwgaG9yaXogPSBGLCBpbnNldCA9IGMoMC4xNSwgMC4xNSkNCiAgKQ0KfQ0KYGBgDQoNCiMjIyMgRTINCg0KYGBge3IgfQ0KZGYgPC0gZWdvZGF0YTEuNVtbMl1dICNncmFiIGVnb25ldCANCmZuZXQgPC0gUlNpZW5hOjpjb0R5YWRDb3ZhcihkYXRhLm1hdHJpeChkZiRmcmllbmRzaGlwKSkgI3Rha2UgZnJpZW5kc2hpcCBtYXRyaXgNCkcgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoZm5ldCwgbW9kZSA9ICJkaXJlY3RlZCIsIGRpYWcgPSBGQUxTRSkgI21ha2UgYW4gJ2lncmFwaCBvYmplY3QnDQoNCiMgYWN0b3IgYXR0cmlidXRlczogc2hhcGUgYW5kIGNvbG91cg0KdmVydGV4X2F0dHIoRykkc2hhcGUgPC0gYygic3F1YXJlIiwgcmVwKCJjaXJjbGUiLCAobnJvdyhmbmV0KSAtIDEpKSkNCnZlcnRleF9hdHRyKEcpJGNvbG9yIDwtIGlmZWxzZSh2ZXJ0ZXhfYXR0cihHKSRuYW1lID09IHZlcnRleF9hdHRyKEcpJG5hbWVbMV0sICIjQkVCQURBIiwiI0ZGRkZCMyIpDQoNCiMgcGxvdA0Kew0KICBwbG90KHNpbXBsaWZ5KEcpLA0KICAgICAgIG1haW4gPSAiMS41IGVnby1jZW50ZXJlZCBuZXR3b3JrIG9mIGRpcmVjdGVkIFNUUkFWQSBmcmllbmRzaGlwcyIsDQoNCiAgICAgICAjID09PSB2ZXJ0ZXgNCiAgICAgICB2ZXJ0ZXguZnJhbWUuY29sb3IgPSJibGFjayIsICAgICAgICAgIA0KICAgICAgIHZlcnRleC5zaXplMj1OQSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgDQogICAgICAgIyA9PT0gdmVydGV4IGxhYmVsDQogICAgICAgdmVydGV4LmxhYmVsPU5BLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmZhbWlseT0iVGltZXMiLCAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmZvbnQ9MiwgICAgICAgICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuY2V4PTEsICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmRpc3Q9MCwgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuZGVncmVlPTAgLCAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICANCiAgICAgICAjID09PSBFZGdlDQogICAgICAgZWRnZS5jb2xvcj0iYmxhY2siLCAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2Uud2lkdGg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2UuYXJyb3cuc2l6ZT0uNCwgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS5hcnJvdy53aWR0aD0xLCAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLmx0eT0ic29saWQiLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS5jdXJ2ZWQ9MCkNCiAgDQogICMgQWRkIGEgbGVnZW5kDQogIGxlZ2VuZCgiYm90dG9tbGVmdCIsIGxlZ2VuZD1jKCJlZ28iLCAiYWx0ZXIiKSwNCiAgICAgICAgIGNvbCA9IHZlcnRleC5hdHRyaWJ1dGVzKEcpJGNvbG9yLCBidHkgPSAibiIsIHB0LmNleCA9IDIuNSwgcGNoID0gYygxNSwgMTkpLCBob3JpeiA9IEYsIGluc2V0ID0gYygwLjE1LCAwLjE1KQ0KICApDQp9DQpgYGANCg0KIyMjIyBFMw0KDQpgYGB7ciB9DQpkZiA8LSBlZ29kYXRhMS41W1szXV0gI2dyYWIgZWdvbmV0IA0KZm5ldCA8LSBSU2llbmE6OmNvRHlhZENvdmFyKGRhdGEubWF0cml4KGRmJGZyaWVuZHNoaXApKSAjdGFrZSBmcmllbmRzaGlwIG1hdHJpeA0KRyA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChmbmV0LCBtb2RlID0gImRpcmVjdGVkIiwgZGlhZyA9IEZBTFNFKSAjbWFrZSBhbiAnaWdyYXBoIG9iamVjdCcNCg0KIyBhY3RvciBhdHRyaWJ1dGVzOiBzaGFwZSBhbmQgY29sb3VyDQp2ZXJ0ZXhfYXR0cihHKSRzaGFwZSA8LSBjKCJzcXVhcmUiLCByZXAoImNpcmNsZSIsIChucm93KGZuZXQpIC0gMSkpKQ0KdmVydGV4X2F0dHIoRykkY29sb3IgPC0gaWZlbHNlKHZlcnRleF9hdHRyKEcpJG5hbWUgPT0gdmVydGV4X2F0dHIoRykkbmFtZVsxXSwgIiNCRUJBREEiLCIjRkZGRkIzIikNCg0KIyBwbG90DQp7DQogIHBsb3Qoc2ltcGxpZnkoRyksDQogICAgICAgbWFpbiA9ICIxLjUgZWdvLWNlbnRlcmVkIG5ldHdvcmsgb2YgZGlyZWN0ZWQgU1RSQVZBIGZyaWVuZHNoaXBzIiwNCg0KICAgICAgICMgPT09IHZlcnRleA0KICAgICAgIHZlcnRleC5mcmFtZS5jb2xvciA9ImJsYWNrIiwgICAgICAgICAgDQogICAgICAgdmVydGV4LnNpemUyPU5BLCAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICANCiAgICAgICAjID09PSB2ZXJ0ZXggbGFiZWwNCiAgICAgICB2ZXJ0ZXgubGFiZWw9TkEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuZmFtaWx5PSJUaW1lcyIsICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuZm9udD0yLCAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5jZXg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuZGlzdD0wLCAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5kZWdyZWU9MCAsICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIA0KICAgICAgICMgPT09IEVkZ2UNCiAgICAgICBlZGdlLmNvbG9yPSJibGFjayIsICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS53aWR0aD0xLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS5hcnJvdy5zaXplPS40LCAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLmFycm93LndpZHRoPTEsICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2UubHR5PSJzb2xpZCIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLmN1cnZlZD0wKQ0KICANCiAgIyBBZGQgYSBsZWdlbmQNCiAgbGVnZW5kKCJib3R0b21sZWZ0IiwgbGVnZW5kPWMoImVnbyIsICJhbHRlciIpLA0KICAgICAgICAgY29sID0gdmVydGV4LmF0dHJpYnV0ZXMoRykkY29sb3IsIGJ0eSA9ICJuIiwgcHQuY2V4ID0gMi41LCBwY2ggPSBjKDE1LCAxOSksIGhvcml6ID0gRiwgaW5zZXQgPSBjKDAuMTUsIDAuMTUpDQogICkNCn0NCmBgYA0KDQojIyMjIEU1DQoNCmBgYHtyIH0NCmRmIDwtIGVnb2RhdGExLjVbWzVdXSAjZ3JhYiBlZ29uZXQgDQpmbmV0IDwtIFJTaWVuYTo6Y29EeWFkQ292YXIoZGF0YS5tYXRyaXgoZGYkZnJpZW5kc2hpcCkpICN0YWtlIGZyaWVuZHNoaXAgbWF0cml4DQpHIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGZuZXQsIG1vZGUgPSAiZGlyZWN0ZWQiLCBkaWFnID0gRkFMU0UpICNtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KDQojIGFjdG9yIGF0dHJpYnV0ZXM6IHNoYXBlIGFuZCBjb2xvdXINCnZlcnRleF9hdHRyKEcpJHNoYXBlIDwtIGMoInNxdWFyZSIsIHJlcCgiY2lyY2xlIiwgKG5yb3coZm5ldCkgLSAxKSkpDQp2ZXJ0ZXhfYXR0cihHKSRjb2xvciA8LSBpZmVsc2UodmVydGV4X2F0dHIoRykkbmFtZSA9PSB2ZXJ0ZXhfYXR0cihHKSRuYW1lWzFdLCAiI0JFQkFEQSIsIiNGRkZGQjMiKQ0KDQojIHBsb3QNCnsNCiAgcGxvdChzaW1wbGlmeShHKSwNCiAgICAgICBtYWluID0gIjEuNSBlZ28tY2VudGVyZWQgbmV0d29yayBvZiBkaXJlY3RlZCBTVFJBVkEgZnJpZW5kc2hpcHMiLA0KDQogICAgICAgIyA9PT0gdmVydGV4DQogICAgICAgdmVydGV4LmZyYW1lLmNvbG9yID0iYmxhY2siLCAgICAgICAgICANCiAgICAgICB2ZXJ0ZXguc2l6ZTI9TkEsICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIA0KICAgICAgICMgPT09IHZlcnRleCBsYWJlbA0KICAgICAgIHZlcnRleC5sYWJlbD1OQSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5mYW1pbHk9IlRpbWVzIiwgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5mb250PTIsICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmNleD0xLCAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5kaXN0PTAsICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmRlZ3JlZT0wICwgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgDQogICAgICAgIyA9PT0gRWRnZQ0KICAgICAgIGVkZ2UuY29sb3I9ImJsYWNrIiwgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLndpZHRoPTEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLmFycm93LnNpemU9LjQsICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2UuYXJyb3cud2lkdGg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS5sdHk9InNvbGlkIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2UuY3VydmVkPTApDQogIA0KICAjIEFkZCBhIGxlZ2VuZA0KICBsZWdlbmQoImJvdHRvbWxlZnQiLCBsZWdlbmQ9YygiZWdvIiwgImFsdGVyIiksDQogICAgICAgICBjb2wgPSB2ZXJ0ZXguYXR0cmlidXRlcyhHKSRjb2xvciwgYnR5ID0gIm4iLCBwdC5jZXggPSAyLjUsIHBjaCA9IGMoMTUsIDE5KSwgaG9yaXogPSBGLCBpbnNldCA9IGMoMC4xNSwgMC4xNSkNCiAgKQ0KfQ0KYGBgDQoNCiMjIyMgRTYNCg0KYGBge3IgfQ0KZGYgPC0gZWdvZGF0YTEuNVtbNl1dICNncmFiIGVnb25ldCANCmZuZXQgPC0gUlNpZW5hOjpjb0R5YWRDb3ZhcihkYXRhLm1hdHJpeChkZiRmcmllbmRzaGlwKSkgI3Rha2UgZnJpZW5kc2hpcCBtYXRyaXgNCkcgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoZm5ldCwgbW9kZSA9ICJkaXJlY3RlZCIsIGRpYWcgPSBGQUxTRSkgI21ha2UgYW4gJ2lncmFwaCBvYmplY3QnDQoNCiMgYWN0b3IgYXR0cmlidXRlczogc2hhcGUgYW5kIGNvbG91cg0KdmVydGV4X2F0dHIoRykkc2hhcGUgPC0gYygic3F1YXJlIiwgcmVwKCJjaXJjbGUiLCAobnJvdyhmbmV0KSAtIDEpKSkNCnZlcnRleF9hdHRyKEcpJGNvbG9yIDwtIGlmZWxzZSh2ZXJ0ZXhfYXR0cihHKSRuYW1lID09IHZlcnRleF9hdHRyKEcpJG5hbWVbMV0sICIjQkVCQURBIiwiI0ZGRkZCMyIpDQoNCiMgcGxvdA0Kew0KICBwbG90KHNpbXBsaWZ5KEcpLA0KICAgICAgIG1haW4gPSAiMS41IGVnby1jZW50ZXJlZCBuZXR3b3JrIG9mIGRpcmVjdGVkIFNUUkFWQSBmcmllbmRzaGlwcyIsDQoNCiAgICAgICAjID09PSB2ZXJ0ZXgNCiAgICAgICB2ZXJ0ZXguZnJhbWUuY29sb3IgPSJibGFjayIsICAgICAgICAgIA0KICAgICAgIHZlcnRleC5zaXplMj1OQSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgDQogICAgICAgIyA9PT0gdmVydGV4IGxhYmVsDQogICAgICAgdmVydGV4LmxhYmVsPU5BLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmZhbWlseT0iVGltZXMiLCAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmZvbnQ9MiwgICAgICAgICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuY2V4PTEsICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmRpc3Q9MCwgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuZGVncmVlPTAgLCAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICANCiAgICAgICAjID09PSBFZGdlDQogICAgICAgZWRnZS5jb2xvcj0iYmxhY2siLCAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2Uud2lkdGg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2UuYXJyb3cuc2l6ZT0uNCwgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS5hcnJvdy53aWR0aD0xLCAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLmx0eT0ic29saWQiLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS5jdXJ2ZWQ9MCkNCiAgDQogICMgQWRkIGEgbGVnZW5kDQogIGxlZ2VuZCgiYm90dG9tbGVmdCIsIGxlZ2VuZD1jKCJlZ28iLCAiYWx0ZXIiKSwNCiAgICAgICAgIGNvbCA9IHZlcnRleC5hdHRyaWJ1dGVzKEcpJGNvbG9yLCBidHkgPSAibiIsIHB0LmNleCA9IDIuNSwgcGNoID0gYygxNSwgMTkpLCBob3JpeiA9IEYsIGluc2V0ID0gYygwLjE1LCAwLjE1KQ0KICApDQp9DQpgYGANCg0KIyMjIyBFOA0KDQpgYGB7ciB9DQpkZiA8LSBlZ29kYXRhMS41W1s4XV0gI2dyYWIgZWdvbmV0IA0KZm5ldCA8LSBSU2llbmE6OmNvRHlhZENvdmFyKGRhdGEubWF0cml4KGRmJGZyaWVuZHNoaXApKSAjdGFrZSBmcmllbmRzaGlwIG1hdHJpeA0KRyA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChmbmV0LCBtb2RlID0gImRpcmVjdGVkIiwgZGlhZyA9IEZBTFNFKSAjbWFrZSBhbiAnaWdyYXBoIG9iamVjdCcNCg0KIyBhY3RvciBhdHRyaWJ1dGVzOiBzaGFwZSBhbmQgY29sb3VyDQp2ZXJ0ZXhfYXR0cihHKSRzaGFwZSA8LSBjKCJzcXVhcmUiLCByZXAoImNpcmNsZSIsIChucm93KGZuZXQpIC0gMSkpKQ0KdmVydGV4X2F0dHIoRykkY29sb3IgPC0gaWZlbHNlKHZlcnRleF9hdHRyKEcpJG5hbWUgPT0gdmVydGV4X2F0dHIoRykkbmFtZVsxXSwgIiNCRUJBREEiLCIjRkZGRkIzIikNCg0KIyBwbG90DQp7DQogIHBsb3Qoc2ltcGxpZnkoRyksDQogICAgICAgbWFpbiA9ICIxLjUgZWdvLWNlbnRlcmVkIG5ldHdvcmsgb2YgZGlyZWN0ZWQgU1RSQVZBIGZyaWVuZHNoaXBzIiwNCg0KICAgICAgICMgPT09IHZlcnRleA0KICAgICAgIHZlcnRleC5mcmFtZS5jb2xvciA9ImJsYWNrIiwgICAgICAgICAgDQogICAgICAgdmVydGV4LnNpemUyPU5BLCAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICANCiAgICAgICAjID09PSB2ZXJ0ZXggbGFiZWwNCiAgICAgICB2ZXJ0ZXgubGFiZWw9TkEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuZmFtaWx5PSJUaW1lcyIsICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuZm9udD0yLCAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5jZXg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuZGlzdD0wLCAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5kZWdyZWU9MCAsICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIA0KICAgICAgICMgPT09IEVkZ2UNCiAgICAgICBlZGdlLmNvbG9yPSJibGFjayIsICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS53aWR0aD0xLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS5hcnJvdy5zaXplPS40LCAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLmFycm93LndpZHRoPTEsICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2UubHR5PSJzb2xpZCIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLmN1cnZlZD0wKQ0KICANCiAgIyBBZGQgYSBsZWdlbmQNCiAgbGVnZW5kKCJib3R0b21sZWZ0IiwgbGVnZW5kPWMoImVnbyIsICJhbHRlciIpLA0KICAgICAgICAgY29sID0gdmVydGV4LmF0dHJpYnV0ZXMoRykkY29sb3IsIGJ0eSA9ICJuIiwgcHQuY2V4ID0gMi41LCBwY2ggPSBjKDE1LCAxOSksIGhvcml6ID0gRiwgaW5zZXQgPSBjKDAuMTUsIDAuMTUpDQogICkNCn0NCmBgYA0KDQojIyMjIEU5DQoNCmBgYHtyIH0NCmRmIDwtIGVnb2RhdGExLjVbWzldXSAjZ3JhYiBlZ29uZXQgDQpmbmV0IDwtIFJTaWVuYTo6Y29EeWFkQ292YXIoZGF0YS5tYXRyaXgoZGYkZnJpZW5kc2hpcCkpICN0YWtlIGZyaWVuZHNoaXAgbWF0cml4DQpHIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGZuZXQsIG1vZGUgPSAiZGlyZWN0ZWQiLCBkaWFnID0gRkFMU0UpICNtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KDQojIGFjdG9yIGF0dHJpYnV0ZXM6IHNoYXBlIGFuZCBjb2xvdXINCnZlcnRleF9hdHRyKEcpJHNoYXBlIDwtIGMoInNxdWFyZSIsIHJlcCgiY2lyY2xlIiwgKG5yb3coZm5ldCkgLSAxKSkpDQp2ZXJ0ZXhfYXR0cihHKSRjb2xvciA8LSBpZmVsc2UodmVydGV4X2F0dHIoRykkbmFtZSA9PSB2ZXJ0ZXhfYXR0cihHKSRuYW1lWzFdLCAiI0JFQkFEQSIsIiNGRkZGQjMiKQ0KDQojIHBsb3QNCnsNCiAgcGxvdChzaW1wbGlmeShHKSwNCiAgICAgICBtYWluID0gIjEuNSBlZ28tY2VudGVyZWQgbmV0d29yayBvZiBkaXJlY3RlZCBTVFJBVkEgZnJpZW5kc2hpcHMiLA0KDQogICAgICAgIyA9PT0gdmVydGV4DQogICAgICAgdmVydGV4LmZyYW1lLmNvbG9yID0iYmxhY2siLCAgICAgICAgICANCiAgICAgICB2ZXJ0ZXguc2l6ZTI9TkEsICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIA0KICAgICAgICMgPT09IHZlcnRleCBsYWJlbA0KICAgICAgIHZlcnRleC5sYWJlbD1OQSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5mYW1pbHk9IlRpbWVzIiwgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5mb250PTIsICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmNleD0xLCAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5kaXN0PTAsICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmRlZ3JlZT0wICwgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgDQogICAgICAgIyA9PT0gRWRnZQ0KICAgICAgIGVkZ2UuY29sb3I9ImJsYWNrIiwgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLndpZHRoPTEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLmFycm93LnNpemU9LjQsICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2UuYXJyb3cud2lkdGg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS5sdHk9InNvbGlkIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2UuY3VydmVkPTApDQogIA0KICAjIEFkZCBhIGxlZ2VuZA0KICBsZWdlbmQoImJvdHRvbWxlZnQiLCBsZWdlbmQ9YygiZWdvIiwgImFsdGVyIiksDQogICAgICAgICBjb2wgPSB2ZXJ0ZXguYXR0cmlidXRlcyhHKSRjb2xvciwgYnR5ID0gIm4iLCBwdC5jZXggPSAyLjUsIHBjaCA9IGMoMTUsIDE5KSwgaG9yaXogPSBGLCBpbnNldCA9IGMoMC4xNSwgMC4xNSkNCiAgKQ0KfQ0KYGBgDQoNCiMjIyMgRTEwDQoNCmBgYHtyIH0NCmRmIDwtIGVnb2RhdGExLjVbWzEwXV0gI2dyYWIgZWdvbmV0IA0KZm5ldCA8LSBSU2llbmE6OmNvRHlhZENvdmFyKGRhdGEubWF0cml4KGRmJGZyaWVuZHNoaXApKSAjdGFrZSBmcmllbmRzaGlwIG1hdHJpeA0KRyA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChmbmV0LCBtb2RlID0gImRpcmVjdGVkIiwgZGlhZyA9IEZBTFNFKSAjbWFrZSBhbiAnaWdyYXBoIG9iamVjdCcNCg0KIyBhY3RvciBhdHRyaWJ1dGVzOiBzaGFwZSBhbmQgY29sb3VyDQp2ZXJ0ZXhfYXR0cihHKSRzaGFwZSA8LSBjKCJzcXVhcmUiLCByZXAoImNpcmNsZSIsIChucm93KGZuZXQpIC0gMSkpKQ0KdmVydGV4X2F0dHIoRykkY29sb3IgPC0gaWZlbHNlKHZlcnRleF9hdHRyKEcpJG5hbWUgPT0gdmVydGV4X2F0dHIoRykkbmFtZVsxXSwgIiNCRUJBREEiLCIjRkZGRkIzIikNCg0KIyBwbG90DQp7DQogIHBsb3Qoc2ltcGxpZnkoRyksDQogICAgICAgbWFpbiA9ICIxLjUgZWdvLWNlbnRlcmVkIG5ldHdvcmsgb2YgZGlyZWN0ZWQgU1RSQVZBIGZyaWVuZHNoaXBzIiwNCg0KICAgICAgICMgPT09IHZlcnRleA0KICAgICAgIHZlcnRleC5mcmFtZS5jb2xvciA9ImJsYWNrIiwgICAgICAgICAgDQogICAgICAgdmVydGV4LnNpemUyPU5BLCAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICANCiAgICAgICAjID09PSB2ZXJ0ZXggbGFiZWwNCiAgICAgICB2ZXJ0ZXgubGFiZWw9TkEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuZmFtaWx5PSJUaW1lcyIsICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuZm9udD0yLCAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5jZXg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuZGlzdD0wLCAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIHZlcnRleC5sYWJlbC5kZWdyZWU9MCAsICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIA0KICAgICAgICMgPT09IEVkZ2UNCiAgICAgICBlZGdlLmNvbG9yPSJibGFjayIsICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS53aWR0aD0xLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS5hcnJvdy5zaXplPS40LCAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLmFycm93LndpZHRoPTEsICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2UubHR5PSJzb2xpZCIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLmN1cnZlZD0wKQ0KICANCiAgIyBBZGQgYSBsZWdlbmQNCiAgbGVnZW5kKCJib3R0b21sZWZ0IiwgbGVnZW5kPWMoImVnbyIsICJhbHRlciIpLA0KICAgICAgICAgY29sID0gdmVydGV4LmF0dHJpYnV0ZXMoRykkY29sb3IsIGJ0eSA9ICJuIiwgcHQuY2V4ID0gMi41LCBwY2ggPSBjKDE1LCAxOSksIGhvcml6ID0gRiwgaW5zZXQgPSBjKDAuMTUsIDAuMTUpDQogICkNCn0NCmBgYA0KDQojIyMjIEUxMQ0KDQpgYGB7ciB9DQpkZiA8LSBlZ29kYXRhMS41W1sxMV1dICNncmFiIGVnb25ldCANCmZuZXQgPC0gUlNpZW5hOjpjb0R5YWRDb3ZhcihkYXRhLm1hdHJpeChkZiRmcmllbmRzaGlwKSkgI3Rha2UgZnJpZW5kc2hpcCBtYXRyaXgNCkcgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoZm5ldCwgbW9kZSA9ICJkaXJlY3RlZCIsIGRpYWcgPSBGQUxTRSkgI21ha2UgYW4gJ2lncmFwaCBvYmplY3QnDQoNCiMgYWN0b3IgYXR0cmlidXRlczogc2hhcGUgYW5kIGNvbG91cg0KdmVydGV4X2F0dHIoRykkc2hhcGUgPC0gYygic3F1YXJlIiwgcmVwKCJjaXJjbGUiLCAobnJvdyhmbmV0KSAtIDEpKSkNCnZlcnRleF9hdHRyKEcpJGNvbG9yIDwtIGlmZWxzZSh2ZXJ0ZXhfYXR0cihHKSRuYW1lID09IHZlcnRleF9hdHRyKEcpJG5hbWVbMV0sICIjQkVCQURBIiwiI0ZGRkZCMyIpDQoNCiMgcGxvdA0Kew0KICBwbG90KHNpbXBsaWZ5KEcpLA0KICAgICAgIG1haW4gPSAiMS41IGVnby1jZW50ZXJlZCBuZXR3b3JrIG9mIGRpcmVjdGVkIFNUUkFWQSBmcmllbmRzaGlwcyIsDQoNCiAgICAgICAjID09PSB2ZXJ0ZXgNCiAgICAgICB2ZXJ0ZXguZnJhbWUuY29sb3IgPSJibGFjayIsICAgICAgICAgIA0KICAgICAgIHZlcnRleC5zaXplMj1OQSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgDQogICAgICAgIyA9PT0gdmVydGV4IGxhYmVsDQogICAgICAgdmVydGV4LmxhYmVsPU5BLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmZhbWlseT0iVGltZXMiLCAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmZvbnQ9MiwgICAgICAgICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuY2V4PTEsICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgdmVydGV4LmxhYmVsLmRpc3Q9MCwgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICB2ZXJ0ZXgubGFiZWwuZGVncmVlPTAgLCAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICANCiAgICAgICAjID09PSBFZGdlDQogICAgICAgZWRnZS5jb2xvcj0iYmxhY2siLCAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2Uud2lkdGg9MSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIA0KICAgICAgIGVkZ2UuYXJyb3cuc2l6ZT0uNCwgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS5hcnJvdy53aWR0aD0xLCAgICAgICAgICAgICAgICAgICAgICAgICANCiAgICAgICBlZGdlLmx0eT0ic29saWQiLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgDQogICAgICAgZWRnZS5jdXJ2ZWQ9MCkNCiAgDQogICMgQWRkIGEgbGVnZW5kDQogIGxlZ2VuZCgiYm90dG9tbGVmdCIsIGxlZ2VuZD1jKCJlZ28iLCAiYWx0ZXIiKSwNCiAgICAgICAgIGNvbCA9IHZlcnRleC5hdHRyaWJ1dGVzKEcpJGNvbG9yLCBidHkgPSAibiIsIHB0LmNleCA9IDIuNSwgcGNoID0gYygxNSwgMTkpLCBob3JpeiA9IEYsIGluc2V0ID0gYygwLjE1LCAwLjE1KQ0KICApDQp9DQpgYGANCg0KDQojIyMgey19DQoNCjwhLS0tIA0KDQojUkY6IGVzcGVjaWFsbHkgRTMgYW5kIEU1IHNlZW0gYXBwcm9wcmlhdGUgZm9yIFItU0lFTkEgKGhpZ2ggZGVuc2l0eSkNCi0tLT4gDQoNCg0KLS0tLQ0KDQo8YnI+DQoNCiMjIFByaW50IHJlcG9ydA0KIyMjIHsudGFic2V0IC50YWJzZXQtZmFkZX0gDQpMZXQncyBnZXQgc29tZSBmaXJzdCBkZXNjcmlwdGl2ZXMgb2YgdGhlIGVnb25ldHMNCg0KYGBge3IgZXZhbCA9IEZ9DQpkZiA8LSBlZ29kYXRhMS41X3JzaWVuYVtbMV1dICMgZ3JhYiBjbHViIA0KcHJpbnQwMVJlcG9ydChkZiwgbW9kZWxuYW1lPSJmaWxlcy9lZ28xXzEuNSIpDQoNCmRmIDwtIGVnb2RhdGExLjVfcnNpZW5hW1syXV0gIyBncmFiIGNsdWIgDQpwcmludDAxUmVwb3J0KGRmLCBtb2RlbG5hbWU9ImZpbGVzL2VnbzJfMS41IikNCg0KZGYgPC0gZWdvZGF0YTEuNV9yc2llbmFbWzNdXSAjIGdyYWIgY2x1YiANCnByaW50MDFSZXBvcnQoZGYsIG1vZGVsbmFtZT0iZmlsZXMvZWdvM18xLjUiKQ0KDQpkZiA8LSBlZ29kYXRhMS41X3JzaWVuYVtbNF1dICMgZ3JhYiBjbHViIA0KcHJpbnQwMVJlcG9ydChkZiwgbW9kZWxuYW1lPSJmaWxlcy9lZ280XzEuNSIpDQoNCmRmIDwtIGVnb2RhdGExLjVfcnNpZW5hW1s1XV0gIyBncmFiIGNsdWIgDQpwcmludDAxUmVwb3J0KGRmLCBtb2RlbG5hbWU9ImZpbGVzL2VnbzVfMS41IikNCg0KZGYgPC0gZWdvZGF0YTEuNV9yc2llbmFbWzZdXSAjIGdyYWIgY2x1YiANCnByaW50MDFSZXBvcnQoZGYsIG1vZGVsbmFtZT0iZmlsZXMvZWdvNl8xLjUiKQ0KDQpkZiA8LSBlZ29kYXRhMS41X3JzaWVuYVtbN11dICMgZ3JhYiBjbHViIA0KcHJpbnQwMVJlcG9ydChkZiwgbW9kZWxuYW1lPSJmaWxlcy9lZ283XzEuNSIpDQoNCmRmIDwtIGVnb2RhdGExLjVfcnNpZW5hW1s4XV0gIyBncmFiIGNsdWIgDQpwcmludDAxUmVwb3J0KGRmLCBtb2RlbG5hbWU9ImZpbGVzL2VnbzhfMS41IikNCg0KZGYgPC0gZWdvZGF0YTEuNV9yc2llbmFbWzldXSAjIGdyYWIgY2x1YiANCnByaW50MDFSZXBvcnQoZGYsIG1vZGVsbmFtZT0iZmlsZXMvZWdvOV8xLjUiKQ0KDQpkZiA8LSBlZ29kYXRhMS41X3JzaWVuYVtbMTBdXSAjIGdyYWIgY2x1YiANCnByaW50MDFSZXBvcnQoZGYsIG1vZGVsbmFtZT0iZmlsZXMvZWdvMTBfMS41IikNCg0KZGYgPC0gZWdvZGF0YTEuNV9yc2llbmFbWzExXV0gIyBncmFiIGNsdWIgDQpwcmludDAxUmVwb3J0KGRmLCBtb2RlbG5hbWU9ImZpbGVzL2VnbzExXzEuNSIpDQpgYGANCg0KPGJyPiANCg0KIyMjIyBFMQ0KDQohW10oZmlsZXMvZWdvMV8xLjUudHh0KXsjaWQgLmNsYXNzIHdpZHRoPTEwMCUgaGVpZ2h0PTIwMHB4fQ0KDQojIyMjIEUyDQoNCiFbXShmaWxlcy9lZ28yXzEuNS50eHQpeyNpZCAuY2xhc3Mgd2lkdGg9MTAwJSBoZWlnaHQ9MjAwcHh9DQoNCiMjIyMgRTMNCg0KIVtdKGZpbGVzL2VnbzNfMS41LnR4dCl7I2lkIC5jbGFzcyB3aWR0aD0xMDAlIGhlaWdodD0yMDBweH0NCg0KIyMjIyBFNA0KDQohW10oZmlsZXMvZWdvNF8xLjUudHh0KXsjaWQgLmNsYXNzIHdpZHRoPTEwMCUgaGVpZ2h0PTIwMHB4fQ0KDQojIyMjIEU1DQoNCiFbXShmaWxlcy9lZ281XzEuNS50eHQpeyNpZCAuY2xhc3Mgd2lkdGg9MTAwJSBoZWlnaHQ9MjAwcHh9DQoNCiMjIyMgRTYNCg0KIVtdKGZpbGVzL2VnbzZfMS41LnR4dCl7I2lkIC5jbGFzcyB3aWR0aD0xMDAlIGhlaWdodD0yMDBweH0NCg0KIyMjIyBFNw0KDQohW10oZmlsZXMvZWdvN18xLjUudHh0KXsjaWQgLmNsYXNzIHdpZHRoPTEwMCUgaGVpZ2h0PTIwMHB4fQ0KDQojIyMjIEU4DQoNCiFbXShmaWxlcy9lZ284XzEuNS50eHQpeyNpZCAuY2xhc3Mgd2lkdGg9MTAwJSBoZWlnaHQ9MjAwcHh9DQoNCiMjIyMgRTkNCg0KIVtdKGZpbGVzL2VnbzlfMS41LnR4dCl7I2lkIC5jbGFzcyB3aWR0aD0xMDAlIGhlaWdodD0yMDBweH0NCg0KIyMjIyBFMTANCg0KIVtdKGZpbGVzL2VnbzEwXzEuNS50eHQpeyNpZCAuY2xhc3Mgd2lkdGg9MTAwJSBoZWlnaHQ9MjAwcHh9DQoNCiMjIyMgRTExDQoNCiFbXShmaWxlcy9lZ28xMV8xLjUudHh0KXsjaWQgLmNsYXNzIHdpZHRoPTEwMCUgaGVpZ2h0PTIwMHB4fQ0KDQojIyMgey19DQoNCg0KLS0tLQ0KIyMjIFJlZmVyZW5jZXM=</div>
<style>
.center {
  text-align: center;
  color: red;
}
</style>

<hr>
<br>
<p class="center">Copyright &copy; 2021 Rob Franken</p>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("des.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
