<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Descriptive statistics</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>
<script src="site_libs/kePrint-0.0.1/kePrint.js"></script>
<link href="site_libs/lightable-0.0.1/lightable.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>

<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="prep.html">Preparation</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Descriptives
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="des.html">Procedure</a>
    </li>
    <li>
      <a href="destab.html">Table 1: Descriptives</a>
    </li>
    <li>
      <a href="desfig.html">Figure 5: Development of the mean running</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Model selection
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="explore.html">Club 1</a>
    </li>
    <li>
      <a href="other.html">Clubs 2-5</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Meta-analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="meta.html">Running frequency models</a>
    </li>
    <li>
      <a href="vol_meta.html">Running volume models</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    GOF
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="GOF1.html">Running frequency models</a>
    </li>
    <li>
      <a href="GOF2.html">Running volume</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Influence effects
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="influenceeffects.html">Different influence operationalizations</a>
    </li>
    <li>
      <a href="figure3.html">Figure 6: Ego-alter influence plot</a>
    </li>
    <li>
      <a href="RI.html">Figure 7: Relative importance of effects</a>
    </li>
    <li>
      <a href="simulations.html">Empirically calibrated SAOMs</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/robfranken/Strava">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Descriptive statistics</h1>
<h4 class="date">Last compiled on maart, 2022</h4>

</div>


<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('right', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
<hr />
<p>We will use the RSiena objects of clubs to describe the friendship
and kudo networks, constant covariates and behavioral variables.</p>
<p><br></p>
<div id="preparation" class="section level1">
<h1>Preparation</h1>
<p>Clean the working environment and load in the club data.</p>
<pre class="r test"><code># clean the working environment
rm(list = ls())

# load the RSiena objects
load(&quot;clubdata_rsiena_freq.RData&quot;)
load(&quot;clubdata_rsiena_vol.RData&quot;)</code></pre>
<p><br></p>
<p>We install and load the packages we need later on.</p>
<pre class="r test"><code># install if necessary
if (!require(&quot;RSiena&quot;, character.only = TRUE)) {
    install.packages(&quot;RSiena&quot;, dependencies = TRUE)
}
if (!require(&quot;igraph&quot;, character.only = TRUE)) {
    install.packages(&quot;igraph&quot;, dependencies = TRUE)
}
if (!require(&quot;tidyverse&quot;, character.only = TRUE)) {
    install.packages(&quot;tidyverse&quot;, dependencies = TRUE)
}
if (!require(&quot;tidyr&quot;, character.only = TRUE)) {
    install.packages(&quot;tidyr&quot;, dependencies = TRUE)
}
if (!require(&quot;moments&quot;, character.only = TRUE)) {
    install.packages(&quot;moments&quot;, dependencies = TRUE)
}
if (!require(&quot;dplyr&quot;, character.only = TRUE)) {
    install.packages(&quot;dplyr&quot;, dependencies = TRUE)
}
if (!require(&quot;ggplot2&quot;, character.only = TRUE)) {
    install.packages(&quot;ggplot2&quot;, dependencies = TRUE)
}
if (!require(&quot;forcats&quot;, character.only = TRUE)) {
    install.packages(&quot;forcats&quot;, dependencies = TRUE)
}
if (!require(&quot;knitr&quot;, character.only = TRUE)) {
    install.packages(&quot;knitr&quot;, dependencies = TRUE)
}
if (!require(&quot;kableExtra&quot;, character.only = TRUE)) {
    install.packages(&quot;kableExtra&quot;, dependencies = TRUE)
}
if (!require(&quot;network&quot;, character.only = TRUE)) {
    install.packages(&quot;network&quot;, dependencies = TRUE)
}
if (!require(&quot;sna&quot;, character.only = TRUE)) {
    install.packages(&quot;sna&quot;, dependencies = TRUE)
}

# load packages.
library(RSiena)  #RSiena models, some descriptives on network level
library(igraph)  #Descriptives: dyad/triad census, degree
library(tidyverse)
library(tidyr)  #for tidy data
library(moments)  #for calculating statistics (e.g., kurtosis, standard error)
library(dplyr)  #for data manipulation
library(ggplot2)  #for data visualisation
library(forcats)  #for handling categorical variables
library(knitr)  #for generating tables
library(kableExtra)  #for manipulating tables
library(network)  #for network analysis
library(sna)  #for network analysis</code></pre>
<hr />
<p>Now define some functions we use later on to describe our data (see
<a
href="https://www.jochemtolsma.nl/courses/complete-networks/socio6/#descriptive-statistics">www.jochemtolsma.nl</a>).</p>
<ul>
<li>fdensity: calculate density (exclude NA and structural zeros)<br />
</li>
<li>fdensityintra: calculate density within group (exclude NA and
structural zeros)<br />
</li>
<li>fdensityinter: calculate density between groups (exclude NA and
structural zeros)<br />
</li>
<li>fhomomat: based on ego/alter characteristics, construct dyad
characteristic whether or not ego/alter are same</li>
<li>fndyads: calculate all valid dyads (no NA or structural zeros)<br />
</li>
<li>fscolnet: calculate Coleman’s segregation index on the
network-level<br />
</li>
<li>fMoran.i: calculate Moran’s I spatial autocorrelation statistic (see
<a
href="https://www.jochemtolsma.nl/courses/complete-networks/socio7/#morans-autocorrelation-for-outgoing-ties-rsiena-build-in-dataset">here</a>)</li>
</ul>
<pre class="r fold-hide"><code># density: observed relations divided by possible relations
fdensity &lt;- function(x) {
    # x is your nomination network make sure diagonal cells are NA
    diag(x) &lt;- NA
    # take care of RSiena structural zeros, set as missing.
    x[x == 10] &lt;- NA
    sum(x == 1, na.rm = T)/(sum(x == 1 | x == 0, na.rm = T))
}

# calculate intragroup density
fdensityintra &lt;- function(x, A) {
    # A is matrix indicating whether nodes in dyad have same node attributes
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    diag(A) &lt;- NA
    sum(x == 1 &amp; A == 1, na.rm = T)/(sum((x == 1 | x == 0) &amp; A == 1, na.rm = T))
}

# calculate intragroup density
fdensityinter &lt;- function(x, A) {
    # A is matrix indicating whether nodes in dyad have same node attributes
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    diag(A) &lt;- NA
    sum(x == 1 &amp; A != 1, na.rm = T)/(sum((x == 1 | x == 0) &amp; A != 1, na.rm = T))
}

# construct dyad characteristic whether nodes are similar/homogenous
fhomomat &lt;- function(x) {
    # x is a vector of node-covariate
    xmat &lt;- matrix(x, nrow = length(x), ncol = length(x))
    xmatt &lt;- t(xmat)
    xhomo &lt;- xmat == xmatt
    return(xhomo)
}

# a function to calculate all valid dyads.
fndyads &lt;- function(x) {
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    (sum((x == 1 | x == 0), na.rm = T))
}

# a function to calculate all valid intragroupdyads.
fndyads2 &lt;- function(x, A) {
    diag(x) &lt;- NA
    x[x == 10] &lt;- NA
    diag(A) &lt;- NA
    (sum((x == 1 | x == 0) &amp; A == 1, na.rm = T))
}


fscolnet &lt;- function(network, ccovar) {
    # Calculate coleman on network level:
    # https://reader.elsevier.com/reader/sd/pii/S0378873314000239?token=A42F99FF6E2B750436DD2CB0DB7B1F41BDEC16052A45683C02644DAF88215A3379636B2AA197B65941D6373E9E2EE413

    fhomomat &lt;- function(x) {
        xmat &lt;- matrix(x, nrow = length(x), ncol = length(x))
        xmatt &lt;- t(xmat)
        xhomo &lt;- xmat == xmatt
        return(xhomo)
    }

    fsumintra &lt;- function(x, A) {
        # A is matrix indicating whether nodes constituting dyad have same characteristics
        diag(x) &lt;- NA
        x[x == 10] &lt;- NA
        diag(A) &lt;- NA
        sum(x == 1 &amp; A == 1, na.rm = T)
    }

    # expecation w*=sum_g sum_i (ni((ng-1)/(N-1)))
    network[network == 10] &lt;- NA
    ni &lt;- rowSums(network, na.rm = T)
    ng &lt;- NA
    for (i in 1:length(ccovar)) {
        ng[i] &lt;- table(ccovar)[rownames(table(ccovar)) == ccovar[i]]
    }
    N &lt;- length(ccovar)
    wexp &lt;- sum(ni * ((ng - 1)/(N - 1)), na.rm = T)

    # wgg1 how many intragroup ties
    w &lt;- fsumintra(network, fhomomat(ccovar))

    Scol_net &lt;- ifelse(w &gt;= wexp, (w - wexp)/(sum(ni, na.rm = T) - wexp), (w - wexp)/wexp)
    return(Scol_net)
}

fMoran.I &lt;- function(x, weight, scaled = FALSE, na.rm = FALSE, alternative = &quot;two.sided&quot;, rowstandardize = TRUE) {
    if (rowstandardize) {
        if (dim(weight)[1] != dim(weight)[2])
            stop(&quot;&#39;weight&#39; must be a square matrix&quot;)
        n &lt;- length(x)
        if (dim(weight)[1] != n)
            stop(&quot;&#39;weight&#39; must have as many rows as observations in &#39;x&#39;&quot;)
        ei &lt;- -1/(n - 1)
        nas &lt;- is.na(x)
        if (any(nas)) {
            if (na.rm) {
                x &lt;- x[!nas]
                n &lt;- length(x)
                weight &lt;- weight[!nas, !nas]
            } else {
                warning(&quot;&#39;x&#39; has missing values: maybe you wanted to set na.rm = TRUE?&quot;)
                return(list(observed = NA, expected = ei, sd = NA, p.value = NA))
            }
        }
        ROWSUM &lt;- rowSums(weight)
        ROWSUM[ROWSUM == 0] &lt;- 1
        weight &lt;- weight/ROWSUM
        s &lt;- sum(weight)
        m &lt;- mean(x)
        y &lt;- x - m
        cv &lt;- sum(weight * y %o% y)
        v &lt;- sum(y^2)
        obs &lt;- (n/s) * (cv/v)
        if (scaled) {
            i.max &lt;- (n/s) * (sd(rowSums(weight) * y)/sqrt(v/(n - 1)))
            obs &lt;- obs/i.max
        }
        S1 &lt;- 0.5 * sum((weight + t(weight))^2)
        S2 &lt;- sum((apply(weight, 1, sum) + apply(weight, 2, sum))^2)
        s.sq &lt;- s^2
        k &lt;- (sum(y^4)/n)/(v/n)^2
        sdi &lt;- sqrt((n * ((n^2 - 3 * n + 3) * S1 - n * S2 + 3 * s.sq) - k * (n * (n - 1) * S1 - 2 * n *
            S2 + 6 * s.sq))/((n - 1) * (n - 2) * (n - 3) * s.sq) - 1/((n - 1)^2))
        alternative &lt;- match.arg(alternative, c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;))
        pv &lt;- pnorm(obs, mean = ei, sd = sdi)
        if (alternative == &quot;two.sided&quot;)
            pv &lt;- if (obs &lt;= ei)
                2 * pv else 2 * (1 - pv)
        if (alternative == &quot;greater&quot;)
            pv &lt;- 1 - pv
        list(observed = obs, expected = ei, sd = sdi, p.value = pv)
    } else {
        if (dim(weight)[1] != dim(weight)[2])
            stop(&quot;&#39;weight&#39; must be a square matrix&quot;)
        n &lt;- length(x)
        if (dim(weight)[1] != n)
            stop(&quot;&#39;weight&#39; must have as many rows as observations in &#39;x&#39;&quot;)
        ei &lt;- -1/(n - 1)
        nas &lt;- is.na(x)
        if (any(nas)) {
            if (na.rm) {
                x &lt;- x[!nas]
                n &lt;- length(x)
                weight &lt;- weight[!nas, !nas]
            } else {
                warning(&quot;&#39;x&#39; has missing values: maybe you wanted to set na.rm = TRUE?&quot;)
                return(list(observed = NA, expected = ei, sd = NA, p.value = NA))
            }
        }
        # ROWSUM &lt;- rowSums(weight) ROWSUM[ROWSUM == 0] &lt;- 1 weight &lt;- weight/ROWSUM
        s &lt;- sum(weight)
        m &lt;- mean(x)
        y &lt;- x - m
        cv &lt;- sum(weight * y %o% y)
        v &lt;- sum(y^2)
        obs &lt;- (n/s) * (cv/v)
        if (scaled) {
            i.max &lt;- (n/s) * (sd(rowSums(weight) * y)/sqrt(v/(n - 1)))
            obs &lt;- obs/i.max
        }
        S1 &lt;- 0.5 * sum((weight + t(weight))^2)
        S2 &lt;- sum((apply(weight, 1, sum) + apply(weight, 2, sum))^2)
        s.sq &lt;- s^2
        k &lt;- (sum(y^4)/n)/(v/n)^2
        sdi &lt;- sqrt((n * ((n^2 - 3 * n + 3) * S1 - n * S2 + 3 * s.sq) - k * (n * (n - 1) * S1 - 2 * n *
            S2 + 6 * s.sq))/((n - 1) * (n - 2) * (n - 3) * s.sq) - 1/((n - 1)^2))
        alternative &lt;- match.arg(alternative, c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;))
        pv &lt;- pnorm(obs, mean = ei, sd = sdi)
        if (alternative == &quot;two.sided&quot;)
            pv &lt;- if (obs &lt;= ei)
                2 * pv else 2 * (1 - pv)
        if (alternative == &quot;greater&quot;)
            pv &lt;- 1 - pv
        list(observed = obs, expected = ei, sd = sdi, p.value = pv)
    }


}</code></pre>
<hr />
<p>We cover the following:</p>
<ul>
<li>club characteristics</li>
<li>network structure in Friendship and Kudos networks</li>
<li>gender composition / segregation</li>
<li>behavior: activity level (frequency and duration) and
correlation</li>
<li>spatial network autocorrelation: behavioral similarity in
networks</li>
</ul>
<hr />
<p><br></p>
</div>
<div id="print-report" class="section level1">
<h1>Print report</h1>
<div id="section" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade"></h2>
<p>Make sure to check the output of the ‘print01Report()’ function for
general data descripton (degrees, network size, etc.) and a general
overview of the dataset. Output is printed in a .txt file in the
directory specified.</p>
<div id="club-1" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[1]]  # grab club 
print01Report(df, modelname = &quot;files/club1&quot;)</code></pre>
<p><embed src="files/club1.txt" id="id" class="class"
style="width:100.0%" height="200" /></p>
</div>
<div id="club-2" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[2]]  # grab club 
print01Report(df, modelname = &quot;files/club2&quot;)</code></pre>
<p><embed src="files/club2.txt" id="id" class="class"
style="width:100.0%" height="200" /></p>
</div>
<div id="club-3" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[3]]  # grab club 
print01Report(df, modelname = &quot;files/club3&quot;)</code></pre>
<p><embed src="files/club3.txt" id="id" class="class"
style="width:100.0%" height="200" /></p>
</div>
<div id="club-4" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[4]]  # grab club 
print01Report(df, modelname = &quot;files/club4&quot;)</code></pre>
<p><embed src="files/club4.txt" id="id" class="class"
style="width:100.0%" height="200" /></p>
</div>
<div id="club-5" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[5]]  # grab club 
print01Report(df, modelname = &quot;files/club5&quot;)</code></pre>
<p><embed src="files/club5.txt" id="id" class="class"
style="width:100.0%" height="200" /></p>
</div>
</div>
<div id="section-1" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<hr />
</div>
</div>
<div id="club-characteristics" class="section level1">
<h1>Club characteristics</h1>
<p>Some club characteristics. We show the size of the network (the
number of actors) for each club and the number of active members
currently (18-1-2021) on Strava, by adding to
<em>www.strava.com/clubs/…</em> the original club id.</p>
<pre class="r test"><code># attrieve from the clubdata the number of actors in each network
netsize &lt;- c(length(clubdata_rsiena_freq[[1]]$nodeSets$Actors), length(clubdata_rsiena_freq[[2]]$nodeSets$Actors),
    length(clubdata_rsiena_freq[[3]]$nodeSets$Actors), length(clubdata_rsiena_freq[[4]]$nodeSets$Actors),
    length(clubdata_rsiena_freq[[5]]$nodeSets$Actors))

clubsize &lt;- c(66, 127, 373, 15, 169)  # find the number of members currently on Strava

df &lt;- data.frame(netsize = netsize, clubsize = clubsize)

print(df)</code></pre>
<pre class="test2"><code>#&gt;   netsize clubsize
#&gt; 1      30       66
#&gt; 2      62      127
#&gt; 3     165      373
#&gt; 4      13       15
#&gt; 5      77      169</code></pre>
<p><br></p>
<hr />
</div>
<div id="friendship-network" class="section level1">
<h1>Friendship network</h1>
<p>We describe the friendship network. Note that the friendship network
is a constant dyadic covariate.</p>
<div id="node-level" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade">1. Node-level</h2>
<p>Let’s describe the friendship-indegrees and -outdegrees of the
Strava-users in each club. We take from the RSiena object the friendship
network of the club in question, and turn it into an <em>igraph</em>
object. Then we find the in- and outdegree of each node.</p>
<div id="club-1-1" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[1]]  # grab club 
fnet &lt;- df$dycCovars$friendship  # take friendship network

# make a &#39;graph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of outdegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<pre class="r test"><code>`?`(hist)
hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of indegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-9-2.png" width="672" /></p>
</div>
<div id="club-2-1" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[2]]  # grab club 
fnet &lt;- df$dycCovars$friendship  # take friendship network

# make a &#39;graph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of outdegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of indegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-10-2.png" width="672" /></p>
</div>
<div id="club-3-1" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[3]]  # grab club 
fnet &lt;- df$dycCovars$friendship  # take friendship network

# make a &#39;graph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of outdegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of indegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-11-2.png" width="672" /></p>
</div>
<div id="club-4-1" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[4]]  # grab club 
fnet &lt;- df$dycCovars$friendship  # take friendship network

# make a &#39;graph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of outdegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of indegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-12-2.png" width="672" /></p>
</div>
<div id="club-5-1" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[5]]  # grab club 
fnet &lt;- df$dycCovars$friendship  # take friendship network

# make a &#39;graph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(fnet, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of outdegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of indegree Strava friendship network&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-13-2.png" width="672" /></p>
</div>
</div>
<div id="section-2" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>In general, we see that the in- and outdegree distribution is
right-skewed, suggesting that most Strava-users befriend and are
befriended by relatively few club-members, while fewer users befriend
and are befriended by many club-members.</p>
<p><br></p>
</div>
<div id="dyad-level" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade">2. Dyad-level</h2>
<p>Let’s investigate to what extent friendship-relationships (dyads) are
reciprocated or mutual. There are three types of dyad: mutual,
assymetric, and non-existent. We will classify dyads with the
dyad-census function, and we will investigate if we observe more mutual
dyads than we would expect based on chance.</p>
<div id="club-1-2" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena_freq[[1]]$dycCovars$friendship, mode = &quot;directed&quot;,
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 66
#&gt; 
#&gt; $asym
#&gt; [1] 8
#&gt; 
#&gt; $null
#&gt; [1] 361
#&gt; 
#&gt; $total
#&gt; [1] 435</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of mutual dyads in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
</div>
<div id="club-2-2" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena_freq[[2]]$dycCovars$friendship, mode = &quot;directed&quot;,
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dayds to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 436
#&gt; 
#&gt; $asym
#&gt; [1] 112
#&gt; 
#&gt; $null
#&gt; [1] 1343
#&gt; 
#&gt; $total
#&gt; [1] 1891</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of mutual dyads in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
</div>
<div id="club-3-2" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena_freq[[3]]$dycCovars$friendship, mode = &quot;directed&quot;,
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dayds to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 291
#&gt; 
#&gt; $asym
#&gt; [1] 129
#&gt; 
#&gt; $null
#&gt; [1] 13110
#&gt; 
#&gt; $total
#&gt; [1] 13530</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of mutual dyads in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
</div>
<div id="club-4-2" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena_freq[[4]]$dycCovars$friendship, mode = &quot;directed&quot;,
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dayds to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 25
#&gt; 
#&gt; $asym
#&gt; [1] 2
#&gt; 
#&gt; $null
#&gt; [1] 51
#&gt; 
#&gt; $total
#&gt; [1] 78</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of mutual dyads in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
</div>
<div id="club-5-2" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena_freq[[5]]$dycCovars$friendship, mode = &quot;directed&quot;,
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dayds to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 433
#&gt; 
#&gt; $asym
#&gt; [1] 120
#&gt; 
#&gt; $null
#&gt; [1] 2373
#&gt; 
#&gt; $total
#&gt; [1] 2926</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of mutual dyads in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
</div>
</div>
<div id="section-3" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>As expected, mutual dyads are way more prominent than would be
expected based on chance, which is indicative of reciprocity effects in
Strava-friendships among the members of clubs.</p>
<p><br></p>
</div>
<div id="triad-level" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade">3. Triad-level</h2>
<p>There are 16 types of triads; see <span class="citation">Davis and
Leinhardt (1967)</span>. They can be classified with the triad-census
function. See <a
href="https://igraph.org/r/doc/triad_census.html">here</a> for the order
in which the multiple triad classifications are counted.</p>
<p>Let’s also calculate for each club the (global) transitivity index,
which is the ratio of connected triplets (transitive triads) and
potentially connected triplets (see <a
href="http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf">here</a>).
The direction of the edges is ignored. We will then calculate the global
transitivity index for random (undirected) graphs.</p>
<div id="club-1-3" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena_freq[[1]]$dycCovars$friendship, mode = &quot;directed&quot;,
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify triads
triadcount &lt;- igraph::triad.census(G1)

# and print the 16 configurations
print(triadcount)</code></pre>
<pre class="test2"><code>#&gt;  [1] 2472  144 1080    0    6    0   27   19    0    0  192    1    0    0   20   99</code></pre>
<pre class="r test"><code># global (or undirected) transitivity index
igraph::transitivity(G1)</code></pre>
<pre class="test2"><code>#&gt; [1] 0.5960265</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- transitivity(random_graph)
}

{
    hist(recip, main = &quot;global transitivity index in random graph&quot;, xlab = &quot;&quot;)
    abline(v = transitivity(G1), col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
</div>
<div id="club-2-3" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena_freq[[2]]$dycCovars$friendship, mode = &quot;directed&quot;,
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify triads
triadcount &lt;- igraph::triad.census(G1)

# and print the 16 configurations
print(triadcount)</code></pre>
<pre class="test2"><code>#&gt;  [1] 15734  2517 11242   305   101    66   990   965    42     1  3433   166    70    26   651  1511</code></pre>
<pre class="r test"><code># global (or undirected) transitivity index
igraph::transitivity(G1)</code></pre>
<pre class="test2"><code>#&gt; [1] 0.5581027</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- transitivity(random_graph)
}

{
    hist(recip, main = &quot;global transitivity index in random graph&quot;, xlab = &quot;&quot;)
    abline(v = transitivity(G1), col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
</div>
<div id="club-3-3" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena_freq[[3]]$dycCovars$friendship, mode = &quot;directed&quot;,
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify triads
triadcount &lt;- igraph::triad.census(G1)

# and print the 16 configurations
print(triadcount)</code></pre>
<pre class="test2"><code>#&gt;  [1] 671047  18490  41738    274    142     78    556    728     11      0   1555     20     26
#&gt; [14]      7    126    332</code></pre>
<pre class="r test"><code># global (or undirected) transitivity index
igraph::transitivity(G1)</code></pre>
<pre class="test2"><code>#&gt; [1] 0.3196571</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- transitivity(random_graph)
}

{
    hist(recip, main = &quot;global transitivity index in random graph&quot;, xlab = &quot;&quot;)
    abline(v = transitivity(G1), col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
</div>
<div id="club-4-3" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena_freq[[4]]$dycCovars$friendship, mode = &quot;directed&quot;,
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify triads
triadcount &lt;- igraph::triad.census(G1)

# and print the 16 configurations
print(triadcount)</code></pre>
<pre class="test2"><code>#&gt;  [1]  69   5 152   0   0   1   5   9   0   0  25   0   0   0   1  19</code></pre>
<pre class="r test"><code># global (or undirected) transitivity index
igraph::transitivity(G1)</code></pre>
<pre class="test2"><code>#&gt; [1] 0.6</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- transitivity(random_graph)
}

{
    hist(recip, main = &quot;global transitivity index in random graph&quot;, xlab = &quot;&quot;)
    abline(v = transitivity(G1), col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
</div>
<div id="club-5-3" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code># make igraph object for the club
G1 &lt;- igraph::graph_from_adjacency_matrix(clubdata_rsiena_freq[[5]]$dycCovars$friendship, mode = &quot;directed&quot;,
    weighted = NULL, diag = TRUE, add.colnames = NA, add.rownames = NA)

# classify triads
triadcount &lt;- igraph::triad.census(G1)

# and print the 16 configurations
print(triadcount)</code></pre>
<pre class="test2"><code>#&gt;  [1] 42054  4944 18114   125   339    54   870  1072    12     0  3237    76   150    20   550  1533</code></pre>
<pre class="r test"><code># global (or undirected) transitivity index
igraph::transitivity(G1)</code></pre>
<pre class="test2"><code>#&gt; [1] 0.5521226</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- transitivity(random_graph)
}

hist(recip, main = &quot;global transitivity index in random graph&quot;, xlab = &quot;&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
</div>
</div>
<div id="section-4" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>Also transitivity is more prominent than would be expected solely
based on chance.</p>
<hr />
</div>
</div>
<div id="kudos-network" class="section level1">
<h1>Kudos network</h1>
<p>Now let’s describe the Kudos network.</p>
<div id="node-level-1" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade">1. Node-level</h2>
<p>Starting, again, with indegrees and outdegrees: who receives and
gives Kudos? We take from the RSiena object the Kudos network for each
club, subset the first wave, and turn it into an <em>igraph</em>
object.</p>
<div id="club-1-4" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[1]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-24-2.png" width="672" /></p>
</div>
<div id="club-2-4" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[2]]  # grab club t
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-25-2.png" width="672" /></p>
</div>
<div id="club-3-4" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[3]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-26-2.png" width="672" /></p>
</div>
<div id="club-4-4" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[4]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-27-2.png" width="672" /></p>
</div>
<div id="club-5-4" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[5]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# find in- and outdegree for each node
hist(igraph::degree(G1, mode = &quot;out&quot;), xlab = &quot;outdegree&quot;, main = &quot;histogram of Kudo outdegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<pre class="r test"><code>hist(igraph::degree(G1, mode = &quot;in&quot;), xlab = &quot;indegree&quot;, main = &quot;histogram of Kudo indegree&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-28-2.png" width="672" /></p>
</div>
</div>
<div id="section-5" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>We can observe the same Pareto-like-patern: some give/receive most of
the Kudos given, while most give/receive few.</p>
<p><br></p>
</div>
<div id="dyad-level-1" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade">2. Dyad-level</h2>
<p>At the dyad-level: let’s see to what extent Kudos tend to be
reciprocated between actors.</p>
<div id="club-1-5" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena_freq[[1]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 30
#&gt; 
#&gt; $asym
#&gt; [1] 5
#&gt; 
#&gt; $null
#&gt; [1] 400
#&gt; 
#&gt; $total
#&gt; [1] 435</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of reciprocated Kudos in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
</div>
<div id="club-2-5" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena_freq[[2]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 231
#&gt; 
#&gt; $asym
#&gt; [1] 99
#&gt; 
#&gt; $null
#&gt; [1] 1561
#&gt; 
#&gt; $total
#&gt; [1] 1891</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of reciprocated Kudos in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
</div>
<div id="club-3-5" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena_freq[[3]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 91
#&gt; 
#&gt; $asym
#&gt; [1] 104
#&gt; 
#&gt; $null
#&gt; [1] 13335
#&gt; 
#&gt; $total
#&gt; [1] 13530</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of reciprocated Kudos in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
</div>
<div id="club-4-5" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena_freq[[4]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 7
#&gt; 
#&gt; $asym
#&gt; [1] 2
#&gt; 
#&gt; $null
#&gt; [1] 69
#&gt; 
#&gt; $total
#&gt; [1] 78</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of reciprocated Kudos in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-32-1.png" width="672" /></p>
</div>
<div id="club-5-5" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code># make igraph object for the club, at wave 1
df &lt;- clubdata_rsiena_freq[[5]]  # grab club 
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# make an &#39;igraph object&#39;
G1 &lt;- igraph::graph_from_adjacency_matrix(knet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# classify dyads
dyadcount &lt;- igraph::dyad.census(G1)

# add the total number of dyads to the graph
dyadcount$total &lt;- (vcount(G1) * (vcount(G1) - 1))/2
dyadcount</code></pre>
<pre class="test2"><code>#&gt; $mut
#&gt; [1] 195
#&gt; 
#&gt; $asym
#&gt; [1] 119
#&gt; 
#&gt; $null
#&gt; [1] 2612
#&gt; 
#&gt; $total
#&gt; [1] 2926</code></pre>
<pre class="r test"><code># compare values with a random graph of the same size with the same density
dens &lt;- igraph::graph.density(G1)
size &lt;- igraph::vcount(G1)
trial &lt;- 1000
recip &lt;- rep(NA, trial)

for (i in 1:trial) {
    random_graph &lt;- igraph::erdos.renyi.game(n = size, p.or.m = dens, directed = TRUE)
    recip[i] &lt;- igraph::dyad.census(random_graph)$mut
}

{
    hist(recip, main = &quot;number of reciprocated Kudos in random graph&quot;, xlab = &quot;&quot;, )
    abline(v = dyadcount$mut, col = &quot;red&quot;, lwd = 3)
}</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-33-1.png" width="672" /></p>
</div>
</div>
<div id="section-6" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>Conclusion: Kudos tend to be reciprocated, like friendships!</p>
<hr />
<p><br></p>
</div>
</div>
<div id="gender-composition" class="section level1">
<h1>Gender composition</h1>
<div id="section-7" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade"></h2>
<p>Let’s investigate the gender composition of the club. We must
retrieve gender from the object (note that we use the clubdata object,
not the RSiena object). Then we make a categorical gender variable and
plot it.</p>
<div id="club-1-6" class="section level3">
<h3>Club 1</h3>
<pre class="r fold-hide"><code>load(&quot;clubdata.RData&quot;)
df &lt;- clubdata[[1]]  # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# make dataframe
df &lt;- data.frame(gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)), n = c(length(gender[gender ==
    &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender ==
    &quot;Missing&quot;])), freq = c(round((length(gender[gender == &quot;Male&quot;])/length(gender) * 100), digits = 1),
    round((length(gender[gender == &quot;Female&quot;])/length(gender) * 100), digits = 1), round((length(gender[gender ==
        &quot;Other&quot;])/length(gender) * 100), digits = 1), round((length(gender[gender == &quot;Missing&quot;])/length(gender) *
        100), digits = 1)))

# plot
df %&gt;%
    mutate(gender = fct_reorder(gender, -n)) %&gt;%
    ggplot(aes(gender, n, fill = gender)) + geom_bar(stat = &quot;identity&quot;, width = 0.8) + geom_text(aes(label = paste0(freq,
    &quot;%&quot;)), vjust = 1.5, colour = &quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-34-1.png" width="672" /></p>
</div>
<div id="club-2-6" class="section level3">
<h3>Club 2</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[2]]  # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# make dataframe
df &lt;- data.frame(gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)), n = c(length(gender[gender ==
    &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender ==
    &quot;Missing&quot;])), freq = c(round((length(gender[gender == &quot;Male&quot;])/length(gender) * 100), digits = 1),
    round((length(gender[gender == &quot;Female&quot;])/length(gender) * 100), digits = 1), round((length(gender[gender ==
        &quot;Other&quot;])/length(gender) * 100), digits = 1), round((length(gender[gender == &quot;Missing&quot;])/length(gender) *
        100), digits = 1)))

# plot
df %&gt;%
    mutate(gender = fct_reorder(gender, -n)) %&gt;%
    ggplot(aes(gender, n, fill = gender)) + geom_bar(stat = &quot;identity&quot;, width = 0.8) + geom_text(aes(label = paste0(freq,
    &quot;%&quot;)), vjust = 1.5, colour = &quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-35-1.png" width="672" /></p>
</div>
<div id="club-3-6" class="section level3">
<h3>Club 3</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[3]]  # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# make dataframe
df &lt;- data.frame(gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)), n = c(length(gender[gender ==
    &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender ==
    &quot;Missing&quot;])), freq = c(round((length(gender[gender == &quot;Male&quot;])/length(gender) * 100), digits = 1),
    round((length(gender[gender == &quot;Female&quot;])/length(gender) * 100), digits = 1), round((length(gender[gender ==
        &quot;Other&quot;])/length(gender) * 100), digits = 1), round((length(gender[gender == &quot;Missing&quot;])/length(gender) *
        100), digits = 1)))

# plot
df %&gt;%
    mutate(gender = fct_reorder(gender, -n)) %&gt;%
    ggplot(aes(gender, n, fill = gender)) + geom_bar(stat = &quot;identity&quot;, width = 0.8) + geom_text(aes(label = paste0(freq,
    &quot;%&quot;)), vjust = 1.5, colour = &quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-36-1.png" width="672" /></p>
</div>
<div id="club-4-6" class="section level3">
<h3>Club 4</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[4]]  # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# make dataframe
df &lt;- data.frame(gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)), n = c(length(gender[gender ==
    &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender ==
    &quot;Missing&quot;])), freq = c(round((length(gender[gender == &quot;Male&quot;])/length(gender) * 100), digits = 1),
    round((length(gender[gender == &quot;Female&quot;])/length(gender) * 100), digits = 1), round((length(gender[gender ==
        &quot;Other&quot;])/length(gender) * 100), digits = 1), round((length(gender[gender == &quot;Missing&quot;])/length(gender) *
        100), digits = 1)))

# plot
df %&gt;%
    mutate(gender = fct_reorder(gender, -n)) %&gt;%
    ggplot(aes(gender, n, fill = gender)) + geom_bar(stat = &quot;identity&quot;, width = 0.8) + geom_text(aes(label = paste0(freq,
    &quot;%&quot;)), vjust = 1.5, colour = &quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-37-1.png" width="672" /></p>
</div>
<div id="club-5-6" class="section level3">
<h3>Club 5</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[5]]  # grab club 

# retrieve node-attribute gender from object
male &lt;- df$male
female &lt;- df$female
other &lt;- df$other

# as factor
gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# make dataframe
df &lt;- data.frame(gender = as.factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;, &quot;Missing&quot;)), n = c(length(gender[gender ==
    &quot;Male&quot;]), length(gender[gender == &quot;Female&quot;]), length(gender[gender == &quot;Other&quot;]), length(gender[gender ==
    &quot;Missing&quot;])), freq = c(round((length(gender[gender == &quot;Male&quot;])/length(gender) * 100), digits = 1),
    round((length(gender[gender == &quot;Female&quot;])/length(gender) * 100), digits = 1), round((length(gender[gender ==
        &quot;Other&quot;])/length(gender) * 100), digits = 1), round((length(gender[gender == &quot;Missing&quot;])/length(gender) *
        100), digits = 1)))

# plot
df %&gt;%
    mutate(gender = fct_reorder(gender, -n)) %&gt;%
    ggplot(aes(gender, n, fill = gender)) + geom_bar(stat = &quot;identity&quot;, width = 0.8) + geom_text(aes(label = paste0(freq,
    &quot;%&quot;)), vjust = 1.5, colour = &quot;white&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-38-1.png" width="672" /></p>
</div>
</div>
<div id="section-8" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>We can see that in all clubs men are the majority.</p>
<hr />
<p><br></p>
</div>
</div>
<div id="gender-segregation" class="section level1">
<h1>Gender segregation</h1>
<p>Let’s now investigate segregation along gender in the friendship
network.</p>
<div id="section-9" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade"></h2>
<p>Let’s start with describing the total density and intra- (same
gender) and intergroup (different gender) densities. We also calculate
the Coleman Homophily index for gender, which reflects gender
segregation while taking into account the relative group size of gender
categories. We describe these segregation measures for friendship and
kudo-networks respectively.</p>
<div id="club-1-7" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[1]]  # grab club 
df2 &lt;- clubdata[[1]]

fnet &lt;- df$dycCovars$friendship  # take friendship network
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not
# work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)


# make object to store results
desmat &lt;- matrix(NA, nrow = 4, ncol = 2)

# use functions
desmat[1, 1] &lt;- fdensity(fnet)
desmat[2, 1] &lt;- fdensityintra(fnet, gender_m)
desmat[3, 1] &lt;- fdensityinter(fnet, gender_m)
desmat[4, 1] &lt;- fscolnet(fnet, gender)
desmat[1, 2] &lt;- fdensity(knet1)
desmat[2, 2] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 2] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 2] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;friendships&quot;, &quot;Kudos&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)



knitr::kable(desmat, digits = 2, &quot;html&quot;, caption = &quot;Gender segregation in friendship and kudo network&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
friendships
</th>
<th style="text-align:right;">
Kudos
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.16
</td>
<td style="text-align:right;">
0.07
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.19
</td>
<td style="text-align:right;">
0.12
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.14
</td>
<td style="text-align:right;">
0.05
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:right;">
0.26
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-2-7" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[2]]  # grab club 
df2 &lt;- clubdata[[2]]

fnet &lt;- df$dycCovars$friendship  # take friendship network
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not
# work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)


# make object to store results
desmat &lt;- matrix(NA, nrow = 4, ncol = 2)

# use functions
desmat[1, 1] &lt;- fdensity(fnet)
desmat[2, 1] &lt;- fdensityintra(fnet, gender_m)
desmat[3, 1] &lt;- fdensityinter(fnet, gender_m)
desmat[4, 1] &lt;- fscolnet(fnet, gender)
desmat[1, 2] &lt;- fdensity(knet1)
desmat[2, 2] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 2] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 2] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;friendships&quot;, &quot;Kudos&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)

# and make a nice table
knitr::kable(desmat, digits = 2, &quot;html&quot;, caption = &quot;Gender segregation in friendship and kudo network&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
friendships
</th>
<th style="text-align:right;">
Kudos
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.26
</td>
<td style="text-align:right;">
0.15
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.33
</td>
<td style="text-align:right;">
0.21
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.18
</td>
<td style="text-align:right;">
0.07
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
0.19
</td>
<td style="text-align:right;">
0.37
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-3-7" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[3]]  # grab club 
df2 &lt;- clubdata[[3]]

fnet &lt;- df$dycCovars$friendship  # take friendship network
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not
# work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)


# make object to store results
desmat &lt;- matrix(NA, nrow = 4, ncol = 2)

# use functions
desmat[1, 1] &lt;- fdensity(fnet)
desmat[2, 1] &lt;- fdensityintra(fnet, gender_m)
desmat[3, 1] &lt;- fdensityinter(fnet, gender_m)
desmat[4, 1] &lt;- fscolnet(fnet, gender)
desmat[1, 2] &lt;- fdensity(knet1)
desmat[2, 2] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 2] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 2] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;friendships&quot;, &quot;Kudos&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)

# and make a nice table
knitr::kable(desmat, digits = 2, &quot;html&quot;, caption = &quot;Gender segregation in friendship and kudo network&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
friendships
</th>
<th style="text-align:right;">
Kudos
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
0.01
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
0.01
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.02
</td>
<td style="text-align:right;">
0.01
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
0.09
</td>
<td style="text-align:right;">
0.03
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-4-7" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[4]]  # grab club 
df2 &lt;- clubdata[[4]]

fnet &lt;- df$dycCovars$friendship  # take friendship network
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not
# work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)


# make object to store results
desmat &lt;- matrix(NA, nrow = 4, ncol = 2)

# use functions
desmat[1, 1] &lt;- fdensity(fnet)
desmat[2, 1] &lt;- fdensityintra(fnet, gender_m)
desmat[3, 1] &lt;- fdensityinter(fnet, gender_m)
desmat[4, 1] &lt;- fscolnet(fnet, gender)
desmat[1, 2] &lt;- fdensity(knet1)
desmat[2, 2] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 2] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 2] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;friendships&quot;, &quot;Kudos&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)

# and make a nice table
knitr::kable(desmat, digits = 2, &quot;html&quot;, caption = &quot;Gender segregation in friendship and kudo network&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
friendships
</th>
<th style="text-align:right;">
Kudos
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.33
</td>
<td style="text-align:right;">
0.10
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.29
</td>
<td style="text-align:right;">
0.06
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.36
</td>
<td style="text-align:right;">
0.13
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
-0.12
</td>
<td style="text-align:right;">
-0.32
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-5-7" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[5]]  # grab club 
df2 &lt;- clubdata[[5]]

fnet &lt;- df$dycCovars$friendship  # take friendship network
knet &lt;- df$depvars$kudonet  # take Kudo network
knet1 &lt;- knet[, , 1]  # take wave 1 only for now

# for some reason constructing the dyad-similarity matrix for gender with the rsiena object did not
# work, so we use the clubdata.RData.
male &lt;- df2$male
female &lt;- df2$female
other &lt;- df2$other

gender &lt;- NA
gender &lt;- ifelse(male == 1, &quot;Male&quot;, gender)
gender &lt;- ifelse(female == 1, &quot;Female&quot;, gender)
gender &lt;- ifelse(other == 1, &quot;Other&quot;, gender)
gender &lt;- ifelse(is.na(gender), &quot;Missing&quot;, gender)  # missing category

# construct dyad similarity matrix
gender_m &lt;- fhomomat(gender)

# make object to store results
desmat &lt;- matrix(NA, nrow = 4, ncol = 2)

# use functions
desmat[1, 1] &lt;- fdensity(fnet)
desmat[2, 1] &lt;- fdensityintra(fnet, gender_m)
desmat[3, 1] &lt;- fdensityinter(fnet, gender_m)
desmat[4, 1] &lt;- fscolnet(fnet, gender)
desmat[1, 2] &lt;- fdensity(knet1)
desmat[2, 2] &lt;- fdensityintra(knet1, gender_m)
desmat[3, 2] &lt;- fdensityinter(knet1, gender_m)
desmat[4, 2] &lt;- fscolnet(knet1, gender)

colnames(desmat) &lt;- c(&quot;friendships&quot;, &quot;Kudos&quot;)
rownames(desmat) &lt;- c(&quot;total density&quot;, &quot;same gender density&quot;, &quot;different gender density&quot;, &quot;Coleman&#39;s homophily index&quot;)

# and make a nice table
knitr::kable(desmat, digits = 2, &quot;html&quot;, caption = &quot;Gender segregation in friendship and kudo network&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Gender segregation in friendship and kudo network
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
friendships
</th>
<th style="text-align:right;">
Kudos
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
total density
</td>
<td style="text-align:right;">
0.17
</td>
<td style="text-align:right;">
0.09
</td>
</tr>
<tr>
<td style="text-align:left;">
same gender density
</td>
<td style="text-align:right;">
0.16
</td>
<td style="text-align:right;">
0.09
</td>
</tr>
<tr>
<td style="text-align:left;">
different gender density
</td>
<td style="text-align:right;">
0.18
</td>
<td style="text-align:right;">
0.08
</td>
</tr>
<tr>
<td style="text-align:left;">
Coleman’s homophily index
</td>
<td style="text-align:right;">
-0.04
</td>
<td style="text-align:right;">
0.02
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="section-10" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>Density in friendships is not much higher within-gender than
between-genders, though this ratio differs per club (and in some clubs
between-gender friendships are more common). The same pattern holds for
Kudos-relationships.</p>
<p>Coleman’s Homophily indices vary across clubs. In some clubs there is
slight gender segregation (or same-gender preference) in friendship ties
(values higher than 0, but rather close to 0), though in others members
tend to befriend others outside their own gender (values lower than 0).
Overall, tendencies towards segregation (or avoidance thereof) are
pronounced to greater extent in the Kudos-relationships than in
friendships.</p>
<hr />
<p><br></p>
</div>
</div>
<div id="behavior" class="section level1">
<h1>Behavior</h1>
<p>We plotted the development of the mean of running attributes (Figure
5 of the manuscript). The script to replicate this plot can be found <a
href="https://robfranken.github.io/Strava/desfig.html">here</a>.</p>
</div>
<div id="within-person-change" class="section level1">
<h1>Within-person change</h1>
<div id="section-11" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade"></h2>
<p>Now let’s also check if behavior varied over time within individuals.
Within-person variation is a prerequisite for identifying influence
effects on behavior. Down below we demonstrate how running activity
varies within individuals over time, in absolute scores (i.e. in times
per week).</p>
<div id="club-1-8" class="section level3">
<h3>Club 1</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[1]]  # grab club

# check within-person variability of running frequency absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[, , ]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df &lt;- df[(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size = 9, replace = F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line() + facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) +
    xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-44-1.png" width="672" /></p>
</div>
<div id="club-2-8" class="section level3">
<h3>Club 2</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[2]]  # grab club

# check within-person variability of running frequency absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[, , ]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df &lt;- df[(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size = 9, replace = F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line() + facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) +
    xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-45-1.png" width="672" /></p>
</div>
<div id="club-3-8" class="section level3">
<h3>Club 3</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[3]]  # grab club

# check within-person variability of running frequency absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[, , ]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df &lt;- df[(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size = 9, replace = F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line() + facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) +
    xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-46-1.png" width="672" /></p>
</div>
<div id="club-4-8" class="section level3">
<h3>Club 4</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[4]]  # grab club

# check within-person variability of running frequency absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[, , ]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df &lt;- df[(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size = 9, replace = F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line() + facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) +
    xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-47-1.png" width="672" /></p>
</div>
<div id="club-5-8" class="section level3">
<h3>Club 5</h3>
<pre class="r fold-hide"><code>df &lt;- clubdata[[5]]  # grab club

# check within-person variability of running frequency absolute scores
size &lt;- df$netsize
y &lt;- array(c(df$freq_run[, , ]))
x &lt;- rep(1:12, size)
df &lt;- data.frame(y, x)
df &lt;- df[(order(df$x)), ]
df$id &lt;- rep(1:size, 12)

# get random sample of 9 persons
sample &lt;- sample(c(1:size), size = 9, replace = F)
df_new &lt;- dplyr::filter(df, id %in% sample)

# plot growth trajectories of random sample of 9 of all club members
p &lt;- ggplot(data = df_new, aes(x, y)) + geom_line() + facet_wrap(~id)
p + scale_x_continuous(breaks = seq(1, 12, 1)) + scale_y_continuous(breaks = seq(0, 8, 1)) + ggtitle(&quot;Growth trajectories in running frequency over time of a random sample of 9 actors&quot;) +
    xlab(&quot;Time in months&quot;) + ylab(&quot;Running frequency in times per week&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-48-1.png" width="672" /></p>
</div>
</div>
<div id="section-12" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>There seems to be ‘sufficient’ within-person variability in running
behavior, at least in frequency.</p>
<hr />
</div>
</div>
<div id="correlation-between-frequency-and-volume"
class="section level1">
<h1>Correlation between frequency and volume</h1>
<p>Let’s plot the relation between frequency in times per week and
volume in hours per week. We also calculate Kendall’s tau-b, i.e. a
non-parametric measure of correlation on ranks (cf. <span
class="citation">Khamis (2008)</span>).</p>
<div id="section-13" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade"></h2>
<div id="club-1-9" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code>df &lt;- clubdata[[1]]  # grab club 
df &lt;- data.frame(x = as.matrix(df$time_run), y = as.matrix(df$freq_run))

c &lt;- cor.test(df$x, df$y, method = &quot;kendall&quot;)

plot(df, type = &quot;b&quot;, main = &quot;Relation between weekly running variables: frequency and (half) hours&quot;,
    sub = &quot;Note: running frequency capped with a maximum of 7, hours with a maximum of 7&quot;, xlab = &quot;Hours per week&quot;,
    ylab = &quot;sessions per week&quot;, col = &quot;blue&quot;, lwd = c(1, rep(6, 10000))) + text(x = 1.7, y = 5, round(c$estimate,
    digits = 2)) + text(x = 0.7, y = 5, &quot;Kendall&#39;s tau-b =&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-49-1.png" width="672" /></p>
<pre class="test2"><code>#&gt; integer(0)</code></pre>
</div>
<div id="club-2-9" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code>df &lt;- clubdata[[2]]  # grab club 
df &lt;- data.frame(x = as.matrix(df$time_run), y = as.matrix(df$freq_run))
c &lt;- cor.test(df$x, df$y, method = &quot;kendall&quot;)

plot(df, type = &quot;b&quot;, main = &quot;Relation between weekly running variables: frequency and hours&quot;, sub = &quot;Note: running frequency capped with a maximum of 7, hours with a maximum of 7&quot;,
    xlab = &quot;hours per week&quot;, ylab = &quot;sessions per week&quot;, col = &quot;blue&quot;, lwd = c(1, rep(6, 10000))) + text(x = 1.7,
    y = 5, round(c$estimate, digits = 2)) + text(x = 0.7, y = 5, &quot;Kendall&#39;s tau-b =&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-50-1.png" width="672" /></p>
<pre class="test2"><code>#&gt; integer(0)</code></pre>
</div>
<div id="club-3-9" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code>df &lt;- clubdata[[3]]  # grab club 
df &lt;- data.frame(x = as.matrix(df$time_run), y = as.matrix(df$freq_run))
c &lt;- cor.test(df$x, df$y, method = &quot;kendall&quot;)

plot(df, type = &quot;b&quot;, main = &quot;Relation between weekly running variables: frequency and hours&quot;, sub = &quot;Note: running frequency capped with a maximum of 7, hours with a maximum of 7&quot;,
    xlab = &quot;hours per week&quot;, ylab = &quot;sessions per week&quot;, col = &quot;blue&quot;, lwd = c(1, rep(6, 10000))) + text(x = 1.7,
    y = 5, round(c$estimate, digits = 2)) + text(x = 0.7, y = 5, &quot;Kendall&#39;s tau-b =&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-51-1.png" width="672" /></p>
<pre class="test2"><code>#&gt; integer(0)</code></pre>
</div>
<div id="club-4-9" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code>df &lt;- clubdata[[4]]  # grab club 
df &lt;- data.frame(x = as.matrix(df$time_run), y = as.matrix(df$freq_run))
c &lt;- cor.test(df$x, df$y, method = &quot;kendall&quot;)

plot(df, type = &quot;b&quot;, main = &quot;Relation between weekly running variables: frequency and hours&quot;, sub = &quot;Note: running frequency capped with a maximum of 7, hours with a maximum of 7&quot;,
    xlab = &quot;hours per week&quot;, ylab = &quot;sessions per week&quot;, col = &quot;blue&quot;, lwd = c(1, rep(6, 10000))) + text(x = 1.5,
    y = 5, round(c$estimate, digits = 2)) + text(x = 0.7, y = 5, &quot;Kendall&#39;s tau-b =&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-52-1.png" width="672" /></p>
<pre class="test2"><code>#&gt; integer(0)</code></pre>
</div>
<div id="club-5-9" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code>df &lt;- clubdata[[5]]  # grab club 
df &lt;- data.frame(x = as.matrix(df$time_run), y = as.matrix(df$freq_run))
c &lt;- cor.test(df$x, df$y, method = &quot;kendall&quot;)

plot(df, type = &quot;b&quot;, main = &quot;Relation between weekly running variables: frequency and hours&quot;, sub = &quot;Note: running frequency capped with a maximum of 7, hours with a maximum of 7&quot;,
    xlab = &quot;hours per week&quot;, ylab = &quot;sessions per week&quot;, col = &quot;blue&quot;, lwd = c(1, rep(6, 10000))) + text(x = 2,
    y = 7, round(c$estimate, digits = 2)) + text(x = 0.7, y = 7, &quot;Kendall&#39;s tau-b =&quot;)</code></pre>
<p><img src="des_files/figure-html/unnamed-chunk-53-1.png" width="672" /></p>
<pre class="test2"><code>#&gt; integer(0)</code></pre>
</div>
</div>
<div id="section-14" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>Although frequency and duration are strongly related, there is some
invariance.</p>
<hr />
<p><br></p>
</div>
</div>
<div id="network-autocorrelation" class="section level1">
<h1>Network autocorrelation</h1>
<div id="section-15" class="section level2 tabset tabset-fade">
<h2 class="tabset tabset-fade"></h2>
<p>We have now covered the sport activity levels of our club-athletes,
and the extent to which friendship- and kudos-associations are
segregated along gender. Last, we will explore if friendship- and
kudos-ties are also segregated along activity levels. Or in other words:
do people with similar activity levels tend to socialize to a greater
extent - by befriending one another and by exchanging kudos - even when
taking into account the opportunity structures for ‘interacting’ with
(dis)similar others?</p>
<p>We use Moran’s I spatial autocorrelation measure for this, which is
the correlation between the behavioral score of actor <em>i</em> and the
(total/mean) behavioral score of alters <em>j</em> to whom <em>i</em> is
connected <strong>directly</strong>. We also calculated Moran’s I by
including the behavioral scores of the actors <em>h</em> to whom
<em>i</em> is indirectly tied, and used the negative exponential
function as described by <span class="citation">Chen (2013)</span> as a
distance-decay function for assigning weights.</p>
<div id="club-1-10" class="section level3">
<h3>Club 1</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[1]]  # grab club 
df2 &lt;- clubdata[[1]]  # grab club 

fnet &lt;- network::as.network(df$dycCovars$friendship)  # take friendship network
knet &lt;- df$depvars$kudonet  # take kudo network
knet1 &lt;- network::as.network(knet[, , 1])  # let&#39;s take wave 1

# get behavioral data
freq1 &lt;- df2$freq_run[, , 1]  # running frequencies wave 1
vol1 &lt;- df2$time_run[, , 1]  # running volume wave 1

# we include geodistances: shortest path lengths from i to j
f_geodistances &lt;- sna::geodist(fnet, count.paths = T)
f_geodistances &lt;- f_geodistances$gdist
k_geodistances &lt;- sna::geodist(knet1, count.paths = T)
k_geodistances &lt;- k_geodistances$gdist

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(f_geodistances) &lt;- Inf
diag(k_geodistances) &lt;- Inf

# first calculate Moran&#39;s i for alters at distance 1.
f_weights1 &lt;- f_geodistances == 1
k_weights1 &lt;- k_geodistances == 1

# and use the negative exponential distance-decay function
f_weights2 &lt;- exp(-f_geodistances)
k_weights2 &lt;- exp(-k_geodistances)

# calculate Moran&#39;s I for distance-1 and with distance decay, in the friendship and kudo network,
# for frequency and volume respectively we do not row standardize!
f_freq1 &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights1, na.rm = TRUE, rowstandardize = FALSE)
f_freq2 &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
f_vol1 &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights1, na.rm = TRUE, rowstandardize = FALSE)
f_vol2 &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)

k_freq1 &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights1, na.rm = TRUE, rowstandardize = FALSE)
k_freq2 &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_vol1 &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights1, na.rm = TRUE, rowstandardize = FALSE)
k_vol2 &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results 1. frequency
f_mat &lt;- matrix(NA, nrow = 4, ncol = 4)
f_mat[1, 1] &lt;- f_freq1$observed
f_mat[1, 2] &lt;- f_freq1$expected
f_mat[1, 3] &lt;- f_freq1$sd
f_mat[1, 4] &lt;- f_freq1$p.value
f_mat[2, 1] &lt;- f_freq2$observed
f_mat[2, 2] &lt;- f_freq2$expected
f_mat[2, 3] &lt;- f_freq2$sd
f_mat[2, 4] &lt;- f_freq2$p.value
f_mat[3, 1] &lt;- k_freq1$observed
f_mat[3, 2] &lt;- k_freq1$expected
f_mat[3, 3] &lt;- k_freq1$sd
f_mat[3, 4] &lt;- k_freq1$p.value
f_mat[4, 1] &lt;- k_freq2$observed
f_mat[4, 2] &lt;- k_freq2$expected
f_mat[4, 3] &lt;- k_freq2$sd
f_mat[4, 4] &lt;- k_freq2$p.value

# 2. volume
v_mat &lt;- matrix(NA, nrow = 4, ncol = 4)
v_mat[1, 1] &lt;- f_vol1$observed
v_mat[1, 2] &lt;- f_vol1$expected
v_mat[1, 3] &lt;- f_vol1$sd
v_mat[1, 4] &lt;- f_vol1$p.value
v_mat[2, 1] &lt;- f_vol2$observed
v_mat[2, 2] &lt;- f_vol2$expected
v_mat[2, 3] &lt;- f_vol2$sd
v_mat[2, 4] &lt;- f_vol2$p.value
v_mat[3, 1] &lt;- k_vol1$observed
v_mat[3, 2] &lt;- k_vol1$expected
v_mat[3, 3] &lt;- k_vol1$sd
v_mat[3, 4] &lt;- k_vol1$p.value
v_mat[4, 1] &lt;- k_vol2$observed
v_mat[4, 2] &lt;- k_vol2$expected
v_mat[4, 3] &lt;- k_vol2$sd
v_mat[4, 4] &lt;- k_vol2$p.value

colnames(f_mat) &lt;- colnames(v_mat) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(f_mat) &lt;- rownames(v_mat) &lt;- c(&quot;direct friends&quot;, &quot;direct and indirect friends (distance-decay)&quot;,
    &quot;direct kudos ties&quot;, &quot;direct and indirect kudos ties (distance-decay)&quot;)

knitr::kable(f_mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct friends
</td>
<td style="text-align:right;">
0.02
</td>
<td style="text-align:right;">
-0.03
</td>
<td style="text-align:right;">
0.09
</td>
<td style="text-align:right;">
0.55
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect friends (distance-decay)
</td>
<td style="text-align:right;">
0.00
</td>
<td style="text-align:right;">
-0.03
</td>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:right;">
0.48
</td>
</tr>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.29
</td>
<td style="text-align:right;">
-0.03
</td>
<td style="text-align:right;">
0.14
</td>
<td style="text-align:right;">
0.02
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.26
</td>
<td style="text-align:right;">
-0.03
</td>
<td style="text-align:right;">
0.09
</td>
<td style="text-align:right;">
0.00
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(v_mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct friends
</td>
<td style="text-align:right;">
-0.08
</td>
<td style="text-align:right;">
-0.03
</td>
<td style="text-align:right;">
0.09
</td>
<td style="text-align:right;">
0.62
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect friends (distance-decay)
</td>
<td style="text-align:right;">
-0.05
</td>
<td style="text-align:right;">
-0.03
</td>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:right;">
0.77
</td>
</tr>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.28
</td>
<td style="text-align:right;">
-0.03
</td>
<td style="text-align:right;">
0.14
</td>
<td style="text-align:right;">
0.02
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.27
</td>
<td style="text-align:right;">
-0.03
</td>
<td style="text-align:right;">
0.09
</td>
<td style="text-align:right;">
0.00
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-2-10" class="section level3">
<h3>Club 2</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[2]]  # grab club 
df2 &lt;- clubdata[[2]]  # grab club 

fnet &lt;- network::as.network(df$dycCovars$friendship)  # take friendship network
knet &lt;- df$depvars$kudonet  # take kudo network
knet1 &lt;- network::as.network(knet[, , 1])  # let&#39;s take wave 1

# get behavioral data
freq1 &lt;- df2$freq_run[, , 1]  # running frequencies wave 1
vol1 &lt;- df2$time_run[, , 1]  # running volume wave 1

# we include geodistances: shortest path lengths from i to j
f_geodistances &lt;- sna::geodist(fnet, count.paths = T)
f_geodistances &lt;- f_geodistances$gdist
k_geodistances &lt;- sna::geodist(knet1, count.paths = T)
k_geodistances &lt;- k_geodistances$gdist

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(f_geodistances) &lt;- Inf
diag(k_geodistances) &lt;- Inf

# first calculate Moran&#39;s i for alters at distance 1.
f_weights1 &lt;- f_geodistances == 1
k_weights1 &lt;- k_geodistances == 1

# and use the negative exponential distance-decay function
f_weights2 &lt;- exp(-f_geodistances)
k_weights2 &lt;- exp(-k_geodistances)

# calculate Moran&#39;s I for distance-1 and with distance decay, in the friendship and kudo network,
# for frequency and volume respectively we do not row standardize!
f_freq1 &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights1, na.rm = TRUE, rowstandardize = FALSE)
f_freq2 &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
f_vol1 &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights1, na.rm = TRUE, rowstandardize = FALSE)
f_vol2 &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)

k_freq1 &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights1, na.rm = TRUE, rowstandardize = FALSE)
k_freq2 &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_vol1 &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights1, na.rm = TRUE, rowstandardize = FALSE)
k_vol2 &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results 1. frequency
f_mat &lt;- matrix(NA, nrow = 4, ncol = 4)
f_mat[1, 1] &lt;- f_freq1$observed
f_mat[1, 2] &lt;- f_freq1$expected
f_mat[1, 3] &lt;- f_freq1$sd
f_mat[1, 4] &lt;- f_freq1$p.value
f_mat[2, 1] &lt;- f_freq2$observed
f_mat[2, 2] &lt;- f_freq2$expected
f_mat[2, 3] &lt;- f_freq2$sd
f_mat[2, 4] &lt;- f_freq2$p.value
f_mat[3, 1] &lt;- k_freq1$observed
f_mat[3, 2] &lt;- k_freq1$expected
f_mat[3, 3] &lt;- k_freq1$sd
f_mat[3, 4] &lt;- k_freq1$p.value
f_mat[4, 1] &lt;- k_freq2$observed
f_mat[4, 2] &lt;- k_freq2$expected
f_mat[4, 3] &lt;- k_freq2$sd
f_mat[4, 4] &lt;- k_freq2$p.value

# 2. volume
v_mat &lt;- matrix(NA, nrow = 4, ncol = 4)
v_mat[1, 1] &lt;- f_vol1$observed
v_mat[1, 2] &lt;- f_vol1$expected
v_mat[1, 3] &lt;- f_vol1$sd
v_mat[1, 4] &lt;- f_vol1$p.value
v_mat[2, 1] &lt;- f_vol2$observed
v_mat[2, 2] &lt;- f_vol2$expected
v_mat[2, 3] &lt;- f_vol2$sd
v_mat[2, 4] &lt;- f_vol2$p.value
v_mat[3, 1] &lt;- k_vol1$observed
v_mat[3, 2] &lt;- k_vol1$expected
v_mat[3, 3] &lt;- k_vol1$sd
v_mat[3, 4] &lt;- k_vol1$p.value
v_mat[4, 1] &lt;- k_vol2$observed
v_mat[4, 2] &lt;- k_vol2$expected
v_mat[4, 3] &lt;- k_vol2$sd
v_mat[4, 4] &lt;- k_vol2$p.value

colnames(f_mat) &lt;- colnames(v_mat) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(f_mat) &lt;- rownames(v_mat) &lt;- c(&quot;direct friends&quot;, &quot;direct and indirect friends (distance-decay)&quot;,
    &quot;direct kudos ties&quot;, &quot;direct and indirect kudos ties (distance-decay)&quot;)

knitr::kable(f_mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct friends
</td>
<td style="text-align:right;">
0.13
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect friends (distance-decay)
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.30
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.04
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.14
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.02
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(v_mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct friends
</td>
<td style="text-align:right;">
0.16
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect friends (distance-decay)
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.35
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.04
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.16
</td>
<td style="text-align:right;">
-0.02
</td>
<td style="text-align:right;">
0.02
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-3-10" class="section level3">
<h3>Club 3</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[3]]  # grab club 
df2 &lt;- clubdata[[3]]  # grab club 

fnet &lt;- network::as.network(df$dycCovars$friendship)  # take friendship network
knet &lt;- df$depvars$kudonet  # take kudo network
knet1 &lt;- network::as.network(knet[, , 1])  # let&#39;s take wave 1

# get behavioral data
freq1 &lt;- df2$freq_run[, , 1]  # running frequencies wave 1
vol1 &lt;- df2$time_run[, , 1]  # running volume wave 1

# we include geodistances: shortest path lengths from i to j
f_geodistances &lt;- sna::geodist(fnet, count.paths = T)
f_geodistances &lt;- f_geodistances$gdist
k_geodistances &lt;- sna::geodist(knet1, count.paths = T)
k_geodistances &lt;- k_geodistances$gdist

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(f_geodistances) &lt;- Inf
diag(k_geodistances) &lt;- Inf

# first calculate Moran&#39;s i for alters at distance 1.
f_weights1 &lt;- f_geodistances == 1
k_weights1 &lt;- k_geodistances == 1

# and use the negative exponential distance-decay function
f_weights2 &lt;- exp(-f_geodistances)
k_weights2 &lt;- exp(-k_geodistances)

# calculate Moran&#39;s I for distance-1 and with distance decay, in the friendship and kudo network,
# for frequency and volume respectively we do not row standardize!
f_freq1 &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights1, na.rm = TRUE, rowstandardize = FALSE)
f_freq2 &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
f_vol1 &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights1, na.rm = TRUE, rowstandardize = FALSE)
f_vol2 &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)

k_freq1 &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights1, na.rm = TRUE, rowstandardize = FALSE)
k_freq2 &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_vol1 &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights1, na.rm = TRUE, rowstandardize = FALSE)
k_vol2 &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results 1. frequency
f_mat &lt;- matrix(NA, nrow = 4, ncol = 4)
f_mat[1, 1] &lt;- f_freq1$observed
f_mat[1, 2] &lt;- f_freq1$expected
f_mat[1, 3] &lt;- f_freq1$sd
f_mat[1, 4] &lt;- f_freq1$p.value
f_mat[2, 1] &lt;- f_freq2$observed
f_mat[2, 2] &lt;- f_freq2$expected
f_mat[2, 3] &lt;- f_freq2$sd
f_mat[2, 4] &lt;- f_freq2$p.value
f_mat[3, 1] &lt;- k_freq1$observed
f_mat[3, 2] &lt;- k_freq1$expected
f_mat[3, 3] &lt;- k_freq1$sd
f_mat[3, 4] &lt;- k_freq1$p.value
f_mat[4, 1] &lt;- k_freq2$observed
f_mat[4, 2] &lt;- k_freq2$expected
f_mat[4, 3] &lt;- k_freq2$sd
f_mat[4, 4] &lt;- k_freq2$p.value

# 2. volume
v_mat &lt;- matrix(NA, nrow = 4, ncol = 4)
v_mat[1, 1] &lt;- f_vol1$observed
v_mat[1, 2] &lt;- f_vol1$expected
v_mat[1, 3] &lt;- f_vol1$sd
v_mat[1, 4] &lt;- f_vol1$p.value
v_mat[2, 1] &lt;- f_vol2$observed
v_mat[2, 2] &lt;- f_vol2$expected
v_mat[2, 3] &lt;- f_vol2$sd
v_mat[2, 4] &lt;- f_vol2$p.value
v_mat[3, 1] &lt;- k_vol1$observed
v_mat[3, 2] &lt;- k_vol1$expected
v_mat[3, 3] &lt;- k_vol1$sd
v_mat[3, 4] &lt;- k_vol1$p.value
v_mat[4, 1] &lt;- k_vol2$observed
v_mat[4, 2] &lt;- k_vol2$expected
v_mat[4, 3] &lt;- k_vol2$sd
v_mat[4, 4] &lt;- k_vol2$p.value

colnames(f_mat) &lt;- colnames(v_mat) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(f_mat) &lt;- rownames(v_mat) &lt;- c(&quot;direct friends&quot;, &quot;direct and indirect friends (distance-decay)&quot;,
    &quot;direct kudos ties&quot;, &quot;direct and indirect kudos ties (distance-decay)&quot;)

knitr::kable(f_mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct friends
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:right;">
0.43
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect friends (distance-decay)
</td>
<td style="text-align:right;">
0.00
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
0.51
</td>
</tr>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.14
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.07
</td>
<td style="text-align:right;">
0.05
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.08
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
0.00
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(v_mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct friends
</td>
<td style="text-align:right;">
0.08
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:right;">
0.06
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect friends (distance-decay)
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
0.19
</td>
</tr>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.35
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.07
</td>
<td style="text-align:right;">
0.00
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.21
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
0.00
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-4-10" class="section level3">
<h3>Club 4</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[4]]  # grab club 
df2 &lt;- clubdata[[4]]  # grab club 


fnet &lt;- network::as.network(df$dycCovars$friendship)  # take friendship network
knet &lt;- df$depvars$kudonet  # take kudo network
knet1 &lt;- network::as.network(knet[, , 1])  # let&#39;s take wave 1

# get behavioral data
freq1 &lt;- df2$freq_run[, , 1]  # running frequencies wave 1
vol1 &lt;- df2$time_run[, , 1]  # running volume wave 1

# we include geodistances: shortest path lengths from i to j
f_geodistances &lt;- sna::geodist(fnet, count.paths = T)
f_geodistances &lt;- f_geodistances$gdist
k_geodistances &lt;- sna::geodist(knet1, count.paths = T)
k_geodistances &lt;- k_geodistances$gdist

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(f_geodistances) &lt;- Inf
diag(k_geodistances) &lt;- Inf

# first calculate Moran&#39;s i for alters at distance 1.
f_weights1 &lt;- f_geodistances == 1
k_weights1 &lt;- k_geodistances == 1

# and use the negative exponential distance-decay function
f_weights2 &lt;- exp(-f_geodistances)
k_weights2 &lt;- exp(-k_geodistances)

# calculate Moran&#39;s I for distance-1 and with distance decay, in the friendship and kudo network,
# for frequency and volume respectively we do not row standardize!
f_freq1 &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights1, na.rm = TRUE, rowstandardize = FALSE)
f_freq2 &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
f_vol1 &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights1, na.rm = TRUE, rowstandardize = FALSE)
f_vol2 &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)

k_freq1 &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights1, na.rm = TRUE, rowstandardize = FALSE)
k_freq2 &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_vol1 &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights1, na.rm = TRUE, rowstandardize = FALSE)
k_vol2 &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results 1. frequency
f_mat &lt;- matrix(NA, nrow = 4, ncol = 4)
f_mat[1, 1] &lt;- f_freq1$observed
f_mat[1, 2] &lt;- f_freq1$expected
f_mat[1, 3] &lt;- f_freq1$sd
f_mat[1, 4] &lt;- f_freq1$p.value
f_mat[2, 1] &lt;- f_freq2$observed
f_mat[2, 2] &lt;- f_freq2$expected
f_mat[2, 3] &lt;- f_freq2$sd
f_mat[2, 4] &lt;- f_freq2$p.value
f_mat[3, 1] &lt;- k_freq1$observed
f_mat[3, 2] &lt;- k_freq1$expected
f_mat[3, 3] &lt;- k_freq1$sd
f_mat[3, 4] &lt;- k_freq1$p.value
f_mat[4, 1] &lt;- k_freq2$observed
f_mat[4, 2] &lt;- k_freq2$expected
f_mat[4, 3] &lt;- k_freq2$sd
f_mat[4, 4] &lt;- k_freq2$p.value

# 2. volume
v_mat &lt;- matrix(NA, nrow = 4, ncol = 4)
v_mat[1, 1] &lt;- f_vol1$observed
v_mat[1, 2] &lt;- f_vol1$expected
v_mat[1, 3] &lt;- f_vol1$sd
v_mat[1, 4] &lt;- f_vol1$p.value
v_mat[2, 1] &lt;- f_vol2$observed
v_mat[2, 2] &lt;- f_vol2$expected
v_mat[2, 3] &lt;- f_vol2$sd
v_mat[2, 4] &lt;- f_vol2$p.value
v_mat[3, 1] &lt;- k_vol1$observed
v_mat[3, 2] &lt;- k_vol1$expected
v_mat[3, 3] &lt;- k_vol1$sd
v_mat[3, 4] &lt;- k_vol1$p.value
v_mat[4, 1] &lt;- k_vol2$observed
v_mat[4, 2] &lt;- k_vol2$expected
v_mat[4, 3] &lt;- k_vol2$sd
v_mat[4, 4] &lt;- k_vol2$p.value

colnames(f_mat) &lt;- colnames(v_mat) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(f_mat) &lt;- rownames(v_mat) &lt;- c(&quot;direct friends&quot;, &quot;direct and indirect friends (distance-decay)&quot;,
    &quot;direct kudos ties&quot;, &quot;direct and indirect kudos ties (distance-decay)&quot;)

knitr::kable(f_mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct friends
</td>
<td style="text-align:right;">
-0.15
</td>
<td style="text-align:right;">
-0.08
</td>
<td style="text-align:right;">
0.16
</td>
<td style="text-align:right;">
0.65
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect friends (distance-decay)
</td>
<td style="text-align:right;">
-0.13
</td>
<td style="text-align:right;">
-0.08
</td>
<td style="text-align:right;">
0.09
</td>
<td style="text-align:right;">
0.62
</td>
</tr>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.54
</td>
<td style="text-align:right;">
-0.08
</td>
<td style="text-align:right;">
0.30
</td>
<td style="text-align:right;">
0.03
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.53
</td>
<td style="text-align:right;">
-0.08
</td>
<td style="text-align:right;">
0.29
</td>
<td style="text-align:right;">
0.03
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(v_mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct friends
</td>
<td style="text-align:right;">
-0.08
</td>
<td style="text-align:right;">
-0.08
</td>
<td style="text-align:right;">
0.16
</td>
<td style="text-align:right;">
0.96
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect friends (distance-decay)
</td>
<td style="text-align:right;">
-0.07
</td>
<td style="text-align:right;">
-0.08
</td>
<td style="text-align:right;">
0.09
</td>
<td style="text-align:right;">
0.90
</td>
</tr>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.70
</td>
<td style="text-align:right;">
-0.08
</td>
<td style="text-align:right;">
0.30
</td>
<td style="text-align:right;">
0.01
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.68
</td>
<td style="text-align:right;">
-0.08
</td>
<td style="text-align:right;">
0.29
</td>
<td style="text-align:right;">
0.01
</td>
</tr>
</tbody>
</table>
</div>
<div id="club-5-10" class="section level3">
<h3>Club 5</h3>
<pre class="r test"><code>df &lt;- clubdata_rsiena_freq[[5]]  # grab club 
df2 &lt;- clubdata[[5]]  # grab club 

fnet &lt;- network::as.network(df$dycCovars$friendship)  # take friendship network
knet &lt;- df$depvars$kudonet  # take kudo network
knet1 &lt;- network::as.network(knet[, , 1])  # let&#39;s take wave 1

# get behavioral data
freq1 &lt;- df2$freq_run[, , 1]  # running frequencies wave 1
vol1 &lt;- df2$time_run[, , 1]  # running volume wave 1

# we include geodistances: shortest path lengths from i to j
f_geodistances &lt;- sna::geodist(fnet, count.paths = T)
f_geodistances &lt;- f_geodistances$gdist
k_geodistances &lt;- sna::geodist(knet1, count.paths = T)
k_geodistances &lt;- k_geodistances$gdist

# set the distance &#39;to yourself&#39; to &#39;Inf&#39;
diag(f_geodistances) &lt;- Inf
diag(k_geodistances) &lt;- Inf

# first calculate Moran&#39;s i for alters at distance 1.
f_weights1 &lt;- f_geodistances == 1
k_weights1 &lt;- k_geodistances == 1

# and use the negative exponential distance-decay function
f_weights2 &lt;- exp(-f_geodistances)
k_weights2 &lt;- exp(-k_geodistances)

# calculate Moran&#39;s I for distance-1 and with distance decay, in the friendship and kudo network,
# for frequency and volume respectively we do not row standardize!
f_freq1 &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights1, na.rm = TRUE, rowstandardize = FALSE)
f_freq2 &lt;- fMoran.I(freq1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)
f_vol1 &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights1, na.rm = TRUE, rowstandardize = FALSE)
f_vol2 &lt;- fMoran.I(vol1, scaled = FALSE, weight = f_weights2, na.rm = TRUE, rowstandardize = FALSE)

k_freq1 &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights1, na.rm = TRUE, rowstandardize = FALSE)
k_freq2 &lt;- fMoran.I(freq1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)
k_vol1 &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights1, na.rm = TRUE, rowstandardize = FALSE)
k_vol2 &lt;- fMoran.I(vol1, scaled = FALSE, weight = k_weights2, na.rm = TRUE, rowstandardize = FALSE)

# make object to store results 1. frequency
f_mat &lt;- matrix(NA, nrow = 4, ncol = 4)
f_mat[1, 1] &lt;- f_freq1$observed
f_mat[1, 2] &lt;- f_freq1$expected
f_mat[1, 3] &lt;- f_freq1$sd
f_mat[1, 4] &lt;- f_freq1$p.value
f_mat[2, 1] &lt;- f_freq2$observed
f_mat[2, 2] &lt;- f_freq2$expected
f_mat[2, 3] &lt;- f_freq2$sd
f_mat[2, 4] &lt;- f_freq2$p.value
f_mat[3, 1] &lt;- k_freq1$observed
f_mat[3, 2] &lt;- k_freq1$expected
f_mat[3, 3] &lt;- k_freq1$sd
f_mat[3, 4] &lt;- k_freq1$p.value
f_mat[4, 1] &lt;- k_freq2$observed
f_mat[4, 2] &lt;- k_freq2$expected
f_mat[4, 3] &lt;- k_freq2$sd
f_mat[4, 4] &lt;- k_freq2$p.value

# 2. volume
v_mat &lt;- matrix(NA, nrow = 4, ncol = 4)
v_mat[1, 1] &lt;- f_vol1$observed
v_mat[1, 2] &lt;- f_vol1$expected
v_mat[1, 3] &lt;- f_vol1$sd
v_mat[1, 4] &lt;- f_vol1$p.value
v_mat[2, 1] &lt;- f_vol2$observed
v_mat[2, 2] &lt;- f_vol2$expected
v_mat[2, 3] &lt;- f_vol2$sd
v_mat[2, 4] &lt;- f_vol2$p.value
v_mat[3, 1] &lt;- k_vol1$observed
v_mat[3, 2] &lt;- k_vol1$expected
v_mat[3, 3] &lt;- k_vol1$sd
v_mat[3, 4] &lt;- k_vol1$p.value
v_mat[4, 1] &lt;- k_vol2$observed
v_mat[4, 2] &lt;- k_vol2$expected
v_mat[4, 3] &lt;- k_vol2$sd
v_mat[4, 4] &lt;- k_vol2$p.value

colnames(f_mat) &lt;- colnames(v_mat) &lt;- c(&quot;observed&quot;, &quot;expected&quot;, &quot;sd&quot;, &quot;p-value&quot;)
rownames(f_mat) &lt;- rownames(v_mat) &lt;- c(&quot;direct friends&quot;, &quot;direct and undirect friends (distance-decay)&quot;,
    &quot;direct kudos ties&quot;, &quot;direct and indirect kudos ties (distance-decay)&quot;)

knitr::kable(f_mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and weekly running frequency&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and weekly running frequency
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct friends
</td>
<td style="text-align:right;">
0.12
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and undirect friends (distance-decay)
</td>
<td style="text-align:right;">
0.06
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.26
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.18
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.02
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
<pre class="r test"><code>knitr::kable(v_mat, digits = 2, &quot;html&quot;, caption = &quot;Moran&#39;s I statistic for spatial autocorrelation based on geodistances and monthly running volume&quot;) %&gt;%
    kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;))</code></pre>
<table class="table table-striped table-hover" style="margin-left: auto; margin-right: auto;">
<caption>
Moran’s I statistic for spatial autocorrelation based on geodistances
and monthly running volume
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
observed
</th>
<th style="text-align:right;">
expected
</th>
<th style="text-align:right;">
sd
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
direct friends
</td>
<td style="text-align:right;">
0.12
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.03
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and undirect friends (distance-decay)
</td>
<td style="text-align:right;">
0.06
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.01
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct kudos ties
</td>
<td style="text-align:right;">
0.35
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
direct and indirect kudos ties (distance-decay)
</td>
<td style="text-align:right;">
0.21
</td>
<td style="text-align:right;">
-0.01
</td>
<td style="text-align:right;">
0.02
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="section-16" class="section level2 unnumbered">
<h2 class="unnumbered"></h2>
<p>Here, the Moran’s I statistic tests whether club members that are
<em>closer to one another</em> (i.e., having a shorter geodesic/path
length), are more a similar with respect to their behavior, under the
null hypothesis that behavior is ‘randomly distributed’ among the club
members.</p>
<p>We observe that, indeed, friends that are closer to one another are
more alike, and especially kudos-ties! Autocorrelation was stronger
without the distance-decay function, which suggests that especially
close alters (with path length one) are similar.</p>
<hr />
<p><br></p>
<hr />
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-chen2013" class="csl-entry">
Chen, Yanguang. 2013. <span>“New Approaches for Calculating Moran’s
Index of Spatial Autocorrelation.”</span> <em>PLOS ONE</em> 8 (7): –. <a
href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0068336">https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0068336</a>.
</div>
<div id="ref-davis1967structure" class="csl-entry">
Davis, James A, and Samuel Leinhardt. 1967. <span>“The Structure of
Positive Interpersonal Relations in Small Groups.”</span> <a
href="https://eric.ed.gov/?id=ED024086">https://eric.ed.gov/?id=ED024086</a>.
</div>
<div id="ref-khamis" class="csl-entry">
Khamis, Harry. 2008. <span>“Measures of Association: How to
Choose?”</span> <em>Journal of Diagnostic Medical Sonography</em> 24
(3): 155–62. <a
href="https://doi:10.1177/8756479308317006">doi:10.1177/8756479308317006</a>.
</div>
</div>
</div>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIkRlc2NyaXB0aXZlIHN0YXRpc3RpY3MiDQpkYXRlOiAiTGFzdCBjb21waWxlZCBvbiBgciBmb3JtYXQoU3lzLnRpbWUoKSwgJyVCLCAlWScpYCINCmJpYmxpb2dyYXBoeTogcmVmZXJlbmNlcy5iaWINCm91dHB1dDoNCiAgaHRtbF9kb2N1bWVudDoNCiAgICBjc3M6IHR3ZWFrcy5jc3MNCiAgICB0b2M6IHRydWUNCiAgICB0b2NfZmxvYXQ6IHRydWUNCiAgICBjb2xsYXBzZWQ6IGZhbHNlDQogICAgbnVtYmVyX3NlY3Rpb25zOiBmYWxzZQ0KICAgIHRvY19kZXB0aDogMQ0KICAgIGNvZGVfZm9sZGluZzogc2hvdw0KICAgIGNvZGVfZG93bmxvYWQ6IHllcw0KLS0tDQoNCg0KYGBge3IsIGdsb2JhbHNldHRpbmdzLCBlY2hvPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQ0KbGlicmFyeShrbml0cikNCmtuaXRyOjpvcHRzX2NodW5rJHNldChlY2hvID0gVFJVRSkNCm9wdHNfY2h1bmskc2V0KHRpZHkub3B0cz1saXN0KHdpZHRoLmN1dG9mZj0xMDApLHRpZHk9VFJVRSwgd2FybmluZyA9IEZBTFNFLCBtZXNzYWdlID0gRkFMU0UsY29tbWVudCA9ICIjPiIsIGNhY2hlPVRSVUUsIGNsYXNzLnNvdXJjZT1jKCJ0ZXN0IiksIGNsYXNzLm91dHB1dD1jKCJ0ZXN0MiIpKQ0Kb3B0aW9ucyh3aWR0aCA9IDEwMCkNCnJnbDo6c2V0dXBLbml0cigpDQoNCg0KDQpjb2xvcml6ZSA8LSBmdW5jdGlvbih4LCBjb2xvcikge3NwcmludGYoIjxzcGFuIHN0eWxlPSdjb2xvcjogJXM7Jz4lczwvc3Bhbj4iLCBjb2xvciwgeCkgfQ0KDQpgYGANCg0KYGBge3Iga2xpcHB5LCBlY2hvPUZBTFNFLCBpbmNsdWRlPVRSVUV9DQprbGlwcHk6OmtsaXBweShwb3NpdGlvbiA9IGMoJ3RvcCcsICdyaWdodCcpKQ0KI2tsaXBweTo6a2xpcHB5KGNvbG9yID0gJ2RhcmtyZWQnKQ0KI2tsaXBweTo6a2xpcHB5KHRvb2x0aXBfbWVzc2FnZSA9ICdDbGljayB0byBjb3B5JywgdG9vbHRpcF9zdWNjZXNzID0gJ0RvbmUnKQ0KYGBgDQoNCg0KDQotLS0NCg0KV2Ugd2lsbCB1c2UgdGhlIFJTaWVuYSBvYmplY3RzIG9mIGNsdWJzIHRvIGRlc2NyaWJlIHRoZSBmcmllbmRzaGlwIGFuZCBrdWRvIG5ldHdvcmtzLCBjb25zdGFudCBjb3ZhcmlhdGVzIGFuZCBiZWhhdmlvcmFsIHZhcmlhYmxlcy4gDQoNCjxicj4NCg0KIyBQcmVwYXJhdGlvbg0KDQpDbGVhbiB0aGUgd29ya2luZyBlbnZpcm9ubWVudCBhbmQgbG9hZCBpbiB0aGUgY2x1YiBkYXRhLg0KDQpgYGB7ciwgYXR0ci5vdXRwdXQ9J3N0eWxlPSJtYXgtaGVpZ2h0OiAyMDBweDsiJ30NCiMgY2xlYW4gdGhlIHdvcmtpbmcgZW52aXJvbm1lbnQgDQpybSAobGlzdCA9IGxzKCApKQ0KDQojIGxvYWQgdGhlIFJTaWVuYSBvYmplY3RzDQpsb2FkKCJjbHViZGF0YV9yc2llbmFfZnJlcS5SRGF0YSIpDQpsb2FkKCJjbHViZGF0YV9yc2llbmFfdm9sLlJEYXRhIikNCg0KYGBgDQoNCjxicj4NCg0KV2UgaW5zdGFsbCBhbmQgbG9hZCB0aGUgcGFja2FnZXMgd2UgbmVlZCBsYXRlciBvbi4NCg0KYGBge3IgcGFja2FnZXN9DQojaW5zdGFsbCBpZiBuZWNlc3NhcnkgDQppZiAoIXJlcXVpcmUoIlJTaWVuYSIsIGNoYXJhY3Rlci5vbmx5ID0gVFJVRSkpIHtpbnN0YWxsLnBhY2thZ2VzKCJSU2llbmEiLCBkZXBlbmRlbmNpZXM9VFJVRSl9DQppZiAoIXJlcXVpcmUoImlncmFwaCIsIGNoYXJhY3Rlci5vbmx5ID0gVFJVRSkpIHtpbnN0YWxsLnBhY2thZ2VzKCJpZ3JhcGgiLCBkZXBlbmRlbmNpZXM9VFJVRSl9DQppZiAoIXJlcXVpcmUoInRpZHl2ZXJzZSIsIGNoYXJhY3Rlci5vbmx5ID0gVFJVRSkpIHtpbnN0YWxsLnBhY2thZ2VzKCJ0aWR5dmVyc2UiLCBkZXBlbmRlbmNpZXM9VFJVRSl9DQppZiAoIXJlcXVpcmUoInRpZHlyIiwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKSkge2luc3RhbGwucGFja2FnZXMoInRpZHlyIiwgZGVwZW5kZW5jaWVzPVRSVUUpfQ0KaWYgKCFyZXF1aXJlKCJtb21lbnRzIiwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKSkge2luc3RhbGwucGFja2FnZXMoIm1vbWVudHMiLCBkZXBlbmRlbmNpZXM9VFJVRSl9DQppZiAoIXJlcXVpcmUoImRwbHlyIiwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKSkge2luc3RhbGwucGFja2FnZXMoImRwbHlyIiwgZGVwZW5kZW5jaWVzPVRSVUUpfQ0KaWYgKCFyZXF1aXJlKCJnZ3Bsb3QyIiwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKSkge2luc3RhbGwucGFja2FnZXMoImdncGxvdDIiLCBkZXBlbmRlbmNpZXM9VFJVRSl9DQppZiAoIXJlcXVpcmUoImZvcmNhdHMiLCBjaGFyYWN0ZXIub25seSA9IFRSVUUpKSB7aW5zdGFsbC5wYWNrYWdlcygiZm9yY2F0cyIsIGRlcGVuZGVuY2llcz1UUlVFKX0NCmlmICghcmVxdWlyZSgia25pdHIiLCBjaGFyYWN0ZXIub25seSA9IFRSVUUpKSB7aW5zdGFsbC5wYWNrYWdlcygia25pdHIiLCBkZXBlbmRlbmNpZXM9VFJVRSl9DQppZiAoIXJlcXVpcmUoImthYmxlRXh0cmEiLCBjaGFyYWN0ZXIub25seSA9IFRSVUUpKSB7aW5zdGFsbC5wYWNrYWdlcygia2FibGVFeHRyYSIsIGRlcGVuZGVuY2llcz1UUlVFKX0NCmlmICghcmVxdWlyZSgibmV0d29yayIsIGNoYXJhY3Rlci5vbmx5ID0gVFJVRSkpIHtpbnN0YWxsLnBhY2thZ2VzKCJuZXR3b3JrIiwgZGVwZW5kZW5jaWVzPVRSVUUpfQ0KaWYgKCFyZXF1aXJlKCJzbmEiLCBjaGFyYWN0ZXIub25seSA9IFRSVUUpKSB7aW5zdGFsbC5wYWNrYWdlcygic25hIiwgZGVwZW5kZW5jaWVzPVRSVUUpfQ0KDQojbG9hZCBwYWNrYWdlcy4NCmxpYnJhcnkoUlNpZW5hKSAjUlNpZW5hIG1vZGVscywgc29tZSBkZXNjcmlwdGl2ZXMgb24gbmV0d29yayBsZXZlbA0KbGlicmFyeShpZ3JhcGgpICNEZXNjcmlwdGl2ZXM6IGR5YWQvdHJpYWQgY2Vuc3VzLCBkZWdyZWUNCmxpYnJhcnkodGlkeXZlcnNlKQ0KbGlicmFyeSh0aWR5cikgI2ZvciB0aWR5IGRhdGENCmxpYnJhcnkobW9tZW50cykgI2ZvciBjYWxjdWxhdGluZyBzdGF0aXN0aWNzIChlLmcuLCBrdXJ0b3Npcywgc3RhbmRhcmQgZXJyb3IpDQpsaWJyYXJ5KGRwbHlyKSAjZm9yIGRhdGEgbWFuaXB1bGF0aW9uDQpsaWJyYXJ5KGdncGxvdDIpICNmb3IgZGF0YSB2aXN1YWxpc2F0aW9uDQpsaWJyYXJ5KGZvcmNhdHMpICNmb3IgaGFuZGxpbmcgY2F0ZWdvcmljYWwgdmFyaWFibGVzDQpsaWJyYXJ5KGtuaXRyKSAjZm9yIGdlbmVyYXRpbmcgdGFibGVzDQpsaWJyYXJ5KGthYmxlRXh0cmEpICNmb3IgbWFuaXB1bGF0aW5nIHRhYmxlcw0KbGlicmFyeShuZXR3b3JrKSAjZm9yIG5ldHdvcmsgYW5hbHlzaXMNCmxpYnJhcnkoc25hKSAjZm9yIG5ldHdvcmsgYW5hbHlzaXMNCmBgYA0KDQoNCi0tLS0NCg0KTm93IGRlZmluZSBzb21lIGZ1bmN0aW9ucyB3ZSB1c2UgbGF0ZXIgb24gdG8gZGVzY3JpYmUgb3VyIGRhdGEgKHNlZSBbd3d3LmpvY2hlbXRvbHNtYS5ubF0oaHR0cHM6Ly93d3cuam9jaGVtdG9sc21hLm5sL2NvdXJzZXMvY29tcGxldGUtbmV0d29ya3Mvc29jaW82LyNkZXNjcmlwdGl2ZS1zdGF0aXN0aWNzKSkuICANCg0KLSBmZGVuc2l0eTogY2FsY3VsYXRlIGRlbnNpdHkgKGV4Y2x1ZGUgTkEgYW5kIHN0cnVjdHVyYWwgemVyb3MpICANCi0gZmRlbnNpdHlpbnRyYTogY2FsY3VsYXRlIGRlbnNpdHkgd2l0aGluIGdyb3VwIChleGNsdWRlIE5BIGFuZCBzdHJ1Y3R1cmFsIHplcm9zKSAgDQotIGZkZW5zaXR5aW50ZXI6IGNhbGN1bGF0ZSBkZW5zaXR5IGJldHdlZW4gZ3JvdXBzIChleGNsdWRlIE5BIGFuZCBzdHJ1Y3R1cmFsIHplcm9zKSAgDQotIGZob21vbWF0OiBiYXNlZCBvbiBlZ28vYWx0ZXIgY2hhcmFjdGVyaXN0aWNzLCBjb25zdHJ1Y3QgZHlhZCBjaGFyYWN0ZXJpc3RpYyB3aGV0aGVyIG9yIG5vdCBlZ28vYWx0ZXIgYXJlIHNhbWUgDQotIGZuZHlhZHM6IGNhbGN1bGF0ZSBhbGwgdmFsaWQgZHlhZHMgKG5vIE5BIG9yIHN0cnVjdHVyYWwgemVyb3MpICANCi0gZnNjb2xuZXQ6IGNhbGN1bGF0ZSBDb2xlbWFuJ3Mgc2VncmVnYXRpb24gaW5kZXggb24gdGhlIG5ldHdvcmstbGV2ZWwgIA0KLSBmTW9yYW4uaTogY2FsY3VsYXRlIE1vcmFuJ3MgSSBzcGF0aWFsIGF1dG9jb3JyZWxhdGlvbiBzdGF0aXN0aWMgKHNlZSBbaGVyZV0oaHR0cHM6Ly93d3cuam9jaGVtdG9sc21hLm5sL2NvdXJzZXMvY29tcGxldGUtbmV0d29ya3Mvc29jaW83LyNtb3JhbnMtYXV0b2NvcnJlbGF0aW9uLWZvci1vdXRnb2luZy10aWVzLXJzaWVuYS1idWlsZC1pbi1kYXRhc2V0KSkNCg0KDQoNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KIyBkZW5zaXR5OiBvYnNlcnZlZCByZWxhdGlvbnMgZGl2aWRlZCBieSBwb3NzaWJsZSByZWxhdGlvbnMNCmZkZW5zaXR5IDwtIGZ1bmN0aW9uKHgpIHsNCiAgICAjIHggaXMgeW91ciBub21pbmF0aW9uIG5ldHdvcmsgbWFrZSBzdXJlIGRpYWdvbmFsIGNlbGxzIGFyZSBOQQ0KICAgIGRpYWcoeCkgPC0gTkENCiAgICAjIHRha2UgY2FyZSBvZiBSU2llbmEgc3RydWN0dXJhbCB6ZXJvcywgc2V0IGFzIG1pc3NpbmcuDQogICAgeFt4ID09IDEwXSA8LSBOQQ0KICAgIHN1bSh4ID09IDEsIG5hLnJtID0gVCkvKHN1bSh4ID09IDEgfCB4ID09IDAsIG5hLnJtID0gVCkpDQp9DQoNCiMgY2FsY3VsYXRlIGludHJhZ3JvdXAgZGVuc2l0eQ0KZmRlbnNpdHlpbnRyYSA8LSBmdW5jdGlvbih4LCBBKSB7DQogICAgIyBBIGlzIG1hdHJpeCBpbmRpY2F0aW5nIHdoZXRoZXIgbm9kZXMgaW4gZHlhZCBoYXZlIHNhbWUgbm9kZSBhdHRyaWJ1dGVzDQogICAgZGlhZyh4KSA8LSBOQQ0KICAgIHhbeCA9PSAxMF0gPC0gTkENCiAgICBkaWFnKEEpIDwtIE5BDQogICAgc3VtKHggPT0gMSAmIEEgPT0gMSwgbmEucm0gPSBUKS8oc3VtKCh4ID09IDEgfCB4ID09IDApICYgQSA9PSAxLCBuYS5ybSA9IFQpKQ0KfQ0KDQojIGNhbGN1bGF0ZSBpbnRyYWdyb3VwIGRlbnNpdHkNCmZkZW5zaXR5aW50ZXIgPC0gZnVuY3Rpb24oeCwgQSkgew0KICAgICMgQSBpcyBtYXRyaXggaW5kaWNhdGluZyB3aGV0aGVyIG5vZGVzIGluIGR5YWQgaGF2ZSBzYW1lIG5vZGUgYXR0cmlidXRlcw0KICAgIGRpYWcoeCkgPC0gTkENCiAgICB4W3ggPT0gMTBdIDwtIE5BDQogICAgZGlhZyhBKSA8LSBOQQ0KICAgIHN1bSh4ID09IDEgJiBBICE9IDEsIG5hLnJtID0gVCkvKHN1bSgoeCA9PSAxIHwgeCA9PSAwKSAmIEEgIT0gMSwgbmEucm0gPSBUKSkNCn0NCg0KIyBjb25zdHJ1Y3QgZHlhZCBjaGFyYWN0ZXJpc3RpYyB3aGV0aGVyIG5vZGVzIGFyZSBzaW1pbGFyL2hvbW9nZW5vdXMNCmZob21vbWF0IDwtIGZ1bmN0aW9uKHgpIHsNCiAgICAjIHggaXMgYSB2ZWN0b3Igb2Ygbm9kZS1jb3ZhcmlhdGUNCiAgICB4bWF0IDwtIG1hdHJpeCh4LCBucm93ID0gbGVuZ3RoKHgpLCBuY29sID0gbGVuZ3RoKHgpKQ0KICAgIHhtYXR0IDwtIHQoeG1hdCkNCiAgICB4aG9tbyA8LSB4bWF0ID09IHhtYXR0DQogICAgcmV0dXJuKHhob21vKQ0KfQ0KDQojIGEgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGFsbCB2YWxpZCBkeWFkcy4NCmZuZHlhZHMgPC0gZnVuY3Rpb24oeCkgew0KICAgIGRpYWcoeCkgPC0gTkENCiAgICB4W3ggPT0gMTBdIDwtIE5BDQogICAgKHN1bSgoeCA9PSAxIHwgeCA9PSAwKSwgbmEucm0gPSBUKSkNCn0NCg0KIyBhIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBhbGwgdmFsaWQgaW50cmFncm91cGR5YWRzLg0KZm5keWFkczIgPC0gZnVuY3Rpb24oeCwgQSkgew0KICAgIGRpYWcoeCkgPC0gTkENCiAgICB4W3ggPT0gMTBdIDwtIE5BDQogICAgZGlhZyhBKSA8LSBOQQ0KICAgIChzdW0oKHggPT0gMSB8IHggPT0gMCkgJiBBID09IDEsIG5hLnJtID0gVCkpDQp9DQoNCg0KZnNjb2xuZXQgPC0gZnVuY3Rpb24obmV0d29yaywgY2NvdmFyKSB7DQogICAgIyBDYWxjdWxhdGUgY29sZW1hbiBvbiBuZXR3b3JrIGxldmVsOg0KICAgICMgaHR0cHM6Ly9yZWFkZXIuZWxzZXZpZXIuY29tL3JlYWRlci9zZC9waWkvUzAzNzg4NzMzMTQwMDAyMzk/dG9rZW49QTQyRjk5RkY2RTJCNzUwNDM2REQyQ0IwREI3QjFGNDFCREVDMTYwNTJBNDU2ODNDMDI2NDREQUY4ODIxNUEzMzc5NjM2QjJBQTE5N0I2NTk0MUQ2MzczRTlFMkVFNDEzDQogICAgDQogICAgZmhvbW9tYXQgPC0gZnVuY3Rpb24oeCkgew0KICAgICAgICB4bWF0IDwtIG1hdHJpeCh4LCBucm93ID0gbGVuZ3RoKHgpLCBuY29sID0gbGVuZ3RoKHgpKQ0KICAgICAgICB4bWF0dCA8LSB0KHhtYXQpDQogICAgICAgIHhob21vIDwtIHhtYXQgPT0geG1hdHQNCiAgICAgICAgcmV0dXJuKHhob21vKQ0KICAgIH0NCiAgICANCiAgICBmc3VtaW50cmEgPC0gZnVuY3Rpb24oeCwgQSkgew0KICAgICAgICAjIEEgaXMgbWF0cml4IGluZGljYXRpbmcgd2hldGhlciBub2RlcyBjb25zdGl0dXRpbmcgZHlhZCBoYXZlIHNhbWUgY2hhcmFjdGVyaXN0aWNzDQogICAgICAgIGRpYWcoeCkgPC0gTkENCiAgICAgICAgeFt4ID09IDEwXSA8LSBOQQ0KICAgICAgICBkaWFnKEEpIDwtIE5BDQogICAgICAgIHN1bSh4ID09IDEgJiBBID09IDEsIG5hLnJtID0gVCkNCiAgICB9DQogICAgDQogICAgIyBleHBlY2F0aW9uIHcqPXN1bV9nIHN1bV9pIChuaSgobmctMSkvKE4tMSkpKQ0KICAgIG5ldHdvcmtbbmV0d29yayA9PSAxMF0gPC0gTkENCiAgICBuaSA8LSByb3dTdW1zKG5ldHdvcmssIG5hLnJtID0gVCkNCiAgICBuZyA8LSBOQQ0KICAgIGZvciAoaSBpbiAxOmxlbmd0aChjY292YXIpKSB7DQogICAgICAgIG5nW2ldIDwtIHRhYmxlKGNjb3Zhcilbcm93bmFtZXModGFibGUoY2NvdmFyKSkgPT0gY2NvdmFyW2ldXQ0KICAgIH0NCiAgICBOIDwtIGxlbmd0aChjY292YXIpDQogICAgd2V4cCA8LSBzdW0obmkgKiAoKG5nIC0gMSkvKE4gLSAxKSksIG5hLnJtID0gVCkNCiAgICANCiAgICAjIHdnZzEgaG93IG1hbnkgaW50cmFncm91cCB0aWVzDQogICAgdyA8LSBmc3VtaW50cmEobmV0d29yaywgZmhvbW9tYXQoY2NvdmFyKSkNCiAgICANCiAgICBTY29sX25ldCA8LSBpZmVsc2UodyA+PSB3ZXhwLCAodyAtIHdleHApLyhzdW0obmksIG5hLnJtID0gVCkgLSB3ZXhwKSwgKHcgLSB3ZXhwKS93ZXhwKQ0KICAgIHJldHVybihTY29sX25ldCkNCn0NCg0KZk1vcmFuLkkgPC0gZnVuY3Rpb24oeCwgd2VpZ2h0LCBzY2FsZWQgPSBGQUxTRSwgbmEucm0gPSBGQUxTRSwgYWx0ZXJuYXRpdmUgPSAidHdvLnNpZGVkIiwgcm93c3RhbmRhcmRpemUgPSBUUlVFKSB7DQogICAgaWYgKHJvd3N0YW5kYXJkaXplKSB7DQogICAgICAgIGlmIChkaW0od2VpZ2h0KVsxXSAhPSBkaW0od2VpZ2h0KVsyXSkgDQogICAgICAgICAgICBzdG9wKCInd2VpZ2h0JyBtdXN0IGJlIGEgc3F1YXJlIG1hdHJpeCIpDQogICAgICAgIG4gPC0gbGVuZ3RoKHgpDQogICAgICAgIGlmIChkaW0od2VpZ2h0KVsxXSAhPSBuKSANCiAgICAgICAgICAgIHN0b3AoIid3ZWlnaHQnIG11c3QgaGF2ZSBhcyBtYW55IHJvd3MgYXMgb2JzZXJ2YXRpb25zIGluICd4JyIpDQogICAgICAgIGVpIDwtIC0xLyhuIC0gMSkNCiAgICAgICAgbmFzIDwtIGlzLm5hKHgpDQogICAgICAgIGlmIChhbnkobmFzKSkgew0KICAgICAgICAgICAgaWYgKG5hLnJtKSB7DQogICAgICAgICAgICAgICAgeCA8LSB4WyFuYXNdDQogICAgICAgICAgICAgICAgbiA8LSBsZW5ndGgoeCkNCiAgICAgICAgICAgICAgICB3ZWlnaHQgPC0gd2VpZ2h0WyFuYXMsICFuYXNdDQogICAgICAgICAgICB9IGVsc2Ugew0KICAgICAgICAgICAgICAgIHdhcm5pbmcoIid4JyBoYXMgbWlzc2luZyB2YWx1ZXM6IG1heWJlIHlvdSB3YW50ZWQgdG8gc2V0IG5hLnJtID0gVFJVRT8iKQ0KICAgICAgICAgICAgICAgIHJldHVybihsaXN0KG9ic2VydmVkID0gTkEsIGV4cGVjdGVkID0gZWksIHNkID0gTkEsIHAudmFsdWUgPSBOQSkpDQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgUk9XU1VNIDwtIHJvd1N1bXMod2VpZ2h0KQ0KICAgICAgICBST1dTVU1bUk9XU1VNID09IDBdIDwtIDENCiAgICAgICAgd2VpZ2h0IDwtIHdlaWdodC9ST1dTVU0NCiAgICAgICAgcyA8LSBzdW0od2VpZ2h0KQ0KICAgICAgICBtIDwtIG1lYW4oeCkNCiAgICAgICAgeSA8LSB4IC0gbQ0KICAgICAgICBjdiA8LSBzdW0od2VpZ2h0ICogeSAlbyUgeSkNCiAgICAgICAgdiA8LSBzdW0oeV4yKQ0KICAgICAgICBvYnMgPC0gKG4vcykgKiAoY3YvdikNCiAgICAgICAgaWYgKHNjYWxlZCkgew0KICAgICAgICAgICAgaS5tYXggPC0gKG4vcykgKiAoc2Qocm93U3Vtcyh3ZWlnaHQpICogeSkvc3FydCh2LyhuIC0gMSkpKQ0KICAgICAgICAgICAgb2JzIDwtIG9icy9pLm1heA0KICAgICAgICB9DQogICAgICAgIFMxIDwtIDAuNSAqIHN1bSgod2VpZ2h0ICsgdCh3ZWlnaHQpKV4yKQ0KICAgICAgICBTMiA8LSBzdW0oKGFwcGx5KHdlaWdodCwgMSwgc3VtKSArIGFwcGx5KHdlaWdodCwgMiwgc3VtKSleMikNCiAgICAgICAgcy5zcSA8LSBzXjINCiAgICAgICAgayA8LSAoc3VtKHleNCkvbikvKHYvbileMg0KICAgICAgICBzZGkgPC0gc3FydCgobiAqICgobl4yIC0gMyAqIG4gKyAzKSAqIFMxIC0gbiAqIFMyICsgMyAqIHMuc3EpIC0gayAqIChuICogKG4gLSAxKSAqIFMxIC0gMiAqIG4gKiANCiAgICAgICAgICAgIFMyICsgNiAqIHMuc3EpKS8oKG4gLSAxKSAqIChuIC0gMikgKiAobiAtIDMpICogcy5zcSkgLSAxLygobiAtIDEpXjIpKQ0KICAgICAgICBhbHRlcm5hdGl2ZSA8LSBtYXRjaC5hcmcoYWx0ZXJuYXRpdmUsIGMoInR3by5zaWRlZCIsICJsZXNzIiwgImdyZWF0ZXIiKSkNCiAgICAgICAgcHYgPC0gcG5vcm0ob2JzLCBtZWFuID0gZWksIHNkID0gc2RpKQ0KICAgICAgICBpZiAoYWx0ZXJuYXRpdmUgPT0gInR3by5zaWRlZCIpIA0KICAgICAgICAgICAgcHYgPC0gaWYgKG9icyA8PSBlaSkgDQogICAgICAgICAgICAgICAgMiAqIHB2IGVsc2UgMiAqICgxIC0gcHYpDQogICAgICAgIGlmIChhbHRlcm5hdGl2ZSA9PSAiZ3JlYXRlciIpIA0KICAgICAgICAgICAgcHYgPC0gMSAtIHB2DQogICAgICAgIGxpc3Qob2JzZXJ2ZWQgPSBvYnMsIGV4cGVjdGVkID0gZWksIHNkID0gc2RpLCBwLnZhbHVlID0gcHYpDQogICAgfSBlbHNlIHsNCiAgICAgICAgaWYgKGRpbSh3ZWlnaHQpWzFdICE9IGRpbSh3ZWlnaHQpWzJdKSANCiAgICAgICAgICAgIHN0b3AoIid3ZWlnaHQnIG11c3QgYmUgYSBzcXVhcmUgbWF0cml4IikNCiAgICAgICAgbiA8LSBsZW5ndGgoeCkNCiAgICAgICAgaWYgKGRpbSh3ZWlnaHQpWzFdICE9IG4pIA0KICAgICAgICAgICAgc3RvcCgiJ3dlaWdodCcgbXVzdCBoYXZlIGFzIG1hbnkgcm93cyBhcyBvYnNlcnZhdGlvbnMgaW4gJ3gnIikNCiAgICAgICAgZWkgPC0gLTEvKG4gLSAxKQ0KICAgICAgICBuYXMgPC0gaXMubmEoeCkNCiAgICAgICAgaWYgKGFueShuYXMpKSB7DQogICAgICAgICAgICBpZiAobmEucm0pIHsNCiAgICAgICAgICAgICAgICB4IDwtIHhbIW5hc10NCiAgICAgICAgICAgICAgICBuIDwtIGxlbmd0aCh4KQ0KICAgICAgICAgICAgICAgIHdlaWdodCA8LSB3ZWlnaHRbIW5hcywgIW5hc10NCiAgICAgICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgICAgICAgd2FybmluZygiJ3gnIGhhcyBtaXNzaW5nIHZhbHVlczogbWF5YmUgeW91IHdhbnRlZCB0byBzZXQgbmEucm0gPSBUUlVFPyIpDQogICAgICAgICAgICAgICAgcmV0dXJuKGxpc3Qob2JzZXJ2ZWQgPSBOQSwgZXhwZWN0ZWQgPSBlaSwgc2QgPSBOQSwgcC52YWx1ZSA9IE5BKSkNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAjIFJPV1NVTSA8LSByb3dTdW1zKHdlaWdodCkgUk9XU1VNW1JPV1NVTSA9PSAwXSA8LSAxIHdlaWdodCA8LSB3ZWlnaHQvUk9XU1VNDQogICAgICAgIHMgPC0gc3VtKHdlaWdodCkNCiAgICAgICAgbSA8LSBtZWFuKHgpDQogICAgICAgIHkgPC0geCAtIG0NCiAgICAgICAgY3YgPC0gc3VtKHdlaWdodCAqIHkgJW8lIHkpDQogICAgICAgIHYgPC0gc3VtKHleMikNCiAgICAgICAgb2JzIDwtIChuL3MpICogKGN2L3YpDQogICAgICAgIGlmIChzY2FsZWQpIHsNCiAgICAgICAgICAgIGkubWF4IDwtIChuL3MpICogKHNkKHJvd1N1bXMod2VpZ2h0KSAqIHkpL3NxcnQodi8obiAtIDEpKSkNCiAgICAgICAgICAgIG9icyA8LSBvYnMvaS5tYXgNCiAgICAgICAgfQ0KICAgICAgICBTMSA8LSAwLjUgKiBzdW0oKHdlaWdodCArIHQod2VpZ2h0KSleMikNCiAgICAgICAgUzIgPC0gc3VtKChhcHBseSh3ZWlnaHQsIDEsIHN1bSkgKyBhcHBseSh3ZWlnaHQsIDIsIHN1bSkpXjIpDQogICAgICAgIHMuc3EgPC0gc14yDQogICAgICAgIGsgPC0gKHN1bSh5XjQpL24pLyh2L24pXjINCiAgICAgICAgc2RpIDwtIHNxcnQoKG4gKiAoKG5eMiAtIDMgKiBuICsgMykgKiBTMSAtIG4gKiBTMiArIDMgKiBzLnNxKSAtIGsgKiAobiAqIChuIC0gMSkgKiBTMSAtIDIgKiBuICogDQogICAgICAgICAgICBTMiArIDYgKiBzLnNxKSkvKChuIC0gMSkgKiAobiAtIDIpICogKG4gLSAzKSAqIHMuc3EpIC0gMS8oKG4gLSAxKV4yKSkNCiAgICAgICAgYWx0ZXJuYXRpdmUgPC0gbWF0Y2guYXJnKGFsdGVybmF0aXZlLCBjKCJ0d28uc2lkZWQiLCAibGVzcyIsICJncmVhdGVyIikpDQogICAgICAgIHB2IDwtIHBub3JtKG9icywgbWVhbiA9IGVpLCBzZCA9IHNkaSkNCiAgICAgICAgaWYgKGFsdGVybmF0aXZlID09ICJ0d28uc2lkZWQiKSANCiAgICAgICAgICAgIHB2IDwtIGlmIChvYnMgPD0gZWkpIA0KICAgICAgICAgICAgICAgIDIgKiBwdiBlbHNlIDIgKiAoMSAtIHB2KQ0KICAgICAgICBpZiAoYWx0ZXJuYXRpdmUgPT0gImdyZWF0ZXIiKSANCiAgICAgICAgICAgIHB2IDwtIDEgLSBwdg0KICAgICAgICBsaXN0KG9ic2VydmVkID0gb2JzLCBleHBlY3RlZCA9IGVpLCBzZCA9IHNkaSwgcC52YWx1ZSA9IHB2KQ0KICAgIH0NCiAgICANCiAgICANCn0NCmBgYA0KDQotLS0tDQoNCldlIGNvdmVyIHRoZSBmb2xsb3dpbmc6DQoNCiogY2x1YiBjaGFyYWN0ZXJpc3RpY3MNCiogbmV0d29yayBzdHJ1Y3R1cmUgaW4gRnJpZW5kc2hpcCBhbmQgS3Vkb3MgbmV0d29ya3MNCiogZ2VuZGVyIGNvbXBvc2l0aW9uIC8gc2VncmVnYXRpb24NCiogYmVoYXZpb3I6IGFjdGl2aXR5IGxldmVsIChmcmVxdWVuY3kgYW5kIGR1cmF0aW9uKSBhbmQgY29ycmVsYXRpb24NCiogc3BhdGlhbCBuZXR3b3JrIGF1dG9jb3JyZWxhdGlvbjogYmVoYXZpb3JhbCBzaW1pbGFyaXR5IGluIG5ldHdvcmtzDQoNCi0tLS0NCg0KPGJyPg0KDQojIFByaW50IHJlcG9ydA0KIyMgey50YWJzZXQgLnRhYnNldC1mYWRlfSANCk1ha2Ugc3VyZSB0byBjaGVjayB0aGUgb3V0cHV0IG9mIHRoZSAncHJpbnQwMVJlcG9ydCgpJyBmdW5jdGlvbiBmb3IgZ2VuZXJhbCBkYXRhIGRlc2NyaXB0b24gKGRlZ3JlZXMsIG5ldHdvcmsgc2l6ZSwgZXRjLikgYW5kIGEgZ2VuZXJhbCBvdmVydmlldyBvZiB0aGUgZGF0YXNldC4gT3V0cHV0IGlzIHByaW50ZWQgaW4gYSAudHh0IGZpbGUgaW4gdGhlIGRpcmVjdG9yeSBzcGVjaWZpZWQuDQoNCg0KIyMjIENsdWIgMQ0KYGBge3IgZXZhbD0gRn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1sxXV0gIyBncmFiIGNsdWIgDQpwcmludDAxUmVwb3J0KGRmLCBtb2RlbG5hbWU9ImZpbGVzL2NsdWIxIikNCmBgYA0KDQohW10oZmlsZXMvY2x1YjEudHh0KXsjaWQgLmNsYXNzIHdpZHRoPTEwMCUgaGVpZ2h0PTIwMHB4fQ0KDQojIyMgQ2x1YiAyDQpgYGB7ciBldmFsPSBGfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzJdXSAjIGdyYWIgY2x1YiANCnByaW50MDFSZXBvcnQoZGYsIG1vZGVsbmFtZT0iZmlsZXMvY2x1YjIiKQ0KYGBgDQoNCiFbXShmaWxlcy9jbHViMi50eHQpeyNpZCAuY2xhc3Mgd2lkdGg9MTAwJSBoZWlnaHQ9MjAwcHh9DQoNCiMjIyBDbHViIDMNCmBgYHtyIGV2YWw9IEZ9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFfZnJlcVtbM11dICMgZ3JhYiBjbHViIA0KcHJpbnQwMVJlcG9ydChkZiwgbW9kZWxuYW1lPSJmaWxlcy9jbHViMyIpDQpgYGANCg0KIVtdKGZpbGVzL2NsdWIzLnR4dCl7I2lkIC5jbGFzcyB3aWR0aD0xMDAlIGhlaWdodD0yMDBweH0NCg0KIyMjIENsdWIgNA0KYGBge3IgZXZhbD0gRn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1s0XV0gIyBncmFiIGNsdWIgDQpwcmludDAxUmVwb3J0KGRmLCBtb2RlbG5hbWU9ImZpbGVzL2NsdWI0IikNCmBgYA0KDQohW10oZmlsZXMvY2x1YjQudHh0KXsjaWQgLmNsYXNzIHdpZHRoPTEwMCUgaGVpZ2h0PTIwMHB4fQ0KDQojIyMgQ2x1YiA1DQpgYGB7ciBldmFsPSBGfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzVdXSAjIGdyYWIgY2x1YiANCnByaW50MDFSZXBvcnQoZGYsIG1vZGVsbmFtZT0iZmlsZXMvY2x1YjUiKQ0KYGBgDQoNCiFbXShmaWxlcy9jbHViNS50eHQpeyNpZCAuY2xhc3Mgd2lkdGg9MTAwJSBoZWlnaHQ9MjAwcHh9DQoNCiMjIHstfQ0KDQotLS0tDQoNCiMgQ2x1YiBjaGFyYWN0ZXJpc3RpY3MNCg0KU29tZSBjbHViIGNoYXJhY3RlcmlzdGljcy4gV2Ugc2hvdyB0aGUgc2l6ZSBvZiB0aGUgbmV0d29yayAodGhlIG51bWJlciBvZiBhY3RvcnMpIGZvciBlYWNoIGNsdWIgYW5kIHRoZSBudW1iZXIgb2YgYWN0aXZlIG1lbWJlcnMgY3VycmVudGx5ICgxOC0xLTIwMjEpIG9uIFN0cmF2YSwgYnkgYWRkaW5nIHRvICp3d3cuc3RyYXZhLmNvbS9jbHVicy8uLi4qIHRoZSBvcmlnaW5hbCBjbHViIGlkLiANCg0KYGBge3J9DQojIGF0dHJpZXZlIGZyb20gdGhlIGNsdWJkYXRhIHRoZSBudW1iZXIgb2YgYWN0b3JzIGluIGVhY2ggbmV0d29yaw0KbmV0c2l6ZSA8LSBjKCANCiAgbGVuZ3RoKGNsdWJkYXRhX3JzaWVuYV9mcmVxW1sxXV0kbm9kZVNldHMkQWN0b3JzKSwgDQogIGxlbmd0aChjbHViZGF0YV9yc2llbmFfZnJlcVtbMl1dJG5vZGVTZXRzJEFjdG9ycyksIA0KICBsZW5ndGgoY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzNdXSRub2RlU2V0cyRBY3RvcnMpLCANCiAgbGVuZ3RoKGNsdWJkYXRhX3JzaWVuYV9mcmVxW1s0XV0kbm9kZVNldHMkQWN0b3JzKSwgDQogIGxlbmd0aChjbHViZGF0YV9yc2llbmFfZnJlcVtbNV1dJG5vZGVTZXRzJEFjdG9ycykpIA0KDQpjbHVic2l6ZSA8LSBjKDY2LCAxMjcsIDM3MywgMTUsIDE2OSkgIyBmaW5kIHRoZSBudW1iZXIgb2YgbWVtYmVycyBjdXJyZW50bHkgb24gU3RyYXZhDQoNCmRmIDwtIGRhdGEuZnJhbWUoIG5ldHNpemUgPSBuZXRzaXplLCBjbHVic2l6ZSA9IGNsdWJzaXplICkNCg0KcHJpbnQoZGYpDQpgYGANCg0KPGJyPg0KDQotLS0tDQoNCiMgRnJpZW5kc2hpcCBuZXR3b3JrDQoNCldlIGRlc2NyaWJlIHRoZSBmcmllbmRzaGlwIG5ldHdvcmsuIE5vdGUgdGhhdCB0aGUgZnJpZW5kc2hpcCBuZXR3b3JrIGlzIGEgY29uc3RhbnQgZHlhZGljIGNvdmFyaWF0ZS4NCg0KIyMgMS4gTm9kZS1sZXZlbCB7LnRhYnNldCAudGFic2V0LWZhZGV9DQoNCkxldCdzIGRlc2NyaWJlIHRoZSBmcmllbmRzaGlwLWluZGVncmVlcyBhbmQgLW91dGRlZ3JlZXMgb2YgdGhlIFN0cmF2YS11c2VycyBpbiBlYWNoIGNsdWIuIFdlIHRha2UgZnJvbSB0aGUgUlNpZW5hIG9iamVjdCB0aGUgZnJpZW5kc2hpcCBuZXR3b3JrIG9mIHRoZSBjbHViIGluIHF1ZXN0aW9uLCBhbmQgdHVybiBpdCBpbnRvIGFuICppZ3JhcGgqIG9iamVjdC4gVGhlbiB3ZSBmaW5kIHRoZSBpbi0gYW5kIG91dGRlZ3JlZSBvZiBlYWNoIG5vZGUuDQoNCiMjIyBDbHViIDENCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzFdXSAjIGdyYWIgY2x1YiANCmZuZXQgPC0gZGYkZHljQ292YXJzJGZyaWVuZHNoaXAgIyB0YWtlIGZyaWVuZHNoaXAgbmV0d29yaw0KDQojIG1ha2UgYSAnZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoZm5ldCwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBmaW5kIGluLSBhbmQgb3V0ZGVncmVlIGZvciBlYWNoIG5vZGUNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9Im91dCIpLCB4bGFiPSJvdXRkZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2Ygb3V0ZGVncmVlIFN0cmF2YSBmcmllbmRzaGlwIG5ldHdvcmsiKQ0KP2hpc3QNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9ImluIiksIHhsYWI9ImluZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIGluZGVncmVlIFN0cmF2YSBmcmllbmRzaGlwIG5ldHdvcmsiKQ0KYGBgDQoNCiMjIyBDbHViIDINCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzJdXSAjIGdyYWIgY2x1YiANCmZuZXQgPC0gZGYkZHljQ292YXJzJGZyaWVuZHNoaXAgIyB0YWtlIGZyaWVuZHNoaXAgbmV0d29yaw0KDQojIG1ha2UgYSAnZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoZm5ldCwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBmaW5kIGluLSBhbmQgb3V0ZGVncmVlIGZvciBlYWNoIG5vZGUNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9Im91dCIpLCB4bGFiPSJvdXRkZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2Ygb3V0ZGVncmVlIFN0cmF2YSBmcmllbmRzaGlwIG5ldHdvcmsiKQ0KaGlzdChpZ3JhcGg6OmRlZ3JlZShHMSwgbW9kZT0iaW4iKSwgeGxhYj0iaW5kZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2YgaW5kZWdyZWUgU3RyYXZhIGZyaWVuZHNoaXAgbmV0d29yayIpDQpgYGANCg0KIyMjIENsdWIgMw0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFfZnJlcVtbM11dICMgZ3JhYiBjbHViIA0KZm5ldCA8LSBkZiRkeWNDb3ZhcnMkZnJpZW5kc2hpcCAjIHRha2UgZnJpZW5kc2hpcCBuZXR3b3JrDQoNCiMgbWFrZSBhICdncmFwaCBvYmplY3QnDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChmbmV0LCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGZpbmQgaW4tIGFuZCBvdXRkZWdyZWUgZm9yIGVhY2ggbm9kZQ0KaGlzdChpZ3JhcGg6OmRlZ3JlZShHMSwgbW9kZT0ib3V0IiksIHhsYWI9Im91dGRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBvdXRkZWdyZWUgU3RyYXZhIGZyaWVuZHNoaXAgbmV0d29yayIpDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJpbiIpLCB4bGFiPSJpbmRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBpbmRlZ3JlZSBTdHJhdmEgZnJpZW5kc2hpcCBuZXR3b3JrIikNCmBgYA0KDQojIyMgQ2x1YiA0DQpgYGB7cn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1s0XV0gIyBncmFiIGNsdWIgDQpmbmV0IDwtIGRmJGR5Y0NvdmFycyRmcmllbmRzaGlwICMgdGFrZSBmcmllbmRzaGlwIG5ldHdvcmsNCg0KIyBtYWtlIGEgJ2dyYXBoIG9iamVjdCcNCkcxIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGZuZXQsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgZmluZCBpbi0gYW5kIG91dGRlZ3JlZSBmb3IgZWFjaCBub2RlDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJvdXQiKSwgeGxhYj0ib3V0ZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIG91dGRlZ3JlZSBTdHJhdmEgZnJpZW5kc2hpcCBuZXR3b3JrIikNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9ImluIiksIHhsYWI9ImluZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIGluZGVncmVlIFN0cmF2YSBmcmllbmRzaGlwIG5ldHdvcmsiKQ0KYGBgDQoNCiMjIyBDbHViIDUNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzVdXSAjIGdyYWIgY2x1YiANCmZuZXQgPC0gZGYkZHljQ292YXJzJGZyaWVuZHNoaXAgIyB0YWtlIGZyaWVuZHNoaXAgbmV0d29yaw0KDQojIG1ha2UgYSAnZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoZm5ldCwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBmaW5kIGluLSBhbmQgb3V0ZGVncmVlIGZvciBlYWNoIG5vZGUNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9Im91dCIpLCB4bGFiPSJvdXRkZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2Ygb3V0ZGVncmVlIFN0cmF2YSBmcmllbmRzaGlwIG5ldHdvcmsiKQ0KaGlzdChpZ3JhcGg6OmRlZ3JlZShHMSwgbW9kZT0iaW4iKSwgeGxhYj0iaW5kZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2YgaW5kZWdyZWUgU3RyYXZhIGZyaWVuZHNoaXAgbmV0d29yayIpDQpgYGANCg0KIyMgey19DQoNCkluIGdlbmVyYWwsIHdlIHNlZSB0aGF0IHRoZSBpbi0gYW5kIG91dGRlZ3JlZSBkaXN0cmlidXRpb24gaXMgcmlnaHQtc2tld2VkLCBzdWdnZXN0aW5nIHRoYXQgbW9zdCBTdHJhdmEtdXNlcnMgYmVmcmllbmQgYW5kIGFyZSBiZWZyaWVuZGVkIGJ5IHJlbGF0aXZlbHkgZmV3IGNsdWItbWVtYmVycywgd2hpbGUgZmV3ZXIgdXNlcnMgYmVmcmllbmQgYW5kIGFyZSBiZWZyaWVuZGVkIGJ5IG1hbnkgY2x1Yi1tZW1iZXJzLg0KDQo8YnI+DQoNCiMjIDIuIER5YWQtbGV2ZWwgey50YWJzZXQgLnRhYnNldC1mYWRlfQ0KDQpMZXQncyBpbnZlc3RpZ2F0ZSB0byB3aGF0IGV4dGVudCBmcmllbmRzaGlwLXJlbGF0aW9uc2hpcHMgKGR5YWRzKSBhcmUgcmVjaXByb2NhdGVkIG9yIG11dHVhbC4gVGhlcmUgYXJlIHRocmVlIHR5cGVzIG9mIGR5YWQ6IG11dHVhbCwgYXNzeW1ldHJpYywgYW5kIG5vbi1leGlzdGVudC4gV2Ugd2lsbCBjbGFzc2lmeSBkeWFkcyB3aXRoIHRoZSBkeWFkLWNlbnN1cyBmdW5jdGlvbiwgYW5kIHdlIHdpbGwgaW52ZXN0aWdhdGUgaWYgd2Ugb2JzZXJ2ZSBtb3JlIG11dHVhbCBkeWFkcyB0aGFuIHdlIHdvdWxkIGV4cGVjdCBiYXNlZCBvbiBjaGFuY2UuDQoNCiMjIyBDbHViIDENCmBgYHtyIH0NCiMgbWFrZSBpZ3JhcGggb2JqZWN0IGZvciB0aGUgY2x1Yg0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzFdXSRkeWNDb3ZhcnMkZnJpZW5kc2hpcCwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBjbGFzc2lmeSBkeWFkcw0KZHlhZGNvdW50IDwtIGlncmFwaDo6ZHlhZC5jZW5zdXMoRzEpDQoNCiMgYWRkIHRoZSB0b3RhbCBudW1iZXIgb2YgZHlhZHMgdG8gdGhlIGdyYXBoDQpkeWFkY291bnQkdG90YWwgPC0gKHZjb3VudChHMSkqKHZjb3VudChHMSktMSkpLzINCmR5YWRjb3VudA0KDQojIGNvbXBhcmUgdmFsdWVzIHdpdGggYSByYW5kb20gZ3JhcGggb2YgdGhlIHNhbWUgc2l6ZSB3aXRoIHRoZSBzYW1lIGRlbnNpdHkNCmRlbnMgPC0gaWdyYXBoOjpncmFwaC5kZW5zaXR5KEcxKQ0Kc2l6ZSA8LSBpZ3JhcGg6OnZjb3VudChHMSkNCnRyaWFsIDwtIDEwMDANCnJlY2lwIDwtIHJlcChOQSwgdHJpYWwpDQoNCmZvciAoIGkgaW4gMTp0cmlhbCApew0KICByYW5kb21fZ3JhcGggPC0gaWdyYXBoOjplcmRvcy5yZW55aS5nYW1lKG4gPSBzaXplLCBwLm9yLm0gPSBkZW5zLCBkaXJlY3RlZCA9IFRSVUUpDQogIHJlY2lwW2ldIDwtIGlncmFwaDo6ZHlhZC5jZW5zdXMocmFuZG9tX2dyYXBoKSRtdXQNCn0NCg0Ke2hpc3QocmVjaXAsIG1haW49Im51bWJlciBvZiBtdXR1YWwgZHlhZHMgaW4gcmFuZG9tIGdyYXBoIiwgeGxhYj0iIiwgKQ0KYWJsaW5lKHY9ZHlhZGNvdW50JG11dCwgY29sPSJyZWQiLCBsd2Q9Myl9DQpgYGANCg0KIyMjIENsdWIgMg0KYGBge3IgfQ0KIyBtYWtlIGlncmFwaCBvYmplY3QgZm9yIHRoZSBjbHViDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChjbHViZGF0YV9yc2llbmFfZnJlcVtbMl1dJGR5Y0NvdmFycyRmcmllbmRzaGlwLCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGNsYXNzaWZ5IGR5YWRzDQpkeWFkY291bnQgPC0gaWdyYXBoOjpkeWFkLmNlbnN1cyhHMSkNCg0KIyBhZGQgdGhlIHRvdGFsIG51bWJlciBvZiBkYXlkcyB0byB0aGUgZ3JhcGgNCmR5YWRjb3VudCR0b3RhbCA8LSAodmNvdW50KEcxKSoodmNvdW50KEcxKS0xKSkvMg0KZHlhZGNvdW50DQoNCiMgY29tcGFyZSB2YWx1ZXMgd2l0aCBhIHJhbmRvbSBncmFwaCBvZiB0aGUgc2FtZSBzaXplIHdpdGggdGhlIHNhbWUgZGVuc2l0eQ0KZGVucyA8LSBpZ3JhcGg6OmdyYXBoLmRlbnNpdHkoRzEpDQpzaXplIDwtIGlncmFwaDo6dmNvdW50KEcxKQ0KdHJpYWwgPC0gMTAwMA0KcmVjaXAgPC0gcmVwKE5BLCB0cmlhbCkNCg0KZm9yICggaSBpbiAxOnRyaWFsICl7DQogIHJhbmRvbV9ncmFwaCA8LSBpZ3JhcGg6OmVyZG9zLnJlbnlpLmdhbWUobiA9IHNpemUsIHAub3IubSA9IGRlbnMsIGRpcmVjdGVkID0gVFJVRSkNCiAgcmVjaXBbaV0gPC0gaWdyYXBoOjpkeWFkLmNlbnN1cyhyYW5kb21fZ3JhcGgpJG11dA0KfQ0KDQp7aGlzdChyZWNpcCwgbWFpbj0ibnVtYmVyIG9mIG11dHVhbCBkeWFkcyBpbiByYW5kb20gZ3JhcGgiLCB4bGFiPSIiLCApDQphYmxpbmUodj1keWFkY291bnQkbXV0LCBjb2w9InJlZCIsIGx3ZD0zKX0NCmBgYA0KDQojIyMgQ2x1YiAzDQpgYGB7cn0NCiMgbWFrZSBpZ3JhcGggb2JqZWN0IGZvciB0aGUgY2x1Yg0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzNdXSRkeWNDb3ZhcnMkZnJpZW5kc2hpcCwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBjbGFzc2lmeSBkeWFkcw0KZHlhZGNvdW50IDwtIGlncmFwaDo6ZHlhZC5jZW5zdXMoRzEpDQoNCiMgYWRkIHRoZSB0b3RhbCBudW1iZXIgb2YgZGF5ZHMgdG8gdGhlIGdyYXBoDQpkeWFkY291bnQkdG90YWwgPC0gKHZjb3VudChHMSkqKHZjb3VudChHMSktMSkpLzINCmR5YWRjb3VudA0KDQojIGNvbXBhcmUgdmFsdWVzIHdpdGggYSByYW5kb20gZ3JhcGggb2YgdGhlIHNhbWUgc2l6ZSB3aXRoIHRoZSBzYW1lIGRlbnNpdHkNCmRlbnMgPC0gaWdyYXBoOjpncmFwaC5kZW5zaXR5KEcxKQ0Kc2l6ZSA8LSBpZ3JhcGg6OnZjb3VudChHMSkNCnRyaWFsIDwtIDEwMDANCnJlY2lwIDwtIHJlcChOQSwgdHJpYWwpDQoNCmZvciAoIGkgaW4gMTp0cmlhbCApew0KICByYW5kb21fZ3JhcGggPC0gaWdyYXBoOjplcmRvcy5yZW55aS5nYW1lKG4gPSBzaXplLCBwLm9yLm0gPSBkZW5zLCBkaXJlY3RlZCA9IFRSVUUpDQogIHJlY2lwW2ldIDwtIGlncmFwaDo6ZHlhZC5jZW5zdXMocmFuZG9tX2dyYXBoKSRtdXQNCn0NCg0Ke2hpc3QocmVjaXAsIG1haW49Im51bWJlciBvZiBtdXR1YWwgZHlhZHMgaW4gcmFuZG9tIGdyYXBoIiwgeGxhYj0iIiwgKQ0KYWJsaW5lKHY9ZHlhZGNvdW50JG11dCwgY29sPSJyZWQiLCBsd2Q9Myl9DQpgYGANCg0KIyMjIENsdWIgNA0KYGBge3IgfQ0KIyBtYWtlIGlncmFwaCBvYmplY3QgZm9yIHRoZSBjbHViDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChjbHViZGF0YV9yc2llbmFfZnJlcVtbNF1dJGR5Y0NvdmFycyRmcmllbmRzaGlwLCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGNsYXNzaWZ5IGR5YWRzDQpkeWFkY291bnQgPC0gaWdyYXBoOjpkeWFkLmNlbnN1cyhHMSkNCg0KIyBhZGQgdGhlIHRvdGFsIG51bWJlciBvZiBkYXlkcyB0byB0aGUgZ3JhcGgNCmR5YWRjb3VudCR0b3RhbCA8LSAodmNvdW50KEcxKSoodmNvdW50KEcxKS0xKSkvMg0KZHlhZGNvdW50DQoNCiMgY29tcGFyZSB2YWx1ZXMgd2l0aCBhIHJhbmRvbSBncmFwaCBvZiB0aGUgc2FtZSBzaXplIHdpdGggdGhlIHNhbWUgZGVuc2l0eQ0KZGVucyA8LSBpZ3JhcGg6OmdyYXBoLmRlbnNpdHkoRzEpDQpzaXplIDwtIGlncmFwaDo6dmNvdW50KEcxKQ0KdHJpYWwgPC0gMTAwMA0KcmVjaXAgPC0gcmVwKE5BLCB0cmlhbCkNCg0KZm9yICggaSBpbiAxOnRyaWFsICl7DQogIHJhbmRvbV9ncmFwaCA8LSBpZ3JhcGg6OmVyZG9zLnJlbnlpLmdhbWUobiA9IHNpemUsIHAub3IubSA9IGRlbnMsIGRpcmVjdGVkID0gVFJVRSkNCiAgcmVjaXBbaV0gPC0gaWdyYXBoOjpkeWFkLmNlbnN1cyhyYW5kb21fZ3JhcGgpJG11dA0KfQ0KDQp7aGlzdChyZWNpcCwgbWFpbj0ibnVtYmVyIG9mIG11dHVhbCBkeWFkcyBpbiByYW5kb20gZ3JhcGgiLCB4bGFiPSIiLCApDQphYmxpbmUodj1keWFkY291bnQkbXV0LCBjb2w9InJlZCIsIGx3ZD0zKX0NCmBgYA0KDQojIyMgQ2x1YiA1DQpgYGB7cn0NCiMgbWFrZSBpZ3JhcGggb2JqZWN0IGZvciB0aGUgY2x1Yg0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzVdXSRkeWNDb3ZhcnMkZnJpZW5kc2hpcCwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBjbGFzc2lmeSBkeWFkcw0KZHlhZGNvdW50IDwtIGlncmFwaDo6ZHlhZC5jZW5zdXMoRzEpDQoNCiMgYWRkIHRoZSB0b3RhbCBudW1iZXIgb2YgZGF5ZHMgdG8gdGhlIGdyYXBoDQpkeWFkY291bnQkdG90YWwgPC0gKHZjb3VudChHMSkqKHZjb3VudChHMSktMSkpLzINCmR5YWRjb3VudA0KDQojIGNvbXBhcmUgdmFsdWVzIHdpdGggYSByYW5kb20gZ3JhcGggb2YgdGhlIHNhbWUgc2l6ZSB3aXRoIHRoZSBzYW1lIGRlbnNpdHkNCmRlbnMgPC0gaWdyYXBoOjpncmFwaC5kZW5zaXR5KEcxKQ0Kc2l6ZSA8LSBpZ3JhcGg6OnZjb3VudChHMSkNCnRyaWFsIDwtIDEwMDANCnJlY2lwIDwtIHJlcChOQSwgdHJpYWwpDQoNCmZvciAoIGkgaW4gMTp0cmlhbCApew0KICByYW5kb21fZ3JhcGggPC0gaWdyYXBoOjplcmRvcy5yZW55aS5nYW1lKG4gPSBzaXplLCBwLm9yLm0gPSBkZW5zLCBkaXJlY3RlZCA9IFRSVUUpDQogIHJlY2lwW2ldIDwtIGlncmFwaDo6ZHlhZC5jZW5zdXMocmFuZG9tX2dyYXBoKSRtdXQNCn0NCg0Ke2hpc3QocmVjaXAsIG1haW49Im51bWJlciBvZiBtdXR1YWwgZHlhZHMgaW4gcmFuZG9tIGdyYXBoIiwgeGxhYj0iIiwgKQ0KYWJsaW5lKHY9ZHlhZGNvdW50JG11dCwgY29sPSJyZWQiLCBsd2Q9Myl9DQpgYGANCg0KIyMgey19DQoNCkFzIGV4cGVjdGVkLCBtdXR1YWwgZHlhZHMgYXJlIHdheSBtb3JlIHByb21pbmVudCB0aGFuIHdvdWxkIGJlIGV4cGVjdGVkIGJhc2VkIG9uIGNoYW5jZSwgd2hpY2ggaXMgaW5kaWNhdGl2ZSBvZiByZWNpcHJvY2l0eSBlZmZlY3RzIGluIFN0cmF2YS1mcmllbmRzaGlwcyBhbW9uZyB0aGUgbWVtYmVycyBvZiBjbHVicy4gICANCg0KPGJyPg0KDQojIyAzLiBUcmlhZC1sZXZlbCB7LnRhYnNldCAudGFic2V0LWZhZGV9DQoNClRoZXJlIGFyZSAxNiB0eXBlcyBvZiB0cmlhZHM7IHNlZSBAZGF2aXMxOTY3c3RydWN0dXJlLiBUaGV5IGNhbiBiZSBjbGFzc2lmaWVkIHdpdGggdGhlIHRyaWFkLWNlbnN1cyBmdW5jdGlvbi4gU2VlIFtoZXJlXShodHRwczovL2lncmFwaC5vcmcvci9kb2MvdHJpYWRfY2Vuc3VzLmh0bWwpIGZvciB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlIG11bHRpcGxlIHRyaWFkIGNsYXNzaWZpY2F0aW9ucyBhcmUgY291bnRlZC4NCg0KTGV0J3MgYWxzbyBjYWxjdWxhdGUgZm9yIGVhY2ggY2x1YiB0aGUgKGdsb2JhbCkgdHJhbnNpdGl2aXR5IGluZGV4LCB3aGljaCBpcyB0aGUgcmF0aW8gb2YgY29ubmVjdGVkIHRyaXBsZXRzICh0cmFuc2l0aXZlIHRyaWFkcykgYW5kIHBvdGVudGlhbGx5IGNvbm5lY3RlZCB0cmlwbGV0cyAoc2VlIFtoZXJlXShodHRwOi8vd3d3LnN0YXRzLm94LmFjLnVrL35zbmlqZGVycy9UcmFuc19UcmlhZHNfaGEucGRmKSkuIFRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VzIGlzIGlnbm9yZWQuIFdlIHdpbGwgdGhlbiBjYWxjdWxhdGUgdGhlIGdsb2JhbCB0cmFuc2l0aXZpdHkgaW5kZXggZm9yIHJhbmRvbSAodW5kaXJlY3RlZCkgZ3JhcGhzLg0KDQojIyMgQ2x1YiAxDQpgYGB7cn0NCiMgbWFrZSBpZ3JhcGggb2JqZWN0IGZvciB0aGUgY2x1Yg0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzFdXSRkeWNDb3ZhcnMkZnJpZW5kc2hpcCwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBjbGFzc2lmeSB0cmlhZHMNCnRyaWFkY291bnQgPC0gaWdyYXBoOjp0cmlhZC5jZW5zdXMoRzEpDQoNCiMgYW5kIHByaW50IHRoZSAxNiBjb25maWd1cmF0aW9ucw0KcHJpbnQodHJpYWRjb3VudCkNCg0KIyBnbG9iYWwgKG9yIHVuZGlyZWN0ZWQpIHRyYW5zaXRpdml0eSBpbmRleA0KaWdyYXBoOjp0cmFuc2l0aXZpdHkoRzEpDQoNCiMgY29tcGFyZSB2YWx1ZXMgd2l0aCBhIHJhbmRvbSBncmFwaCBvZiB0aGUgc2FtZSBzaXplIHdpdGggdGhlIHNhbWUgZGVuc2l0eQ0KZGVucyA8LSBpZ3JhcGg6OmdyYXBoLmRlbnNpdHkoRzEpDQpzaXplIDwtIGlncmFwaDo6dmNvdW50KEcxKQ0KdHJpYWwgPC0gMTAwMA0KcmVjaXAgPC0gcmVwKE5BLCB0cmlhbCkNCg0KZm9yICggaSBpbiAxOnRyaWFsICl7DQogIHJhbmRvbV9ncmFwaCA8LSBpZ3JhcGg6OmVyZG9zLnJlbnlpLmdhbWUobiA9IHNpemUsIHAub3IubSA9IGRlbnMsIGRpcmVjdGVkID0gVFJVRSkNCiAgcmVjaXBbaV0gPC0gdHJhbnNpdGl2aXR5KHJhbmRvbV9ncmFwaCkNCn0NCg0Ke2hpc3QocmVjaXAsIG1haW49Imdsb2JhbCB0cmFuc2l0aXZpdHkgaW5kZXggaW4gcmFuZG9tIGdyYXBoIiwgeGxhYj0iIiApDQphYmxpbmUodj10cmFuc2l0aXZpdHkoRzEpLCBjb2w9InJlZCIsIGx3ZD0zKX0NCg0KYGBgDQoNCiMjIyBDbHViIDINCmBgYHtyIH0NCiMgbWFrZSBpZ3JhcGggb2JqZWN0IGZvciB0aGUgY2x1Yg0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzJdXSRkeWNDb3ZhcnMkZnJpZW5kc2hpcCwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBjbGFzc2lmeSB0cmlhZHMNCnRyaWFkY291bnQgPC0gaWdyYXBoOjp0cmlhZC5jZW5zdXMoRzEpDQoNCiMgYW5kIHByaW50IHRoZSAxNiBjb25maWd1cmF0aW9ucw0KcHJpbnQodHJpYWRjb3VudCkNCg0KIyBnbG9iYWwgKG9yIHVuZGlyZWN0ZWQpIHRyYW5zaXRpdml0eSBpbmRleA0KaWdyYXBoOjp0cmFuc2l0aXZpdHkoRzEpDQoNCiMgY29tcGFyZSB2YWx1ZXMgd2l0aCBhIHJhbmRvbSBncmFwaCBvZiB0aGUgc2FtZSBzaXplIHdpdGggdGhlIHNhbWUgZGVuc2l0eQ0KZGVucyA8LSBpZ3JhcGg6OmdyYXBoLmRlbnNpdHkoRzEpDQpzaXplIDwtIGlncmFwaDo6dmNvdW50KEcxKQ0KdHJpYWwgPC0gMTAwMA0KcmVjaXAgPC0gcmVwKE5BLCB0cmlhbCkNCg0KZm9yICggaSBpbiAxOnRyaWFsICl7DQogIHJhbmRvbV9ncmFwaCA8LSBpZ3JhcGg6OmVyZG9zLnJlbnlpLmdhbWUobiA9IHNpemUsIHAub3IubSA9IGRlbnMsIGRpcmVjdGVkID0gVFJVRSkNCiAgcmVjaXBbaV0gPC0gdHJhbnNpdGl2aXR5KHJhbmRvbV9ncmFwaCkNCn0NCg0Ke2hpc3QocmVjaXAsIG1haW49Imdsb2JhbCB0cmFuc2l0aXZpdHkgaW5kZXggaW4gcmFuZG9tIGdyYXBoIiwgeGxhYj0iIiApDQphYmxpbmUodj10cmFuc2l0aXZpdHkoRzEpLCBjb2w9InJlZCIsIGx3ZD0zKX0NCg0KYGBgDQoNCiMjIyBDbHViIDMNCmBgYHtyfQ0KIyBtYWtlIGlncmFwaCBvYmplY3QgZm9yIHRoZSBjbHViDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChjbHViZGF0YV9yc2llbmFfZnJlcVtbM11dJGR5Y0NvdmFycyRmcmllbmRzaGlwLCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGNsYXNzaWZ5IHRyaWFkcw0KdHJpYWRjb3VudCA8LSBpZ3JhcGg6OnRyaWFkLmNlbnN1cyhHMSkNCg0KIyBhbmQgcHJpbnQgdGhlIDE2IGNvbmZpZ3VyYXRpb25zDQpwcmludCh0cmlhZGNvdW50KQ0KDQojIGdsb2JhbCAob3IgdW5kaXJlY3RlZCkgdHJhbnNpdGl2aXR5IGluZGV4DQppZ3JhcGg6OnRyYW5zaXRpdml0eShHMSkNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSB0cmFuc2l0aXZpdHkocmFuZG9tX2dyYXBoKQ0KfQ0KDQp7aGlzdChyZWNpcCwgbWFpbj0iZ2xvYmFsIHRyYW5zaXRpdml0eSBpbmRleCBpbiByYW5kb20gZ3JhcGgiLCB4bGFiPSIiICkNCmFibGluZSh2PXRyYW5zaXRpdml0eShHMSksIGNvbD0icmVkIiwgbHdkPTMpfQ0KDQpgYGANCg0KIyMjIENsdWIgNA0KYGBge3J9DQojIG1ha2UgaWdyYXBoIG9iamVjdCBmb3IgdGhlIGNsdWINCkcxIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGNsdWJkYXRhX3JzaWVuYV9mcmVxW1s0XV0kZHljQ292YXJzJGZyaWVuZHNoaXAsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgdHJpYWRzDQp0cmlhZGNvdW50IDwtIGlncmFwaDo6dHJpYWQuY2Vuc3VzKEcxKQ0KDQojIGFuZCBwcmludCB0aGUgMTYgY29uZmlndXJhdGlvbnMNCnByaW50KHRyaWFkY291bnQpDQoNCiMgZ2xvYmFsIChvciB1bmRpcmVjdGVkKSB0cmFuc2l0aXZpdHkgaW5kZXgNCmlncmFwaDo6dHJhbnNpdGl2aXR5KEcxKQ0KDQojIGNvbXBhcmUgdmFsdWVzIHdpdGggYSByYW5kb20gZ3JhcGggb2YgdGhlIHNhbWUgc2l6ZSB3aXRoIHRoZSBzYW1lIGRlbnNpdHkNCmRlbnMgPC0gaWdyYXBoOjpncmFwaC5kZW5zaXR5KEcxKQ0Kc2l6ZSA8LSBpZ3JhcGg6OnZjb3VudChHMSkNCnRyaWFsIDwtIDEwMDANCnJlY2lwIDwtIHJlcChOQSwgdHJpYWwpDQoNCmZvciAoIGkgaW4gMTp0cmlhbCApew0KICByYW5kb21fZ3JhcGggPC0gaWdyYXBoOjplcmRvcy5yZW55aS5nYW1lKG4gPSBzaXplLCBwLm9yLm0gPSBkZW5zLCBkaXJlY3RlZCA9IFRSVUUpDQogIHJlY2lwW2ldIDwtIHRyYW5zaXRpdml0eShyYW5kb21fZ3JhcGgpDQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJnbG9iYWwgdHJhbnNpdGl2aXR5IGluZGV4IGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIgKQ0KYWJsaW5lKHY9dHJhbnNpdGl2aXR5KEcxKSwgY29sPSJyZWQiLCBsd2Q9Myl9DQoNCmBgYA0KDQojIyMgQ2x1YiA1DQpgYGB7cn0NCiMgbWFrZSBpZ3JhcGggb2JqZWN0IGZvciB0aGUgY2x1Yg0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzVdXSRkeWNDb3ZhcnMkZnJpZW5kc2hpcCwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBjbGFzc2lmeSB0cmlhZHMNCnRyaWFkY291bnQgPC0gaWdyYXBoOjp0cmlhZC5jZW5zdXMoRzEpDQoNCiMgYW5kIHByaW50IHRoZSAxNiBjb25maWd1cmF0aW9ucw0KcHJpbnQodHJpYWRjb3VudCkNCg0KIyBnbG9iYWwgKG9yIHVuZGlyZWN0ZWQpIHRyYW5zaXRpdml0eSBpbmRleA0KaWdyYXBoOjp0cmFuc2l0aXZpdHkoRzEpDQoNCiMgY29tcGFyZSB2YWx1ZXMgd2l0aCBhIHJhbmRvbSBncmFwaCBvZiB0aGUgc2FtZSBzaXplIHdpdGggdGhlIHNhbWUgZGVuc2l0eQ0KZGVucyA8LSBpZ3JhcGg6OmdyYXBoLmRlbnNpdHkoRzEpDQpzaXplIDwtIGlncmFwaDo6dmNvdW50KEcxKQ0KdHJpYWwgPC0gMTAwMA0KcmVjaXAgPC0gcmVwKE5BLCB0cmlhbCkNCg0KZm9yICggaSBpbiAxOnRyaWFsICl7DQogIHJhbmRvbV9ncmFwaCA8LSBpZ3JhcGg6OmVyZG9zLnJlbnlpLmdhbWUobiA9IHNpemUsIHAub3IubSA9IGRlbnMsIGRpcmVjdGVkID0gVFJVRSkNCiAgcmVjaXBbaV0gPC0gdHJhbnNpdGl2aXR5KHJhbmRvbV9ncmFwaCkNCn0NCg0KaGlzdChyZWNpcCwgbWFpbj0iZ2xvYmFsIHRyYW5zaXRpdml0eSBpbmRleCBpbiByYW5kb20gZ3JhcGgiLCB4bGFiPSIiICkNCg0KYGBgDQoNCiMjIHstfQ0KQWxzbyB0cmFuc2l0aXZpdHkgaXMgbW9yZSBwcm9taW5lbnQgdGhhbiB3b3VsZCBiZSBleHBlY3RlZCBzb2xlbHkgYmFzZWQgb24gY2hhbmNlLiANCg0KDQotLS0tDQoNCg0KIyBLdWRvcyBuZXR3b3JrDQoNCk5vdyBsZXQncyBkZXNjcmliZSB0aGUgS3Vkb3MgbmV0d29yay4NCg0KIyMgMS4gTm9kZS1sZXZlbCB7LnRhYnNldCAudGFic2V0LWZhZGV9DQoNClN0YXJ0aW5nLCBhZ2Fpbiwgd2l0aCBpbmRlZ3JlZXMgYW5kIG91dGRlZ3JlZXM6IHdobyByZWNlaXZlcyBhbmQgZ2l2ZXMgS3Vkb3M/IFdlIHRha2UgZnJvbSB0aGUgUlNpZW5hIG9iamVjdCB0aGUgS3Vkb3MgbmV0d29yayBmb3IgZWFjaCBjbHViLCBzdWJzZXQgdGhlIGZpcnN0IHdhdmUsIGFuZCB0dXJuIGl0IGludG8gYW4gKmlncmFwaCogb2JqZWN0LiANCg0KIyMjIENsdWIgMQ0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFfZnJlcVtbMV1dICMgZ3JhYiBjbHViIA0Ka25ldCA8LSBkZiRkZXB2YXJzJGt1ZG9uZXQgIyB0YWtlIEt1ZG8gbmV0d29yaw0Ka25ldDEgPC0ga25ldFssLDFdICMgdGFrZSB3YXZlIDEgb25seSBmb3Igbm93DQoNCiMgbWFrZSBhbiAnaWdyYXBoIG9iamVjdCcNCkcxIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGtuZXQxLCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGZpbmQgaW4tIGFuZCBvdXRkZWdyZWUgZm9yIGVhY2ggbm9kZQ0KaGlzdChpZ3JhcGg6OmRlZ3JlZShHMSwgbW9kZT0ib3V0IiksIHhsYWI9Im91dGRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBLdWRvIG91dGRlZ3JlZSIpDQoNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9ImluIiksIHhsYWI9ImluZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIEt1ZG8gaW5kZWdyZWUiKQ0KYGBgDQoNCiMjIyBDbHViIDINCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzJdXSAjIGdyYWIgY2x1YiB0DQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgZmluZCBpbi0gYW5kIG91dGRlZ3JlZSBmb3IgZWFjaCBub2RlDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJvdXQiKSwgeGxhYj0ib3V0ZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIEt1ZG8gb3V0ZGVncmVlIikNCg0KaGlzdChpZ3JhcGg6OmRlZ3JlZShHMSwgbW9kZT0iaW4iKSwgeGxhYj0iaW5kZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2YgS3VkbyBpbmRlZ3JlZSIpDQpgYGANCg0KIyMjIENsdWIgMw0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFfZnJlcVtbM11dICMgZ3JhYiBjbHViIA0Ka25ldCA8LSBkZiRkZXB2YXJzJGt1ZG9uZXQgIyB0YWtlIEt1ZG8gbmV0d29yaw0Ka25ldDEgPC0ga25ldFssLDFdICMgdGFrZSB3YXZlIDEgb25seSBmb3Igbm93DQoNCiMgbWFrZSBhbiAnaWdyYXBoIG9iamVjdCcNCkcxIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGtuZXQxLCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGZpbmQgaW4tIGFuZCBvdXRkZWdyZWUgZm9yIGVhY2ggbm9kZQ0KaGlzdChpZ3JhcGg6OmRlZ3JlZShHMSwgbW9kZT0ib3V0IiksIHhsYWI9Im91dGRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBLdWRvIG91dGRlZ3JlZSIpDQoNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9ImluIiksIHhsYWI9ImluZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIEt1ZG8gaW5kZWdyZWUiKQ0KYGBgDQoNCiMjIyBDbHViIDQNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzRdXSAjIGdyYWIgY2x1YiANCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIG1ha2UgYW4gJ2lncmFwaCBvYmplY3QnDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChrbmV0MSwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBmaW5kIGluLSBhbmQgb3V0ZGVncmVlIGZvciBlYWNoIG5vZGUNCmhpc3QoaWdyYXBoOjpkZWdyZWUoRzEsIG1vZGU9Im91dCIpLCB4bGFiPSJvdXRkZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2YgS3VkbyBvdXRkZWdyZWUiKQ0KDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJpbiIpLCB4bGFiPSJpbmRlZ3JlZSIsIG1haW49Imhpc3RvZ3JhbSBvZiBLdWRvIGluZGVncmVlIikNCmBgYA0KDQojIyMgQ2x1YiA1DQpgYGB7cn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1s1XV0gIyBncmFiIGNsdWIgDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgZmluZCBpbi0gYW5kIG91dGRlZ3JlZSBmb3IgZWFjaCBub2RlDQpoaXN0KGlncmFwaDo6ZGVncmVlKEcxLCBtb2RlPSJvdXQiKSwgeGxhYj0ib3V0ZGVncmVlIiwgbWFpbj0iaGlzdG9ncmFtIG9mIEt1ZG8gb3V0ZGVncmVlIikNCg0KaGlzdChpZ3JhcGg6OmRlZ3JlZShHMSwgbW9kZT0iaW4iKSwgeGxhYj0iaW5kZWdyZWUiLCBtYWluPSJoaXN0b2dyYW0gb2YgS3VkbyBpbmRlZ3JlZSIpDQpgYGANCg0KIyMgey19DQoNCldlIGNhbiBvYnNlcnZlIHRoZSBzYW1lIFBhcmV0by1saWtlLXBhdGVybjogc29tZSBnaXZlL3JlY2VpdmUgbW9zdCBvZiB0aGUgS3Vkb3MgZ2l2ZW4sIHdoaWxlIG1vc3QgZ2l2ZS9yZWNlaXZlIGZldy4NCg0KPGJyPg0KDQojIyAyLiBEeWFkLWxldmVsIHsudGFic2V0IC50YWJzZXQtZmFkZX0NCg0KQXQgdGhlIGR5YWQtbGV2ZWw6IGxldCdzIHNlZSB0byB3aGF0IGV4dGVudCBLdWRvcyB0ZW5kIHRvIGJlIHJlY2lwcm9jYXRlZCBiZXR3ZWVuIGFjdG9ycy4NCg0KIyMjIENsdWIgMQ0KYGBge3IgfQ0KIyBtYWtlIGlncmFwaCBvYmplY3QgZm9yIHRoZSBjbHViLCBhdCB3YXZlIDENCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1sxXV0gIyBncmFiIGNsdWIgDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgZHlhZHMNCmR5YWRjb3VudCA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKEcxKQ0KDQojIGFkZCB0aGUgdG90YWwgbnVtYmVyIG9mIGR5YWRzIHRvIHRoZSBncmFwaA0KZHlhZGNvdW50JHRvdGFsIDwtICh2Y291bnQoRzEpKih2Y291bnQoRzEpLTEpKS8yDQpkeWFkY291bnQNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKHJhbmRvbV9ncmFwaCkkbXV0DQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJudW1iZXIgb2YgcmVjaXByb2NhdGVkIEt1ZG9zIGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIsICkNCmFibGluZSh2PWR5YWRjb3VudCRtdXQsIGNvbD0icmVkIiwgbHdkPTMpfQ0KYGBgDQoNCiMjIyBDbHViIDINCmBgYHtyIH0NCiMgbWFrZSBpZ3JhcGggb2JqZWN0IGZvciB0aGUgY2x1YiwgYXQgd2F2ZSAxDQpkZiA8LSBjbHViZGF0YV9yc2llbmFfZnJlcVtbMl1dICMgZ3JhYiBjbHViIA0Ka25ldCA8LSBkZiRkZXB2YXJzJGt1ZG9uZXQgIyB0YWtlIEt1ZG8gbmV0d29yaw0Ka25ldDEgPC0ga25ldFssLDFdICMgdGFrZSB3YXZlIDEgb25seSBmb3Igbm93DQoNCiMgbWFrZSBhbiAnaWdyYXBoIG9iamVjdCcNCkcxIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGtuZXQxLCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGNsYXNzaWZ5IGR5YWRzDQpkeWFkY291bnQgPC0gaWdyYXBoOjpkeWFkLmNlbnN1cyhHMSkNCg0KIyBhZGQgdGhlIHRvdGFsIG51bWJlciBvZiBkeWFkcyB0byB0aGUgZ3JhcGgNCmR5YWRjb3VudCR0b3RhbCA8LSAodmNvdW50KEcxKSoodmNvdW50KEcxKS0xKSkvMg0KZHlhZGNvdW50DQoNCiMgY29tcGFyZSB2YWx1ZXMgd2l0aCBhIHJhbmRvbSBncmFwaCBvZiB0aGUgc2FtZSBzaXplIHdpdGggdGhlIHNhbWUgZGVuc2l0eQ0KZGVucyA8LSBpZ3JhcGg6OmdyYXBoLmRlbnNpdHkoRzEpDQpzaXplIDwtIGlncmFwaDo6dmNvdW50KEcxKQ0KdHJpYWwgPC0gMTAwMA0KcmVjaXAgPC0gcmVwKE5BLCB0cmlhbCkNCg0KZm9yICggaSBpbiAxOnRyaWFsICl7DQogIHJhbmRvbV9ncmFwaCA8LSBpZ3JhcGg6OmVyZG9zLnJlbnlpLmdhbWUobiA9IHNpemUsIHAub3IubSA9IGRlbnMsIGRpcmVjdGVkID0gVFJVRSkNCiAgcmVjaXBbaV0gPC0gaWdyYXBoOjpkeWFkLmNlbnN1cyhyYW5kb21fZ3JhcGgpJG11dA0KfQ0KDQp7aGlzdChyZWNpcCwgbWFpbj0ibnVtYmVyIG9mIHJlY2lwcm9jYXRlZCBLdWRvcyBpbiByYW5kb20gZ3JhcGgiLCB4bGFiPSIiLCApDQphYmxpbmUodj1keWFkY291bnQkbXV0LCBjb2w9InJlZCIsIGx3ZD0zKX0NCmBgYA0KDQojIyMgQ2x1YiAzDQpgYGB7ciB9DQojIG1ha2UgaWdyYXBoIG9iamVjdCBmb3IgdGhlIGNsdWIsIGF0IHdhdmUgMQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzNdXSAjIGdyYWIgY2x1YiANCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIG1ha2UgYW4gJ2lncmFwaCBvYmplY3QnDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChrbmV0MSwgbW9kZSA9ICJkaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLCBhZGQucm93bmFtZXMgPSBOQSkNCg0KIyBjbGFzc2lmeSBkeWFkcw0KZHlhZGNvdW50IDwtIGlncmFwaDo6ZHlhZC5jZW5zdXMoRzEpDQoNCiMgYWRkIHRoZSB0b3RhbCBudW1iZXIgb2YgZHlhZHMgdG8gdGhlIGdyYXBoDQpkeWFkY291bnQkdG90YWwgPC0gKHZjb3VudChHMSkqKHZjb3VudChHMSktMSkpLzINCmR5YWRjb3VudA0KDQojIGNvbXBhcmUgdmFsdWVzIHdpdGggYSByYW5kb20gZ3JhcGggb2YgdGhlIHNhbWUgc2l6ZSB3aXRoIHRoZSBzYW1lIGRlbnNpdHkNCmRlbnMgPC0gaWdyYXBoOjpncmFwaC5kZW5zaXR5KEcxKQ0Kc2l6ZSA8LSBpZ3JhcGg6OnZjb3VudChHMSkNCnRyaWFsIDwtIDEwMDANCnJlY2lwIDwtIHJlcChOQSwgdHJpYWwpDQoNCmZvciAoIGkgaW4gMTp0cmlhbCApew0KICByYW5kb21fZ3JhcGggPC0gaWdyYXBoOjplcmRvcy5yZW55aS5nYW1lKG4gPSBzaXplLCBwLm9yLm0gPSBkZW5zLCBkaXJlY3RlZCA9IFRSVUUpDQogIHJlY2lwW2ldIDwtIGlncmFwaDo6ZHlhZC5jZW5zdXMocmFuZG9tX2dyYXBoKSRtdXQNCn0NCg0Ke2hpc3QocmVjaXAsIG1haW49Im51bWJlciBvZiByZWNpcHJvY2F0ZWQgS3Vkb3MgaW4gcmFuZG9tIGdyYXBoIiwgeGxhYj0iIiwgKQ0KYWJsaW5lKHY9ZHlhZGNvdW50JG11dCwgY29sPSJyZWQiLCBsd2Q9Myl9DQpgYGANCg0KIyMjIENsdWIgNA0KYGBge3IgfQ0KIyBtYWtlIGlncmFwaCBvYmplY3QgZm9yIHRoZSBjbHViLCBhdCB3YXZlIDENCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1s0XV0gIyBncmFiIGNsdWIgDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgZHlhZHMNCmR5YWRjb3VudCA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKEcxKQ0KDQojIGFkZCB0aGUgdG90YWwgbnVtYmVyIG9mIGR5YWRzIHRvIHRoZSBncmFwaA0KZHlhZGNvdW50JHRvdGFsIDwtICh2Y291bnQoRzEpKih2Y291bnQoRzEpLTEpKS8yDQpkeWFkY291bnQNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKHJhbmRvbV9ncmFwaCkkbXV0DQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJudW1iZXIgb2YgcmVjaXByb2NhdGVkIEt1ZG9zIGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIsICkNCmFibGluZSh2PWR5YWRjb3VudCRtdXQsIGNvbD0icmVkIiwgbHdkPTMpfQ0KYGBgDQoNCiMjIyBDbHViIDUNCmBgYHtyfQ0KIyBtYWtlIGlncmFwaCBvYmplY3QgZm9yIHRoZSBjbHViLCBhdCB3YXZlIDENCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1s1XV0gIyBncmFiIGNsdWIgDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBtYWtlIGFuICdpZ3JhcGggb2JqZWN0Jw0KRzEgPC0gaWdyYXBoOjpncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoa25ldDEsIG1vZGUgPSAiZGlyZWN0ZWQiLCB3ZWlnaHRlZCA9IE5VTEwsIGRpYWcgPSBUUlVFLCBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgY2xhc3NpZnkgZHlhZHMNCmR5YWRjb3VudCA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKEcxKQ0KDQojIGFkZCB0aGUgdG90YWwgbnVtYmVyIG9mIGR5YWRzIHRvIHRoZSBncmFwaA0KZHlhZGNvdW50JHRvdGFsIDwtICh2Y291bnQoRzEpKih2Y291bnQoRzEpLTEpKS8yDQpkeWFkY291bnQNCg0KIyBjb21wYXJlIHZhbHVlcyB3aXRoIGEgcmFuZG9tIGdyYXBoIG9mIHRoZSBzYW1lIHNpemUgd2l0aCB0aGUgc2FtZSBkZW5zaXR5DQpkZW5zIDwtIGlncmFwaDo6Z3JhcGguZGVuc2l0eShHMSkNCnNpemUgPC0gaWdyYXBoOjp2Y291bnQoRzEpDQp0cmlhbCA8LSAxMDAwDQpyZWNpcCA8LSByZXAoTkEsIHRyaWFsKQ0KDQpmb3IgKCBpIGluIDE6dHJpYWwgKXsNCiAgcmFuZG9tX2dyYXBoIDwtIGlncmFwaDo6ZXJkb3MucmVueWkuZ2FtZShuID0gc2l6ZSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBUUlVFKQ0KICByZWNpcFtpXSA8LSBpZ3JhcGg6OmR5YWQuY2Vuc3VzKHJhbmRvbV9ncmFwaCkkbXV0DQp9DQoNCntoaXN0KHJlY2lwLCBtYWluPSJudW1iZXIgb2YgcmVjaXByb2NhdGVkIEt1ZG9zIGluIHJhbmRvbSBncmFwaCIsIHhsYWI9IiIsICkNCmFibGluZSh2PWR5YWRjb3VudCRtdXQsIGNvbD0icmVkIiwgbHdkPTMpfQ0KYGBgDQoNCiMjIHstfQ0KDQpDb25jbHVzaW9uOiBLdWRvcyB0ZW5kIHRvIGJlIHJlY2lwcm9jYXRlZCwgbGlrZSBmcmllbmRzaGlwcyENCg0KLS0tLQ0KDQoNCjxicj4NCg0KIyBHZW5kZXIgY29tcG9zaXRpb24gDQoNCiMjIHsudGFic2V0IC50YWJzZXQtZmFkZX0NCg0KTGV0J3MgaW52ZXN0aWdhdGUgdGhlIGdlbmRlciBjb21wb3NpdGlvbiBvZiB0aGUgY2x1Yi4NCldlIG11c3QgcmV0cmlldmUgZ2VuZGVyIGZyb20gdGhlIG9iamVjdCAobm90ZSB0aGF0IHdlIHVzZSB0aGUgY2x1YmRhdGEgb2JqZWN0LCBub3QgdGhlIFJTaWVuYSBvYmplY3QpLiBUaGVuIHdlIG1ha2UgYSBjYXRlZ29yaWNhbCBnZW5kZXIgdmFyaWFibGUgYW5kIHBsb3QgaXQuDQoNCiMjIyBDbHViIDENCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KbG9hZCgiY2x1YmRhdGEuUkRhdGEiKQ0KZGYgPC0gY2x1YmRhdGFbWzFdXSAjIGdyYWIgY2x1YiANCg0KIyByZXRyaWV2ZSBub2RlLWF0dHJpYnV0ZSBnZW5kZXIgZnJvbSBvYmplY3QNCm1hbGUgPC0gZGYkbWFsZQ0KZmVtYWxlIDwtIGRmJGZlbWFsZQ0Kb3RoZXIgPC0gZGYkb3RoZXINCg0KIyBhcyBmYWN0b3INCmdlbmRlciA8LSBOQQ0KZ2VuZGVyIDwtIGlmZWxzZShtYWxlID09IDEsICJNYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShmZW1hbGUgPT0gMSwgIkZlbWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2Uob3RoZXIgPT0gMSwgIk90aGVyIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShpcy5uYShnZW5kZXIpLCAiTWlzc2luZyIsIGdlbmRlcikgIyBtaXNzaW5nIGNhdGVnb3J5DQoNCiMgbWFrZSBkYXRhZnJhbWUNCmRmIDwtIGRhdGEuZnJhbWUoDQogIGdlbmRlciA9IGFzLmZhY3RvcihjKCJNYWxlIiwgIkZlbWFsZSIsICJPdGhlciIsICJNaXNzaW5nIikpLA0KICBuID0gYyhsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiTWFsZSJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIkZlbWFsZSJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk90aGVyIl0pLCBsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiTWlzc2luZyJdKSksDQogIGZyZXEgPSBjKHJvdW5kKChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik1hbGUiXSkvbGVuZ3RoKGdlbmRlcikgKjEwMCksIGRpZ2l0cz0xKSwgcm91bmQoKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iRmVtYWxlIl0pL2xlbmd0aChnZW5kZXIpICoxMDApLCBkaWdpdHM9MSksIHJvdW5kKChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik90aGVyIl0pL2xlbmd0aChnZW5kZXIpKjEwMCksIGRpZ2l0cz0xKSwgcm91bmQoKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iTWlzc2luZyJdKS9sZW5ndGgoZ2VuZGVyKSoxMDApLCBkaWdpdHM9MSkpDQopDQoNCiMgcGxvdA0KZGYgJT4lDQogIG11dGF0ZShnZW5kZXIgPSBmY3RfcmVvcmRlcihnZW5kZXIsIC1uKSkgJT4lDQogICAgICAgICAgIGdncGxvdChhZXMoZ2VuZGVyLCBuLCBmaWxsPWdlbmRlcikpICsgDQogICAgICAgICAgIGdlb21fYmFyKHN0YXQ9ImlkZW50aXR5Iiwgd2lkdGg9MC44KSArDQogICAgICAgICAgIGdlb21fdGV4dChhZXMobGFiZWw9cGFzdGUwKGZyZXEsIiUiKSksIHZqdXN0PTEuNSwgY29sb3VyPSJ3aGl0ZSIpDQoNCmBgYA0KDQojIyMgQ2x1YiAyDQpgYGB7ciBjbGFzcy5zb3VyY2UgPSAnZm9sZC1oaWRlJ30NCmRmIDwtIGNsdWJkYXRhW1syXV0gIyBncmFiIGNsdWIgDQoNCiMgcmV0cmlldmUgbm9kZS1hdHRyaWJ1dGUgZ2VuZGVyIGZyb20gb2JqZWN0DQptYWxlIDwtIGRmJG1hbGUNCmZlbWFsZSA8LSBkZiRmZW1hbGUNCm90aGVyIDwtIGRmJG90aGVyDQoNCiMgYXMgZmFjdG9yDQpnZW5kZXIgPC0gTkENCmdlbmRlciA8LSBpZmVsc2UobWFsZSA9PSAxLCAiTWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoZmVtYWxlID09IDEsICJGZW1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKG90aGVyID09IDEsICJPdGhlciIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoaXMubmEoZ2VuZGVyKSwgIk1pc3NpbmciLCBnZW5kZXIpICMgbWlzc2luZyBjYXRlZ29yeQ0KDQojIG1ha2UgZGF0YWZyYW1lDQpkZiA8LSBkYXRhLmZyYW1lKA0KICBnZW5kZXIgPSBhcy5mYWN0b3IoYygiTWFsZSIsICJGZW1hbGUiLCAiT3RoZXIiLCAiTWlzc2luZyIpKSwNCiAgbiA9IGMobGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk1hbGUiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJGZW1hbGUiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJPdGhlciJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk1pc3NpbmciXSkpLA0KICBmcmVxID0gYyhyb3VuZCgobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJNYWxlIl0pL2xlbmd0aChnZW5kZXIpICoxMDApLCBkaWdpdHM9MSksIHJvdW5kKChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09IkZlbWFsZSJdKS9sZW5ndGgoZ2VuZGVyKSAqMTAwKSwgZGlnaXRzPTEpLCByb3VuZCgobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJPdGhlciJdKS9sZW5ndGgoZ2VuZGVyKSoxMDApLCBkaWdpdHM9MSksIHJvdW5kKChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik1pc3NpbmciXSkvbGVuZ3RoKGdlbmRlcikqMTAwKSwgZGlnaXRzPTEpKQ0KKQ0KDQojIHBsb3QNCmRmICU+JQ0KICBtdXRhdGUoZ2VuZGVyID0gZmN0X3Jlb3JkZXIoZ2VuZGVyLCAtbikpICU+JQ0KICAgICAgICAgICBnZ3Bsb3QoYWVzKGdlbmRlciwgbiwgZmlsbD1nZW5kZXIpKSArIA0KICAgICAgICAgICBnZW9tX2JhcihzdGF0PSJpZGVudGl0eSIsIHdpZHRoPTAuOCkgKw0KICAgICAgICAgICBnZW9tX3RleHQoYWVzKGxhYmVsPXBhc3RlMChmcmVxLCIlIikpLCB2anVzdD0xLjUsIGNvbG91cj0id2hpdGUiKQ0KYGBgDQoNCiMjIyBDbHViIDMNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFbWzNdXSAjIGdyYWIgY2x1YiANCg0KIyByZXRyaWV2ZSBub2RlLWF0dHJpYnV0ZSBnZW5kZXIgZnJvbSBvYmplY3QNCm1hbGUgPC0gZGYkbWFsZQ0KZmVtYWxlIDwtIGRmJGZlbWFsZQ0Kb3RoZXIgPC0gZGYkb3RoZXINCg0KIyBhcyBmYWN0b3INCmdlbmRlciA8LSBOQQ0KZ2VuZGVyIDwtIGlmZWxzZShtYWxlID09IDEsICJNYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShmZW1hbGUgPT0gMSwgIkZlbWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2Uob3RoZXIgPT0gMSwgIk90aGVyIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShpcy5uYShnZW5kZXIpLCAiTWlzc2luZyIsIGdlbmRlcikgIyBtaXNzaW5nIGNhdGVnb3J5DQoNCiMgbWFrZSBkYXRhZnJhbWUNCmRmIDwtIGRhdGEuZnJhbWUoDQogIGdlbmRlciA9IGFzLmZhY3RvcihjKCJNYWxlIiwgIkZlbWFsZSIsICJPdGhlciIsICJNaXNzaW5nIikpLA0KICBuID0gYyhsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiTWFsZSJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIkZlbWFsZSJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk90aGVyIl0pLCBsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiTWlzc2luZyJdKSksDQogIGZyZXEgPSBjKHJvdW5kKChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik1hbGUiXSkvbGVuZ3RoKGdlbmRlcikgKjEwMCksIGRpZ2l0cz0xKSwgcm91bmQoKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iRmVtYWxlIl0pL2xlbmd0aChnZW5kZXIpICoxMDApLCBkaWdpdHM9MSksIHJvdW5kKChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik90aGVyIl0pL2xlbmd0aChnZW5kZXIpKjEwMCksIGRpZ2l0cz0xKSwgcm91bmQoKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iTWlzc2luZyJdKS9sZW5ndGgoZ2VuZGVyKSoxMDApLCBkaWdpdHM9MSkpDQopDQoNCiMgcGxvdA0KZGYgJT4lDQogIG11dGF0ZShnZW5kZXIgPSBmY3RfcmVvcmRlcihnZW5kZXIsIC1uKSkgJT4lDQogICAgICAgICAgIGdncGxvdChhZXMoZ2VuZGVyLCBuLCBmaWxsPWdlbmRlcikpICsgDQogICAgICAgICAgIGdlb21fYmFyKHN0YXQ9ImlkZW50aXR5Iiwgd2lkdGg9MC44KSArDQogICAgICAgICAgIGdlb21fdGV4dChhZXMobGFiZWw9cGFzdGUwKGZyZXEsIiUiKSksIHZqdXN0PTEuNSwgY29sb3VyPSJ3aGl0ZSIpDQpgYGANCg0KIyMjIENsdWIgNA0KYGBge3IgY2xhc3Muc291cmNlID0gJ2ZvbGQtaGlkZSd9DQpkZiA8LSBjbHViZGF0YVtbNF1dICMgZ3JhYiBjbHViIA0KDQojIHJldHJpZXZlIG5vZGUtYXR0cmlidXRlIGdlbmRlciBmcm9tIG9iamVjdA0KbWFsZSA8LSBkZiRtYWxlDQpmZW1hbGUgPC0gZGYkZmVtYWxlDQpvdGhlciA8LSBkZiRvdGhlcg0KDQojIGFzIGZhY3Rvcg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBtYWtlIGRhdGFmcmFtZQ0KZGYgPC0gZGF0YS5mcmFtZSgNCiAgZ2VuZGVyID0gYXMuZmFjdG9yKGMoIk1hbGUiLCAiRmVtYWxlIiwgIk90aGVyIiwgIk1pc3NpbmciKSksDQogIG4gPSBjKGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJNYWxlIl0pLCBsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiRmVtYWxlIl0pLCBsZW5ndGgoZ2VuZGVyW2dlbmRlciA9PSAiT3RoZXIiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJNaXNzaW5nIl0pKSwNCiAgZnJlcSA9IGMocm91bmQoKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iTWFsZSJdKS9sZW5ndGgoZ2VuZGVyKSAqMTAwKSwgZGlnaXRzPTEpLCByb3VuZCgobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJGZW1hbGUiXSkvbGVuZ3RoKGdlbmRlcikgKjEwMCksIGRpZ2l0cz0xKSwgcm91bmQoKGxlbmd0aChnZW5kZXJbZ2VuZGVyPT0iT3RoZXIiXSkvbGVuZ3RoKGdlbmRlcikqMTAwKSwgZGlnaXRzPTEpLCByb3VuZCgobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJNaXNzaW5nIl0pL2xlbmd0aChnZW5kZXIpKjEwMCksIGRpZ2l0cz0xKSkNCikNCg0KIyBwbG90DQpkZiAlPiUNCiAgbXV0YXRlKGdlbmRlciA9IGZjdF9yZW9yZGVyKGdlbmRlciwgLW4pKSAlPiUNCiAgICAgICAgICAgZ2dwbG90KGFlcyhnZW5kZXIsIG4sIGZpbGw9Z2VuZGVyKSkgKyANCiAgICAgICAgICAgZ2VvbV9iYXIoc3RhdD0iaWRlbnRpdHkiLCB3aWR0aD0wLjgpICsNCiAgICAgICAgICAgZ2VvbV90ZXh0KGFlcyhsYWJlbD1wYXN0ZTAoZnJlcSwiJSIpKSwgdmp1c3Q9MS41LCBjb2xvdXI9IndoaXRlIikNCmBgYA0KDQojIyMgQ2x1YiA1DQpgYGB7ciBjbGFzcy5zb3VyY2UgPSAnZm9sZC1oaWRlJ30NCmRmIDwtIGNsdWJkYXRhW1s1XV0gIyBncmFiIGNsdWIgDQoNCiMgcmV0cmlldmUgbm9kZS1hdHRyaWJ1dGUgZ2VuZGVyIGZyb20gb2JqZWN0DQptYWxlIDwtIGRmJG1hbGUNCmZlbWFsZSA8LSBkZiRmZW1hbGUNCm90aGVyIDwtIGRmJG90aGVyDQoNCiMgYXMgZmFjdG9yDQpnZW5kZXIgPC0gTkENCmdlbmRlciA8LSBpZmVsc2UobWFsZSA9PSAxLCAiTWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoZmVtYWxlID09IDEsICJGZW1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKG90aGVyID09IDEsICJPdGhlciIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoaXMubmEoZ2VuZGVyKSwgIk1pc3NpbmciLCBnZW5kZXIpICMgbWlzc2luZyBjYXRlZ29yeQ0KDQojIG1ha2UgZGF0YWZyYW1lDQpkZiA8LSBkYXRhLmZyYW1lKA0KICBnZW5kZXIgPSBhcy5mYWN0b3IoYygiTWFsZSIsICJGZW1hbGUiLCAiT3RoZXIiLCAiTWlzc2luZyIpKSwNCiAgbiA9IGMobGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk1hbGUiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJGZW1hbGUiXSksIGxlbmd0aChnZW5kZXJbZ2VuZGVyID09ICJPdGhlciJdKSwgbGVuZ3RoKGdlbmRlcltnZW5kZXIgPT0gIk1pc3NpbmciXSkpLA0KICBmcmVxID0gYyhyb3VuZCgobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJNYWxlIl0pL2xlbmd0aChnZW5kZXIpICoxMDApLCBkaWdpdHM9MSksIHJvdW5kKChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09IkZlbWFsZSJdKS9sZW5ndGgoZ2VuZGVyKSAqMTAwKSwgZGlnaXRzPTEpLCByb3VuZCgobGVuZ3RoKGdlbmRlcltnZW5kZXI9PSJPdGhlciJdKS9sZW5ndGgoZ2VuZGVyKSoxMDApLCBkaWdpdHM9MSksIHJvdW5kKChsZW5ndGgoZ2VuZGVyW2dlbmRlcj09Ik1pc3NpbmciXSkvbGVuZ3RoKGdlbmRlcikqMTAwKSwgZGlnaXRzPTEpKQ0KKQ0KDQojIHBsb3QNCmRmICU+JQ0KICBtdXRhdGUoZ2VuZGVyID0gZmN0X3Jlb3JkZXIoZ2VuZGVyLCAtbikpICU+JQ0KICAgICAgICAgICBnZ3Bsb3QoYWVzKGdlbmRlciwgbiwgZmlsbD1nZW5kZXIpKSArIA0KICAgICAgICAgICBnZW9tX2JhcihzdGF0PSJpZGVudGl0eSIsIHdpZHRoPTAuOCkgKw0KICAgICAgICAgICBnZW9tX3RleHQoYWVzKGxhYmVsPXBhc3RlMChmcmVxLCIlIikpLCB2anVzdD0xLjUsIGNvbG91cj0id2hpdGUiKQ0KYGBgDQoNCiMjIHstfQ0KDQpXZSBjYW4gc2VlIHRoYXQgaW4gYWxsIGNsdWJzIG1lbiBhcmUgdGhlIG1ham9yaXR5LiANCg0KLS0tLQ0KDQo8YnI+DQoNCiMgR2VuZGVyIHNlZ3JlZ2F0aW9uDQoNCkxldCdzIG5vdyBpbnZlc3RpZ2F0ZSBzZWdyZWdhdGlvbiBhbG9uZyBnZW5kZXIgaW4gdGhlIGZyaWVuZHNoaXAgbmV0d29yay4NCg0KDQojIyB7LnRhYnNldCAudGFic2V0LWZhZGV9DQoNCkxldCdzIHN0YXJ0IHdpdGggZGVzY3JpYmluZyB0aGUgdG90YWwgZGVuc2l0eSBhbmQgaW50cmEtIChzYW1lIGdlbmRlcikgYW5kIGludGVyZ3JvdXAgKGRpZmZlcmVudCBnZW5kZXIpIGRlbnNpdGllcy4gV2UgYWxzbyBjYWxjdWxhdGUgdGhlIENvbGVtYW4gSG9tb3BoaWx5IGluZGV4IGZvciBnZW5kZXIsIHdoaWNoIHJlZmxlY3RzIGdlbmRlciBzZWdyZWdhdGlvbiB3aGlsZSB0YWtpbmcgaW50byBhY2NvdW50IHRoZSByZWxhdGl2ZSBncm91cCBzaXplIG9mIGdlbmRlciBjYXRlZ29yaWVzLiBXZSBkZXNjcmliZSB0aGVzZSBzZWdyZWdhdGlvbiBtZWFzdXJlcyBmb3IgZnJpZW5kc2hpcCBhbmQga3Vkby1uZXR3b3JrcyByZXNwZWN0aXZlbHkuIA0KDQojIyMgQ2x1YiAxDQpgYGB7ciB9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFfZnJlcVtbMV1dICMgZ3JhYiBjbHViIA0KZGYyIDwtIGNsdWJkYXRhW1sxXV0NCg0KZm5ldCA8LSBkZiRkeWNDb3ZhcnMkZnJpZW5kc2hpcCAjIHRha2UgZnJpZW5kc2hpcCBuZXR3b3JrDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBmb3Igc29tZSByZWFzb24gY29uc3RydWN0aW5nIHRoZSBkeWFkLXNpbWlsYXJpdHkgbWF0cml4IGZvciBnZW5kZXIgd2l0aCB0aGUgcnNpZW5hIG9iamVjdCBkaWQgbm90IHdvcmssIHNvIHdlIHVzZSB0aGUgY2x1YmRhdGEuUkRhdGEuDQptYWxlIDwtIGRmMiRtYWxlDQpmZW1hbGUgPC0gZGYyJGZlbWFsZQ0Kb3RoZXIgPC0gZGYyJG90aGVyDQoNCmdlbmRlciA8LSBOQQ0KZ2VuZGVyIDwtIGlmZWxzZShtYWxlID09IDEsICJNYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShmZW1hbGUgPT0gMSwgIkZlbWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2Uob3RoZXIgPT0gMSwgIk90aGVyIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShpcy5uYShnZW5kZXIpLCAiTWlzc2luZyIsIGdlbmRlcikgIyBtaXNzaW5nIGNhdGVnb3J5DQoNCiMgY29uc3RydWN0IGR5YWQgc2ltaWxhcml0eSBtYXRyaXgNCmdlbmRlcl9tIDwtIGZob21vbWF0KGdlbmRlcikNCg0KDQojIG1ha2Ugb2JqZWN0IHRvIHN0b3JlIHJlc3VsdHMNCmRlc21hdCA8LSBtYXRyaXgoTkEsIG5yb3c9NCwgbmNvbD0yKQ0KDQojIHVzZSBmdW5jdGlvbnMNCmRlc21hdFsxLCAxXSA8LSBmZGVuc2l0eShmbmV0KQ0KZGVzbWF0WzIsIDFdIDwtIGZkZW5zaXR5aW50cmEoZm5ldCwgZ2VuZGVyX20pDQpkZXNtYXRbMywgMV0gPC0gZmRlbnNpdHlpbnRlcihmbmV0LCBnZW5kZXJfbSkNCmRlc21hdFs0LCAxXSA8LSBmc2NvbG5ldChmbmV0LCBnZW5kZXIpDQpkZXNtYXRbMSwgMl0gPC0gZmRlbnNpdHkoa25ldDEpDQpkZXNtYXRbMiwgMl0gPC0gZmRlbnNpdHlpbnRyYShrbmV0MSwgZ2VuZGVyX20pDQpkZXNtYXRbMywgMl0gPC0gZmRlbnNpdHlpbnRlcihrbmV0MSwgZ2VuZGVyX20pDQpkZXNtYXRbNCwgMl0gPC0gZnNjb2xuZXQoa25ldDEsIGdlbmRlcikNCg0KY29sbmFtZXMoZGVzbWF0KSA8LSBjKCJmcmllbmRzaGlwcyIsICJLdWRvcyIpDQpyb3duYW1lcyhkZXNtYXQpIDwtIGMoInRvdGFsIGRlbnNpdHkiLCAic2FtZSBnZW5kZXIgZGVuc2l0eSIsICJkaWZmZXJlbnQgZ2VuZGVyIGRlbnNpdHkiLCAiQ29sZW1hbidzIGhvbW9waGlseSBpbmRleCIpDQoNCg0KDQprbml0cjo6a2FibGUoZGVzbWF0LCBkaWdpdHM9MiwgImh0bWwiLCBjYXB0aW9uPSJHZW5kZXIgc2VncmVnYXRpb24gaW4gZnJpZW5kc2hpcCBhbmQga3VkbyBuZXR3b3JrIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCiMjIyBDbHViIDINCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzJdXSAjIGdyYWIgY2x1YiANCmRmMiA8LSBjbHViZGF0YVtbMl1dDQoNCmZuZXQgPC0gZGYkZHljQ292YXJzJGZyaWVuZHNoaXAgIyB0YWtlIGZyaWVuZHNoaXAgbmV0d29yaw0Ka25ldCA8LSBkZiRkZXB2YXJzJGt1ZG9uZXQgIyB0YWtlIEt1ZG8gbmV0d29yaw0Ka25ldDEgPC0ga25ldFssLDFdICMgdGFrZSB3YXZlIDEgb25seSBmb3Igbm93DQoNCiMgZm9yIHNvbWUgcmVhc29uIGNvbnN0cnVjdGluZyB0aGUgZHlhZC1zaW1pbGFyaXR5IG1hdHJpeCBmb3IgZ2VuZGVyIHdpdGggdGhlIHJzaWVuYSBvYmplY3QgZGlkIG5vdCB3b3JrLCBzbyB3ZSB1c2UgdGhlIGNsdWJkYXRhLlJEYXRhLg0KbWFsZSA8LSBkZjIkbWFsZQ0KZmVtYWxlIDwtIGRmMiRmZW1hbGUNCm90aGVyIDwtIGRmMiRvdGhlcg0KDQpnZW5kZXIgPC0gTkENCmdlbmRlciA8LSBpZmVsc2UobWFsZSA9PSAxLCAiTWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoZmVtYWxlID09IDEsICJGZW1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKG90aGVyID09IDEsICJPdGhlciIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoaXMubmEoZ2VuZGVyKSwgIk1pc3NpbmciLCBnZW5kZXIpICMgbWlzc2luZyBjYXRlZ29yeQ0KDQojIGNvbnN0cnVjdCBkeWFkIHNpbWlsYXJpdHkgbWF0cml4DQpnZW5kZXJfbSA8LSBmaG9tb21hdChnZW5kZXIpDQoNCg0KIyBtYWtlIG9iamVjdCB0byBzdG9yZSByZXN1bHRzDQpkZXNtYXQgPC0gbWF0cml4KE5BLCBucm93PTQsIG5jb2w9MikNCg0KIyB1c2UgZnVuY3Rpb25zDQpkZXNtYXRbMSwgMV0gPC0gZmRlbnNpdHkoZm5ldCkNCmRlc21hdFsyLCAxXSA8LSBmZGVuc2l0eWludHJhKGZuZXQsIGdlbmRlcl9tKQ0KZGVzbWF0WzMsIDFdIDwtIGZkZW5zaXR5aW50ZXIoZm5ldCwgZ2VuZGVyX20pDQpkZXNtYXRbNCwgMV0gPC0gZnNjb2xuZXQoZm5ldCwgZ2VuZGVyKQ0KZGVzbWF0WzEsIDJdIDwtIGZkZW5zaXR5KGtuZXQxKQ0KZGVzbWF0WzIsIDJdIDwtIGZkZW5zaXR5aW50cmEoa25ldDEsIGdlbmRlcl9tKQ0KZGVzbWF0WzMsIDJdIDwtIGZkZW5zaXR5aW50ZXIoa25ldDEsIGdlbmRlcl9tKQ0KZGVzbWF0WzQsIDJdIDwtIGZzY29sbmV0KGtuZXQxLCBnZW5kZXIpDQoNCmNvbG5hbWVzKGRlc21hdCkgPC0gYygiZnJpZW5kc2hpcHMiLCAiS3Vkb3MiKQ0Kcm93bmFtZXMoZGVzbWF0KSA8LSBjKCJ0b3RhbCBkZW5zaXR5IiwgInNhbWUgZ2VuZGVyIGRlbnNpdHkiLCAiZGlmZmVyZW50IGdlbmRlciBkZW5zaXR5IiwgIkNvbGVtYW4ncyBob21vcGhpbHkgaW5kZXgiKQ0KDQojIGFuZCBtYWtlIGEgbmljZSB0YWJsZQ0Ka25pdHI6OmthYmxlKGRlc21hdCwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iR2VuZGVyIHNlZ3JlZ2F0aW9uIGluIGZyaWVuZHNoaXAgYW5kIGt1ZG8gbmV0d29yayIpICU+JSANCiAga2FibGVFeHRyYTo6a2FibGVfc3R5bGluZyhib290c3RyYXBfb3B0aW9ucyA9IGMoInN0cmlwZWQiLCAiaG92ZXIiKSkNCmBgYA0KDQojIyMgQ2x1YiAzDQpgYGB7cn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1szXV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzNdXQ0KDQpmbmV0IDwtIGRmJGR5Y0NvdmFycyRmcmllbmRzaGlwICMgdGFrZSBmcmllbmRzaGlwIG5ldHdvcmsNCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBLdWRvIG5ldHdvcmsNCmtuZXQxIDwtIGtuZXRbLCwxXSAjIHRha2Ugd2F2ZSAxIG9ubHkgZm9yIG5vdw0KDQojIGZvciBzb21lIHJlYXNvbiBjb25zdHJ1Y3RpbmcgdGhlIGR5YWQtc2ltaWxhcml0eSBtYXRyaXggZm9yIGdlbmRlciB3aXRoIHRoZSByc2llbmEgb2JqZWN0IGRpZCBub3Qgd29yaywgc28gd2UgdXNlIHRoZSBjbHViZGF0YS5SRGF0YS4NCm1hbGUgPC0gZGYyJG1hbGUNCmZlbWFsZSA8LSBkZjIkZmVtYWxlDQpvdGhlciA8LSBkZjIkb3RoZXINCg0KZ2VuZGVyIDwtIE5BDQpnZW5kZXIgPC0gaWZlbHNlKG1hbGUgPT0gMSwgIk1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGZlbWFsZSA9PSAxLCAiRmVtYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShvdGhlciA9PSAxLCAiT3RoZXIiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKGlzLm5hKGdlbmRlciksICJNaXNzaW5nIiwgZ2VuZGVyKSAjIG1pc3NpbmcgY2F0ZWdvcnkNCg0KIyBjb25zdHJ1Y3QgZHlhZCBzaW1pbGFyaXR5IG1hdHJpeA0KZ2VuZGVyX20gPC0gZmhvbW9tYXQoZ2VuZGVyKQ0KDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KZGVzbWF0IDwtIG1hdHJpeChOQSwgbnJvdz00LCBuY29sPTIpDQoNCiMgdXNlIGZ1bmN0aW9ucw0KZGVzbWF0WzEsIDFdIDwtIGZkZW5zaXR5KGZuZXQpDQpkZXNtYXRbMiwgMV0gPC0gZmRlbnNpdHlpbnRyYShmbmV0LCBnZW5kZXJfbSkNCmRlc21hdFszLCAxXSA8LSBmZGVuc2l0eWludGVyKGZuZXQsIGdlbmRlcl9tKQ0KZGVzbWF0WzQsIDFdIDwtIGZzY29sbmV0KGZuZXQsIGdlbmRlcikNCmRlc21hdFsxLCAyXSA8LSBmZGVuc2l0eShrbmV0MSkNCmRlc21hdFsyLCAyXSA8LSBmZGVuc2l0eWludHJhKGtuZXQxLCBnZW5kZXJfbSkNCmRlc21hdFszLCAyXSA8LSBmZGVuc2l0eWludGVyKGtuZXQxLCBnZW5kZXJfbSkNCmRlc21hdFs0LCAyXSA8LSBmc2NvbG5ldChrbmV0MSwgZ2VuZGVyKQ0KDQpjb2xuYW1lcyhkZXNtYXQpIDwtIGMoImZyaWVuZHNoaXBzIiwgIkt1ZG9zIikNCnJvd25hbWVzKGRlc21hdCkgPC0gYygidG90YWwgZGVuc2l0eSIsICJzYW1lIGdlbmRlciBkZW5zaXR5IiwgImRpZmZlcmVudCBnZW5kZXIgZGVuc2l0eSIsICJDb2xlbWFuJ3MgaG9tb3BoaWx5IGluZGV4IikNCg0KIyBhbmQgbWFrZSBhIG5pY2UgdGFibGUNCmtuaXRyOjprYWJsZShkZXNtYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249IkdlbmRlciBzZWdyZWdhdGlvbiBpbiBmcmllbmRzaGlwIGFuZCBrdWRvIG5ldHdvcmsiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQpgYGANCg0KIyMjIENsdWIgNA0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFfZnJlcVtbNF1dICMgZ3JhYiBjbHViIA0KZGYyIDwtIGNsdWJkYXRhW1s0XV0NCg0KZm5ldCA8LSBkZiRkeWNDb3ZhcnMkZnJpZW5kc2hpcCAjIHRha2UgZnJpZW5kc2hpcCBuZXR3b3JrDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2UgS3VkbyBuZXR3b3JrDQprbmV0MSA8LSBrbmV0WywsMV0gIyB0YWtlIHdhdmUgMSBvbmx5IGZvciBub3cNCg0KIyBmb3Igc29tZSByZWFzb24gY29uc3RydWN0aW5nIHRoZSBkeWFkLXNpbWlsYXJpdHkgbWF0cml4IGZvciBnZW5kZXIgd2l0aCB0aGUgcnNpZW5hIG9iamVjdCBkaWQgbm90IHdvcmssIHNvIHdlIHVzZSB0aGUgY2x1YmRhdGEuUkRhdGEuDQptYWxlIDwtIGRmMiRtYWxlDQpmZW1hbGUgPC0gZGYyJGZlbWFsZQ0Kb3RoZXIgPC0gZGYyJG90aGVyDQoNCmdlbmRlciA8LSBOQQ0KZ2VuZGVyIDwtIGlmZWxzZShtYWxlID09IDEsICJNYWxlIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShmZW1hbGUgPT0gMSwgIkZlbWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2Uob3RoZXIgPT0gMSwgIk90aGVyIiwgZ2VuZGVyKQ0KZ2VuZGVyIDwtIGlmZWxzZShpcy5uYShnZW5kZXIpLCAiTWlzc2luZyIsIGdlbmRlcikgIyBtaXNzaW5nIGNhdGVnb3J5DQoNCiMgY29uc3RydWN0IGR5YWQgc2ltaWxhcml0eSBtYXRyaXgNCmdlbmRlcl9tIDwtIGZob21vbWF0KGdlbmRlcikNCg0KDQojIG1ha2Ugb2JqZWN0IHRvIHN0b3JlIHJlc3VsdHMNCmRlc21hdCA8LSBtYXRyaXgoTkEsIG5yb3c9NCwgbmNvbD0yKQ0KDQojIHVzZSBmdW5jdGlvbnMNCmRlc21hdFsxLCAxXSA8LSBmZGVuc2l0eShmbmV0KQ0KZGVzbWF0WzIsIDFdIDwtIGZkZW5zaXR5aW50cmEoZm5ldCwgZ2VuZGVyX20pDQpkZXNtYXRbMywgMV0gPC0gZmRlbnNpdHlpbnRlcihmbmV0LCBnZW5kZXJfbSkNCmRlc21hdFs0LCAxXSA8LSBmc2NvbG5ldChmbmV0LCBnZW5kZXIpDQpkZXNtYXRbMSwgMl0gPC0gZmRlbnNpdHkoa25ldDEpDQpkZXNtYXRbMiwgMl0gPC0gZmRlbnNpdHlpbnRyYShrbmV0MSwgZ2VuZGVyX20pDQpkZXNtYXRbMywgMl0gPC0gZmRlbnNpdHlpbnRlcihrbmV0MSwgZ2VuZGVyX20pDQpkZXNtYXRbNCwgMl0gPC0gZnNjb2xuZXQoa25ldDEsIGdlbmRlcikNCg0KY29sbmFtZXMoZGVzbWF0KSA8LSBjKCJmcmllbmRzaGlwcyIsICJLdWRvcyIpDQpyb3duYW1lcyhkZXNtYXQpIDwtIGMoInRvdGFsIGRlbnNpdHkiLCAic2FtZSBnZW5kZXIgZGVuc2l0eSIsICJkaWZmZXJlbnQgZ2VuZGVyIGRlbnNpdHkiLCAiQ29sZW1hbidzIGhvbW9waGlseSBpbmRleCIpDQoNCiMgYW5kIG1ha2UgYSBuaWNlIHRhYmxlDQprbml0cjo6a2FibGUoZGVzbWF0LCBkaWdpdHM9MiwgImh0bWwiLCBjYXB0aW9uPSJHZW5kZXIgc2VncmVnYXRpb24gaW4gZnJpZW5kc2hpcCBhbmQga3VkbyBuZXR3b3JrIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCiMjIyBDbHViIDUNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzVdXSAjIGdyYWIgY2x1YiANCmRmMiA8LSBjbHViZGF0YVtbNV1dDQoNCmZuZXQgPC0gZGYkZHljQ292YXJzJGZyaWVuZHNoaXAgIyB0YWtlIGZyaWVuZHNoaXAgbmV0d29yaw0Ka25ldCA8LSBkZiRkZXB2YXJzJGt1ZG9uZXQgIyB0YWtlIEt1ZG8gbmV0d29yaw0Ka25ldDEgPC0ga25ldFssLDFdICMgdGFrZSB3YXZlIDEgb25seSBmb3Igbm93DQoNCiMgZm9yIHNvbWUgcmVhc29uIGNvbnN0cnVjdGluZyB0aGUgZHlhZC1zaW1pbGFyaXR5IG1hdHJpeCBmb3IgZ2VuZGVyIHdpdGggdGhlIHJzaWVuYSBvYmplY3QgZGlkIG5vdCB3b3JrLCBzbyB3ZSB1c2UgdGhlIGNsdWJkYXRhLlJEYXRhLg0KbWFsZSA8LSBkZjIkbWFsZQ0KZmVtYWxlIDwtIGRmMiRmZW1hbGUNCm90aGVyIDwtIGRmMiRvdGhlcg0KDQpnZW5kZXIgPC0gTkENCmdlbmRlciA8LSBpZmVsc2UobWFsZSA9PSAxLCAiTWFsZSIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoZmVtYWxlID09IDEsICJGZW1hbGUiLCBnZW5kZXIpDQpnZW5kZXIgPC0gaWZlbHNlKG90aGVyID09IDEsICJPdGhlciIsIGdlbmRlcikNCmdlbmRlciA8LSBpZmVsc2UoaXMubmEoZ2VuZGVyKSwgIk1pc3NpbmciLCBnZW5kZXIpICMgbWlzc2luZyBjYXRlZ29yeQ0KDQojIGNvbnN0cnVjdCBkeWFkIHNpbWlsYXJpdHkgbWF0cml4DQpnZW5kZXJfbSA8LSBmaG9tb21hdChnZW5kZXIpDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KZGVzbWF0IDwtIG1hdHJpeChOQSwgbnJvdz00LCBuY29sPTIpDQoNCiMgdXNlIGZ1bmN0aW9ucw0KZGVzbWF0WzEsIDFdIDwtIGZkZW5zaXR5KGZuZXQpDQpkZXNtYXRbMiwgMV0gPC0gZmRlbnNpdHlpbnRyYShmbmV0LCBnZW5kZXJfbSkNCmRlc21hdFszLCAxXSA8LSBmZGVuc2l0eWludGVyKGZuZXQsIGdlbmRlcl9tKQ0KZGVzbWF0WzQsIDFdIDwtIGZzY29sbmV0KGZuZXQsIGdlbmRlcikNCmRlc21hdFsxLCAyXSA8LSBmZGVuc2l0eShrbmV0MSkNCmRlc21hdFsyLCAyXSA8LSBmZGVuc2l0eWludHJhKGtuZXQxLCBnZW5kZXJfbSkNCmRlc21hdFszLCAyXSA8LSBmZGVuc2l0eWludGVyKGtuZXQxLCBnZW5kZXJfbSkNCmRlc21hdFs0LCAyXSA8LSBmc2NvbG5ldChrbmV0MSwgZ2VuZGVyKQ0KDQpjb2xuYW1lcyhkZXNtYXQpIDwtIGMoImZyaWVuZHNoaXBzIiwgIkt1ZG9zIikNCnJvd25hbWVzKGRlc21hdCkgPC0gYygidG90YWwgZGVuc2l0eSIsICJzYW1lIGdlbmRlciBkZW5zaXR5IiwgImRpZmZlcmVudCBnZW5kZXIgZGVuc2l0eSIsICJDb2xlbWFuJ3MgaG9tb3BoaWx5IGluZGV4IikNCg0KIyBhbmQgbWFrZSBhIG5pY2UgdGFibGUNCmtuaXRyOjprYWJsZShkZXNtYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249IkdlbmRlciBzZWdyZWdhdGlvbiBpbiBmcmllbmRzaGlwIGFuZCBrdWRvIG5ldHdvcmsiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQpgYGANCg0KIyMgey19DQoNCkRlbnNpdHkgaW4gZnJpZW5kc2hpcHMgaXMgbm90IG11Y2ggaGlnaGVyIHdpdGhpbi1nZW5kZXIgdGhhbiBiZXR3ZWVuLWdlbmRlcnMsIHRob3VnaCB0aGlzIHJhdGlvIGRpZmZlcnMgcGVyIGNsdWIgKGFuZCBpbiBzb21lIGNsdWJzIGJldHdlZW4tZ2VuZGVyIGZyaWVuZHNoaXBzIGFyZSBtb3JlIGNvbW1vbikuIFRoZSBzYW1lIHBhdHRlcm4gaG9sZHMgZm9yIEt1ZG9zLXJlbGF0aW9uc2hpcHMuIA0KDQpDb2xlbWFuJ3MgSG9tb3BoaWx5IGluZGljZXMgdmFyeSBhY3Jvc3MgY2x1YnMuIEluIHNvbWUgY2x1YnMgdGhlcmUgaXMgc2xpZ2h0IGdlbmRlciBzZWdyZWdhdGlvbiAob3Igc2FtZS1nZW5kZXIgcHJlZmVyZW5jZSkgaW4gZnJpZW5kc2hpcCB0aWVzICh2YWx1ZXMgaGlnaGVyIHRoYW4gMCwgYnV0IHJhdGhlciBjbG9zZSB0byAwKSwgdGhvdWdoIGluIG90aGVycyBtZW1iZXJzIHRlbmQgdG8gYmVmcmllbmQgb3RoZXJzIG91dHNpZGUgdGhlaXIgb3duIGdlbmRlciAodmFsdWVzIGxvd2VyIHRoYW4gMCkuIE92ZXJhbGwsIHRlbmRlbmNpZXMgdG93YXJkcyBzZWdyZWdhdGlvbiAob3IgYXZvaWRhbmNlIHRoZXJlb2YpIGFyZSBwcm9ub3VuY2VkIHRvIGdyZWF0ZXIgZXh0ZW50IGluIHRoZSBLdWRvcy1yZWxhdGlvbnNoaXBzIHRoYW4gaW4gZnJpZW5kc2hpcHMuIA0KDQotLS0tDQoNCjxicj4NCg0KIyBCZWhhdmlvcg0KDQoNCldlIHBsb3R0ZWQgdGhlIGRldmVsb3BtZW50IG9mIHRoZSBtZWFuIG9mIHJ1bm5pbmcgYXR0cmlidXRlcyAoRmlndXJlIDUgb2YgdGhlIG1hbnVzY3JpcHQpLiBUaGUgc2NyaXB0IHRvIHJlcGxpY2F0ZSB0aGlzIHBsb3QgY2FuIGJlIGZvdW5kIFtoZXJlXShodHRwczovL3JvYmZyYW5rZW4uZ2l0aHViLmlvL1N0cmF2YS9kZXNmaWcuaHRtbCkuDQoNCg0KDQojIFdpdGhpbi1wZXJzb24gY2hhbmdlDQoNCiMjIHsudGFic2V0IC50YWJzZXQtZmFkZX0NCk5vdyBsZXQncyBhbHNvIGNoZWNrIGlmIGJlaGF2aW9yIHZhcmllZCBvdmVyIHRpbWUgd2l0aGluIGluZGl2aWR1YWxzLiBXaXRoaW4tcGVyc29uIHZhcmlhdGlvbiBpcyBhIHByZXJlcXVpc2l0ZSBmb3IgaWRlbnRpZnlpbmcgaW5mbHVlbmNlIGVmZmVjdHMgb24gYmVoYXZpb3IuIERvd24gYmVsb3cgd2UgZGVtb25zdHJhdGUgaG93IHJ1bm5pbmcgYWN0aXZpdHkgdmFyaWVzIHdpdGhpbiBpbmRpdmlkdWFscyBvdmVyIHRpbWUsIGluIGFic29sdXRlIHNjb3JlcyAoaS5lLiBpbiB0aW1lcyBwZXIgd2VlaykuDQoNCiMjIyBDbHViIDENCg0KYGBge3IgY2xhc3Muc291cmNlID0gJ2ZvbGQtaGlkZSd9DQpkZiA8LSBjbHViZGF0YVtbMV1dICMgZ3JhYiBjbHViDQoNCiMgY2hlY2sgd2l0aGluLXBlcnNvbiB2YXJpYWJpbGl0eSBvZiBydW5uaW5nIGZyZXF1ZW5jeQ0KIyBhYnNvbHV0ZSBzY29yZXMNCnNpemUgPC0gZGYkbmV0c2l6ZQ0KeSA8LSBhcnJheShjKGRmJGZyZXFfcnVuWywsXSkpDQp4IDwtIHJlcCgxOjEyLCBzaXplKQ0KZGYgPC0gZGF0YS5mcmFtZSh5LCB4KQ0KZGYgIDwtIGRmIFsob3JkZXIoZGYkeCkpLCBdDQpkZiRpZCA8LSByZXAoMTpzaXplLCAxMikNCg0KIyBnZXQgcmFuZG9tIHNhbXBsZSBvZiA5IHBlcnNvbnMNCnNhbXBsZSA8LSBzYW1wbGUoYygxOnNpemUpLCBzaXplPTksIHJlcGxhY2U9RikNCmRmX25ldyA8LSBkcGx5cjo6ZmlsdGVyKGRmLCBpZCAlaW4lIHNhbXBsZSkNCg0KIyBwbG90IGdyb3d0aCB0cmFqZWN0b3JpZXMgb2YgcmFuZG9tIHNhbXBsZSBvZiA5IG9mIGFsbCBjbHViIG1lbWJlcnMNCnAgPC0gZ2dwbG90KGRhdGEgPSBkZl9uZXcsIGFlcyh4LCB5KSkgKyBnZW9tX2xpbmUoKSsNCiAgZmFjZXRfd3JhcCh+aWQpDQpwICsgc2NhbGVfeF9jb250aW51b3VzKGJyZWFrcyA9IHNlcSgxLCAxMiwgMSkpICsgc2NhbGVfeV9jb250aW51b3VzKGJyZWFrcyA9IHNlcSgwLCA4LCAxKSkgKyANCiBnZ3RpdGxlKCJHcm93dGggdHJhamVjdG9yaWVzIGluIHJ1bm5pbmcgZnJlcXVlbmN5IG92ZXIgdGltZSBvZiBhIHJhbmRvbSBzYW1wbGUgb2YgOSBhY3RvcnMiKSArDQogIHhsYWIoIlRpbWUgaW4gbW9udGhzIikgKyB5bGFiKCJSdW5uaW5nIGZyZXF1ZW5jeSBpbiB0aW1lcyBwZXIgd2VlayIpDQoNCmBgYA0KDQojIyMgQ2x1YiAyDQoNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFbWzJdXSAjIGdyYWIgY2x1Yg0KDQojIGNoZWNrIHdpdGhpbi1wZXJzb24gdmFyaWFiaWxpdHkgb2YgcnVubmluZyBmcmVxdWVuY3kNCiMgYWJzb2x1dGUgc2NvcmVzDQpzaXplIDwtIGRmJG5ldHNpemUNCnkgPC0gYXJyYXkoYyhkZiRmcmVxX3J1blssLF0pKQ0KeCA8LSByZXAoMToxMiwgc2l6ZSkNCmRmIDwtIGRhdGEuZnJhbWUoeSwgeCkNCmRmICA8LSBkZiBbKG9yZGVyKGRmJHgpKSwgXQ0KZGYkaWQgPC0gcmVwKDE6c2l6ZSwgMTIpDQoNCiMgZ2V0IHJhbmRvbSBzYW1wbGUgb2YgOSBwZXJzb25zDQpzYW1wbGUgPC0gc2FtcGxlKGMoMTpzaXplKSwgc2l6ZT05LCByZXBsYWNlPUYpDQpkZl9uZXcgPC0gZHBseXI6OmZpbHRlcihkZiwgaWQgJWluJSBzYW1wbGUpDQoNCiMgcGxvdCBncm93dGggdHJhamVjdG9yaWVzIG9mIHJhbmRvbSBzYW1wbGUgb2YgOSBvZiBhbGwgY2x1YiBtZW1iZXJzDQpwIDwtIGdncGxvdChkYXRhID0gZGZfbmV3LCBhZXMoeCwgeSkpICsgZ2VvbV9saW5lKCkrDQogIGZhY2V0X3dyYXAofmlkKQ0KcCArIHNjYWxlX3hfY29udGludW91cyhicmVha3MgPSBzZXEoMSwgMTIsIDEpKSArIHNjYWxlX3lfY29udGludW91cyhicmVha3MgPSBzZXEoMCwgOCwgMSkpICsgDQogZ2d0aXRsZSgiR3Jvd3RoIHRyYWplY3RvcmllcyBpbiBydW5uaW5nIGZyZXF1ZW5jeSBvdmVyIHRpbWUgb2YgYSByYW5kb20gc2FtcGxlIG9mIDkgYWN0b3JzIikgKw0KICB4bGFiKCJUaW1lIGluIG1vbnRocyIpICsgeWxhYigiUnVubmluZyBmcmVxdWVuY3kgaW4gdGltZXMgcGVyIHdlZWsiKQ0KDQpgYGANCg0KDQojIyMgQ2x1YiAzDQoNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFbWzNdXSAjIGdyYWIgY2x1Yg0KDQojIGNoZWNrIHdpdGhpbi1wZXJzb24gdmFyaWFiaWxpdHkgb2YgcnVubmluZyBmcmVxdWVuY3kNCiMgYWJzb2x1dGUgc2NvcmVzDQpzaXplIDwtIGRmJG5ldHNpemUNCnkgPC0gYXJyYXkoYyhkZiRmcmVxX3J1blssLF0pKQ0KeCA8LSByZXAoMToxMiwgc2l6ZSkNCmRmIDwtIGRhdGEuZnJhbWUoeSwgeCkNCmRmICA8LSBkZiBbKG9yZGVyKGRmJHgpKSwgXQ0KZGYkaWQgPC0gcmVwKDE6c2l6ZSwgMTIpDQoNCiMgZ2V0IHJhbmRvbSBzYW1wbGUgb2YgOSBwZXJzb25zDQpzYW1wbGUgPC0gc2FtcGxlKGMoMTpzaXplKSwgc2l6ZT05LCByZXBsYWNlPUYpDQpkZl9uZXcgPC0gZHBseXI6OmZpbHRlcihkZiwgaWQgJWluJSBzYW1wbGUpDQoNCiMgcGxvdCBncm93dGggdHJhamVjdG9yaWVzIG9mIHJhbmRvbSBzYW1wbGUgb2YgOSBvZiBhbGwgY2x1YiBtZW1iZXJzDQpwIDwtIGdncGxvdChkYXRhID0gZGZfbmV3LCBhZXMoeCwgeSkpICsgZ2VvbV9saW5lKCkrDQogIGZhY2V0X3dyYXAofmlkKQ0KcCArIHNjYWxlX3hfY29udGludW91cyhicmVha3MgPSBzZXEoMSwgMTIsIDEpKSArIHNjYWxlX3lfY29udGludW91cyhicmVha3MgPSBzZXEoMCwgOCwgMSkpICsgDQogICBnZ3RpdGxlKCJHcm93dGggdHJhamVjdG9yaWVzIGluIHJ1bm5pbmcgZnJlcXVlbmN5IG92ZXIgdGltZSBvZiBhIHJhbmRvbSBzYW1wbGUgb2YgOSBhY3RvcnMiKSArDQogIHhsYWIoIlRpbWUgaW4gbW9udGhzIikgKyB5bGFiKCJSdW5uaW5nIGZyZXF1ZW5jeSBpbiB0aW1lcyBwZXIgd2VlayIpDQoNCmBgYA0KDQojIyMgQ2x1YiA0DQoNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFbWzRdXSAjIGdyYWIgY2x1Yg0KDQojIGNoZWNrIHdpdGhpbi1wZXJzb24gdmFyaWFiaWxpdHkgb2YgcnVubmluZyBmcmVxdWVuY3kNCiMgYWJzb2x1dGUgc2NvcmVzDQpzaXplIDwtIGRmJG5ldHNpemUNCnkgPC0gYXJyYXkoYyhkZiRmcmVxX3J1blssLF0pKQ0KeCA8LSByZXAoMToxMiwgc2l6ZSkNCmRmIDwtIGRhdGEuZnJhbWUoeSwgeCkNCmRmICA8LSBkZiBbKG9yZGVyKGRmJHgpKSwgXQ0KZGYkaWQgPC0gcmVwKDE6c2l6ZSwgMTIpDQoNCiMgZ2V0IHJhbmRvbSBzYW1wbGUgb2YgOSBwZXJzb25zDQpzYW1wbGUgPC0gc2FtcGxlKGMoMTpzaXplKSwgc2l6ZT05LCByZXBsYWNlPUYpDQpkZl9uZXcgPC0gZHBseXI6OmZpbHRlcihkZiwgaWQgJWluJSBzYW1wbGUpDQoNCiMgcGxvdCBncm93dGggdHJhamVjdG9yaWVzIG9mIHJhbmRvbSBzYW1wbGUgb2YgOSBvZiBhbGwgY2x1YiBtZW1iZXJzDQpwIDwtIGdncGxvdChkYXRhID0gZGZfbmV3LCBhZXMoeCwgeSkpICsgZ2VvbV9saW5lKCkrDQogIGZhY2V0X3dyYXAofmlkKQ0KcCArIHNjYWxlX3hfY29udGludW91cyhicmVha3MgPSBzZXEoMSwgMTIsIDEpKSArIHNjYWxlX3lfY29udGludW91cyhicmVha3MgPSBzZXEoMCwgOCwgMSkpICsgDQogZ2d0aXRsZSgiR3Jvd3RoIHRyYWplY3RvcmllcyBpbiBydW5uaW5nIGZyZXF1ZW5jeSBvdmVyIHRpbWUgb2YgYSByYW5kb20gc2FtcGxlIG9mIDkgYWN0b3JzIikgKw0KICB4bGFiKCJUaW1lIGluIG1vbnRocyIpICsgeWxhYigiUnVubmluZyBmcmVxdWVuY3kgaW4gdGltZXMgcGVyIHdlZWsiKQ0KDQpgYGANCg0KDQojIyMgQ2x1YiA1DQoNCmBgYHtyIGNsYXNzLnNvdXJjZSA9ICdmb2xkLWhpZGUnfQ0KZGYgPC0gY2x1YmRhdGFbWzVdXSAjIGdyYWIgY2x1Yg0KDQojIGNoZWNrIHdpdGhpbi1wZXJzb24gdmFyaWFiaWxpdHkgb2YgcnVubmluZyBmcmVxdWVuY3kNCiMgYWJzb2x1dGUgc2NvcmVzDQpzaXplIDwtIGRmJG5ldHNpemUNCnkgPC0gYXJyYXkoYyhkZiRmcmVxX3J1blssLF0pKQ0KeCA8LSByZXAoMToxMiwgc2l6ZSkNCmRmIDwtIGRhdGEuZnJhbWUoeSwgeCkNCmRmICA8LSBkZiBbKG9yZGVyKGRmJHgpKSwgXQ0KZGYkaWQgPC0gcmVwKDE6c2l6ZSwgMTIpDQoNCiMgZ2V0IHJhbmRvbSBzYW1wbGUgb2YgOSBwZXJzb25zDQpzYW1wbGUgPC0gc2FtcGxlKGMoMTpzaXplKSwgc2l6ZT05LCByZXBsYWNlPUYpDQpkZl9uZXcgPC0gZHBseXI6OmZpbHRlcihkZiwgaWQgJWluJSBzYW1wbGUpDQoNCiMgcGxvdCBncm93dGggdHJhamVjdG9yaWVzIG9mIHJhbmRvbSBzYW1wbGUgb2YgOSBvZiBhbGwgY2x1YiBtZW1iZXJzDQpwIDwtIGdncGxvdChkYXRhID0gZGZfbmV3LCBhZXMoeCwgeSkpICsgZ2VvbV9saW5lKCkrDQogIGZhY2V0X3dyYXAofmlkKQ0KcCArIHNjYWxlX3hfY29udGludW91cyhicmVha3MgPSBzZXEoMSwgMTIsIDEpKSArIHNjYWxlX3lfY29udGludW91cyhicmVha3MgPSBzZXEoMCwgOCwgMSkpICsgDQogIGdndGl0bGUoIkdyb3d0aCB0cmFqZWN0b3JpZXMgaW4gcnVubmluZyBmcmVxdWVuY3kgb3ZlciB0aW1lIG9mIGEgcmFuZG9tIHNhbXBsZSBvZiA5IGFjdG9ycyIpICsNCiAgeGxhYigiVGltZSBpbiBtb250aHMiKSArIHlsYWIoIlJ1bm5pbmcgZnJlcXVlbmN5IGluIHRpbWVzIHBlciB3ZWVrIikNCg0KYGBgDQoNCiMjIHstfQ0KDQpUaGVyZSBzZWVtcyB0byBiZSAnc3VmZmljaWVudCcgd2l0aGluLXBlcnNvbiB2YXJpYWJpbGl0eSBpbiBydW5uaW5nIGJlaGF2aW9yLCBhdCBsZWFzdCBpbiBmcmVxdWVuY3kuDQoNCi0tLS0NCg0KIyBDb3JyZWxhdGlvbiBiZXR3ZWVuIGZyZXF1ZW5jeSBhbmQgdm9sdW1lDQoNCkxldCdzIHBsb3QgdGhlIHJlbGF0aW9uIGJldHdlZW4gZnJlcXVlbmN5IGluIHRpbWVzIHBlciB3ZWVrIGFuZCB2b2x1bWUgaW4gaG91cnMgcGVyIHdlZWsuIFdlIGFsc28gY2FsY3VsYXRlIEtlbmRhbGwncyB0YXUtYiwgaS5lLiBhIG5vbi1wYXJhbWV0cmljIG1lYXN1cmUgb2YgY29ycmVsYXRpb24gb24gcmFua3MgKGNmLiBAa2hhbWlzKS4NCg0KIyMgey50YWJzZXQgLnRhYnNldC1mYWRlfQ0KDQojIyMgQ2x1YiAxDQoNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFbWzFdXSAjIGdyYWIgY2x1YiANCmRmIDwtIGRhdGEuZnJhbWUoeCA9IGFzLm1hdHJpeChkZiR0aW1lX3J1biksIHkgPSBhcy5tYXRyaXgoZGYkZnJlcV9ydW4pKQ0KDQpjIDwtIGNvci50ZXN0KGRmJHgsIGRmJHksIG1ldGhvZD0ia2VuZGFsbCIpDQoNCnBsb3QoZGYsIHR5cGU9ImIiLCANCiAgICAgbWFpbiA9ICJSZWxhdGlvbiBiZXR3ZWVuIHdlZWtseSBydW5uaW5nIHZhcmlhYmxlczogZnJlcXVlbmN5IGFuZCAoaGFsZikgaG91cnMiLA0KICAgICBzdWIgPSAiTm90ZTogcnVubmluZyBmcmVxdWVuY3kgY2FwcGVkIHdpdGggYSBtYXhpbXVtIG9mIDcsIGhvdXJzIHdpdGggYSBtYXhpbXVtIG9mIDciLA0KICAgICB4bGFiID0gIkhvdXJzIHBlciB3ZWVrIiwgeWxhYiA9ICJzZXNzaW9ucyBwZXIgd2VlayIsDQogICAgIGNvbD0iYmx1ZSIsIGx3ZD1jKDEscmVwKDYsMTAwMDApKSkgKyANCiAgdGV4dCh4ID0gMS43LCB5ID0gNSwgcm91bmQoYyRlc3RpbWF0ZSwgZGlnaXRzPTIpKSArDQogIHRleHQoeCA9IC43LCB5ID0gNSwgIktlbmRhbGwncyB0YXUtYiA9IikNCg0KYGBgDQoNCiMjIyBDbHViIDINCg0KYGBge3J9DQpkZiA8LSBjbHViZGF0YVtbMl1dICMgZ3JhYiBjbHViIA0KZGYgPC0gZGF0YS5mcmFtZSh4ID0gYXMubWF0cml4KGRmJHRpbWVfcnVuKSwgeSA9IGFzLm1hdHJpeChkZiRmcmVxX3J1bikpDQpjIDwtIGNvci50ZXN0KGRmJHgsZGYkeSxtZXRob2Q9ImtlbmRhbGwiKQ0KDQpwbG90KGRmLCB0eXBlPSJiIiwgDQogICAgIG1haW4gPSAiUmVsYXRpb24gYmV0d2VlbiB3ZWVrbHkgcnVubmluZyB2YXJpYWJsZXM6IGZyZXF1ZW5jeSBhbmQgaG91cnMiLA0KICAgICBzdWIgPSAiTm90ZTogcnVubmluZyBmcmVxdWVuY3kgY2FwcGVkIHdpdGggYSBtYXhpbXVtIG9mIDcsIGhvdXJzIHdpdGggYSBtYXhpbXVtIG9mIDciLA0KICAgICB4bGFiID0gImhvdXJzIHBlciB3ZWVrIiwgeWxhYiA9ICJzZXNzaW9ucyBwZXIgd2VlayIsDQogICAgIGNvbD0iYmx1ZSIsIGx3ZD1jKDEscmVwKDYsMTAwMDApKSkgKyANCiAgdGV4dCh4ID0gMS43LCB5ID0gNSwgcm91bmQoYyRlc3RpbWF0ZSwgZGlnaXRzPTIpKSArDQogIHRleHQoeCA9IC43LCB5ID0gNSwgIktlbmRhbGwncyB0YXUtYiA9IikNCmBgYA0KDQojIyMgQ2x1YiAzDQoNCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFbWzNdXSAjIGdyYWIgY2x1YiANCmRmIDwtIGRhdGEuZnJhbWUoeCA9IGFzLm1hdHJpeChkZiR0aW1lX3J1biksIHkgPSBhcy5tYXRyaXgoZGYkZnJlcV9ydW4pKQ0KYyA8LSBjb3IudGVzdChkZiR4LGRmJHksbWV0aG9kPSJrZW5kYWxsIikNCg0KcGxvdChkZiwgdHlwZT0iYiIsIA0KICAgICBtYWluID0gIlJlbGF0aW9uIGJldHdlZW4gd2Vla2x5IHJ1bm5pbmcgdmFyaWFibGVzOiBmcmVxdWVuY3kgYW5kIGhvdXJzIiwNCiAgICAgc3ViID0gIk5vdGU6IHJ1bm5pbmcgZnJlcXVlbmN5IGNhcHBlZCB3aXRoIGEgbWF4aW11bSBvZiA3LCBob3VycyB3aXRoIGEgbWF4aW11bSBvZiA3IiwNCiAgICAgeGxhYiA9ICJob3VycyBwZXIgd2VlayIsIHlsYWIgPSAic2Vzc2lvbnMgcGVyIHdlZWsiLA0KICAgICBjb2w9ImJsdWUiLCBsd2Q9YygxLHJlcCg2LDEwMDAwKSkpICsgDQogIHRleHQoeCA9IDEuNywgeSA9IDUsIHJvdW5kKGMkZXN0aW1hdGUsIGRpZ2l0cz0yKSkgKw0KICB0ZXh0KHggPSAuNywgeSA9IDUsICJLZW5kYWxsJ3MgdGF1LWIgPSIpDQpgYGANCg0KIyMjIENsdWIgNA0KDQpgYGB7cn0NCmRmIDwtIGNsdWJkYXRhW1s0XV0gIyBncmFiIGNsdWIgDQpkZiA8LSBkYXRhLmZyYW1lKHggPSBhcy5tYXRyaXgoZGYkdGltZV9ydW4pLCB5ID0gYXMubWF0cml4KGRmJGZyZXFfcnVuKSkNCmMgPC0gY29yLnRlc3QoZGYkeCxkZiR5LG1ldGhvZD0ia2VuZGFsbCIpDQoNCnBsb3QoZGYsIHR5cGU9ImIiLCANCiAgICAgbWFpbiA9ICJSZWxhdGlvbiBiZXR3ZWVuIHdlZWtseSBydW5uaW5nIHZhcmlhYmxlczogZnJlcXVlbmN5IGFuZCBob3VycyIsDQogICAgIHN1YiA9ICJOb3RlOiBydW5uaW5nIGZyZXF1ZW5jeSBjYXBwZWQgd2l0aCBhIG1heGltdW0gb2YgNywgaG91cnMgd2l0aCBhIG1heGltdW0gb2YgNyIsDQogICAgIHhsYWIgPSAiaG91cnMgcGVyIHdlZWsiLCB5bGFiID0gInNlc3Npb25zIHBlciB3ZWVrIiwNCiAgICAgY29sPSJibHVlIiwgbHdkPWMoMSxyZXAoNiwxMDAwMCkpKSArIA0KICB0ZXh0KHggPSAxLjUsIHkgPSA1LCByb3VuZChjJGVzdGltYXRlLCBkaWdpdHM9MikpICsNCiAgdGV4dCh4ID0gLjcsIHkgPSA1LCAiS2VuZGFsbCdzIHRhdS1iID0iKQ0KYGBgDQoNCiMjIyBDbHViIDUNCg0KYGBge3J9DQpkZiA8LSBjbHViZGF0YVtbNV1dICMgZ3JhYiBjbHViIA0KZGYgPC0gZGF0YS5mcmFtZSh4ID0gYXMubWF0cml4KGRmJHRpbWVfcnVuKSwgeSA9IGFzLm1hdHJpeChkZiRmcmVxX3J1bikpDQpjIDwtIGNvci50ZXN0KGRmJHgsZGYkeSxtZXRob2Q9ImtlbmRhbGwiKQ0KDQpwbG90KGRmLCB0eXBlPSJiIiwgDQogICAgIG1haW4gPSAiUmVsYXRpb24gYmV0d2VlbiB3ZWVrbHkgcnVubmluZyB2YXJpYWJsZXM6IGZyZXF1ZW5jeSBhbmQgaG91cnMiLA0KICAgICBzdWIgPSAiTm90ZTogcnVubmluZyBmcmVxdWVuY3kgY2FwcGVkIHdpdGggYSBtYXhpbXVtIG9mIDcsIGhvdXJzIHdpdGggYSBtYXhpbXVtIG9mIDciLA0KICAgICB4bGFiID0gImhvdXJzIHBlciB3ZWVrIiwgeWxhYiA9ICJzZXNzaW9ucyBwZXIgd2VlayIsDQogICAgIGNvbD0iYmx1ZSIsIGx3ZD1jKDEscmVwKDYsMTAwMDApKSkgKyANCiAgdGV4dCh4ID0gMiwgeSA9IDcsIHJvdW5kKGMkZXN0aW1hdGUsIGRpZ2l0cz0yKSkgKw0KICB0ZXh0KHggPSAuNywgeSA9IDcsICJLZW5kYWxsJ3MgdGF1LWIgPSIpDQpgYGANCg0KIyMgey19DQoNCkFsdGhvdWdoIGZyZXF1ZW5jeSBhbmQgZHVyYXRpb24gYXJlIHN0cm9uZ2x5IHJlbGF0ZWQsIHRoZXJlIGlzIHNvbWUgaW52YXJpYW5jZS4gDQoNCi0tLS0NCg0KPGJyPg0KDQoNCg0KIyBOZXR3b3JrIGF1dG9jb3JyZWxhdGlvbg0KDQojIyB7LnRhYnNldCAudGFic2V0LWZhZGV9DQpXZSBoYXZlIG5vdyBjb3ZlcmVkIHRoZSBzcG9ydCBhY3Rpdml0eSBsZXZlbHMgb2Ygb3VyIGNsdWItYXRobGV0ZXMsIGFuZCB0aGUgZXh0ZW50IHRvIHdoaWNoIGZyaWVuZHNoaXAtIGFuZCBrdWRvcy1hc3NvY2lhdGlvbnMgYXJlIHNlZ3JlZ2F0ZWQgYWxvbmcgZ2VuZGVyLiBMYXN0LCB3ZSB3aWxsIGV4cGxvcmUgaWYgZnJpZW5kc2hpcC0gYW5kIGt1ZG9zLXRpZXMgYXJlIGFsc28gc2VncmVnYXRlZCBhbG9uZyBhY3Rpdml0eSBsZXZlbHMuIE9yIGluIG90aGVyIHdvcmRzOiBkbyBwZW9wbGUgd2l0aCBzaW1pbGFyIGFjdGl2aXR5IGxldmVscyB0ZW5kIHRvIHNvY2lhbGl6ZSB0byBhIGdyZWF0ZXIgZXh0ZW50IC0gYnkgYmVmcmllbmRpbmcgb25lIGFub3RoZXIgYW5kIGJ5IGV4Y2hhbmdpbmcga3Vkb3MgLSBldmVuIHdoZW4gdGFraW5nIGludG8gYWNjb3VudCB0aGUgb3Bwb3J0dW5pdHkgc3RydWN0dXJlcyBmb3IgJ2ludGVyYWN0aW5nJyB3aXRoIChkaXMpc2ltaWxhciBvdGhlcnM/IA0KDQpXZSB1c2UgTW9yYW4ncyBJIHNwYXRpYWwgYXV0b2NvcnJlbGF0aW9uIG1lYXN1cmUgZm9yIHRoaXMsIHdoaWNoIGlzIHRoZSBjb3JyZWxhdGlvbiBiZXR3ZWVuIHRoZSBiZWhhdmlvcmFsIHNjb3JlIG9mIGFjdG9yICppKiBhbmQgdGhlICh0b3RhbC9tZWFuKSBiZWhhdmlvcmFsIHNjb3JlIG9mIGFsdGVycyAqaiogdG8gd2hvbSAqaSogaXMgY29ubmVjdGVkICoqZGlyZWN0bHkqKi4gV2UgYWxzbyBjYWxjdWxhdGVkIE1vcmFuJ3MgSSBieSBpbmNsdWRpbmcgdGhlIGJlaGF2aW9yYWwgc2NvcmVzIG9mIHRoZSBhY3RvcnMgKmgqIHRvIHdob20gKmkqIGlzIGluZGlyZWN0bHkgdGllZCwgYW5kIHVzZWQgdGhlIG5lZ2F0aXZlIGV4cG9uZW50aWFsIGZ1bmN0aW9uIGFzIGRlc2NyaWJlZCBieSBAY2hlbjIwMTMgYXMgYSBkaXN0YW5jZS1kZWNheSBmdW5jdGlvbiBmb3IgYXNzaWduaW5nIHdlaWdodHMuDQoNCiMjIyBDbHViIDENCmBgYHtyfQ0KZGYgPC0gY2x1YmRhdGFfcnNpZW5hX2ZyZXFbWzFdXSAjIGdyYWIgY2x1YiANCmRmMiA8LSBjbHViZGF0YVtbMV1dICMgZ3JhYiBjbHViIA0KDQpmbmV0IDwtIG5ldHdvcms6OmFzLm5ldHdvcmsoZGYkZHljQ292YXJzJGZyaWVuZHNoaXApICMgdGFrZSBmcmllbmRzaGlwIG5ldHdvcmsNCmtuZXQgPC0gZGYkZGVwdmFycyRrdWRvbmV0ICMgdGFrZSBrdWRvIG5ldHdvcmsNCmtuZXQxIDwtIG5ldHdvcms6OmFzLm5ldHdvcmsoa25ldFssLDFdKSAjIGxldCdzIHRha2Ugd2F2ZSAxDQoNCiMgZ2V0IGJlaGF2aW9yYWwgZGF0YQ0KZnJlcTEgPC0gZGYyJGZyZXFfcnVuWywsMV0gIyBydW5uaW5nIGZyZXF1ZW5jaWVzIHdhdmUgMQ0Kdm9sMSA8LSBkZjIkdGltZV9ydW5bLCwxXSAjIHJ1bm5pbmcgdm9sdW1lIHdhdmUgMQ0KDQojIHdlIGluY2x1ZGUgZ2VvZGlzdGFuY2VzOiBzaG9ydGVzdCBwYXRoIGxlbmd0aHMgZnJvbSBpIHRvIGoNCmZfZ2VvZGlzdGFuY2VzIDwtIHNuYTo6Z2VvZGlzdChmbmV0LCBjb3VudC5wYXRocz1UKQ0KZl9nZW9kaXN0YW5jZXMgPC0gZl9nZW9kaXN0YW5jZXMkZ2Rpc3QgDQprX2dlb2Rpc3RhbmNlcyA8LSBzbmE6Omdlb2Rpc3Qoa25ldDEsIGNvdW50LnBhdGhzPVQpDQprX2dlb2Rpc3RhbmNlcyA8LSBrX2dlb2Rpc3RhbmNlcyRnZGlzdCANCg0KIyBzZXQgdGhlIGRpc3RhbmNlICd0byB5b3Vyc2VsZicgdG8gJ0luZicNCmRpYWcoZl9nZW9kaXN0YW5jZXMpIDwtIEluZg0KZGlhZyhrX2dlb2Rpc3RhbmNlcykgPC0gSW5mDQoNCiMgZmlyc3QgY2FsY3VsYXRlIE1vcmFuJ3MgaSBmb3IgYWx0ZXJzIGF0IGRpc3RhbmNlIDEuDQpmX3dlaWdodHMxIDwtIGZfZ2VvZGlzdGFuY2VzID09IDENCmtfd2VpZ2h0czEgPC0ga19nZW9kaXN0YW5jZXMgPT0gMQ0KDQojIGFuZCB1c2UgdGhlIG5lZ2F0aXZlIGV4cG9uZW50aWFsIGRpc3RhbmNlLWRlY2F5IGZ1bmN0aW9uDQpmX3dlaWdodHMyIDwtIGV4cCgtZl9nZW9kaXN0YW5jZXMpDQprX3dlaWdodHMyIDwtIGV4cCgta19nZW9kaXN0YW5jZXMpDQoNCiMgY2FsY3VsYXRlIE1vcmFuJ3MgSQ0KIyBmb3IgZGlzdGFuY2UtMSBhbmQgd2l0aCBkaXN0YW5jZSBkZWNheSwgaW4gdGhlIGZyaWVuZHNoaXAgYW5kIGt1ZG8gbmV0d29yaywgZm9yIGZyZXF1ZW5jeSBhbmQgdm9sdW1lICByZXNwZWN0aXZlbHkNCiMgd2UgZG8gbm90IHJvdyBzdGFuZGFyZGl6ZSENCmZfZnJlcTEgPC0gZk1vcmFuLkkoZnJlcTEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBmX3dlaWdodHMxLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQpmX2ZyZXEyIDwtIGZNb3Jhbi5JKGZyZXExLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gZl93ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KZl92b2wxIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBmX3dlaWdodHMxLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQpmX3ZvbDIgPC0gZk1vcmFuLkkodm9sMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGZfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCg0Ka19mcmVxMSA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGtfd2VpZ2h0czEsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmtfZnJlcTIgPC0gZk1vcmFuLkkoZnJlcTEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBrX3dlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQprX3ZvbDEgPC0gZk1vcmFuLkkodm9sMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGtfd2VpZ2h0czEsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmtfdm9sMiA8LSBmTW9yYW4uSSh2b2wxLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0ga193ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KDQojIG1ha2Ugb2JqZWN0IHRvIHN0b3JlIHJlc3VsdHMNCiMgMS4gZnJlcXVlbmN5DQpmX21hdCA8LSBtYXRyaXgoTkEsIG5yb3c9NCwgbmNvbD00KQ0KZl9tYXRbMSwxXSA8LSBmX2ZyZXExJG9ic2VydmVkDQpmX21hdFsxLDJdIDwtIGZfZnJlcTEkZXhwZWN0ZWQNCmZfbWF0WzEsM10gPC0gZl9mcmVxMSRzZA0KZl9tYXRbMSw0XSA8LSBmX2ZyZXExJHAudmFsdWUNCmZfbWF0WzIsMV0gPC0gZl9mcmVxMiRvYnNlcnZlZA0KZl9tYXRbMiwyXSA8LSBmX2ZyZXEyJGV4cGVjdGVkDQpmX21hdFsyLDNdIDwtIGZfZnJlcTIkc2QNCmZfbWF0WzIsNF0gPC0gZl9mcmVxMiRwLnZhbHVlDQpmX21hdFszLDFdIDwtIGtfZnJlcTEkb2JzZXJ2ZWQNCmZfbWF0WzMsMl0gPC0ga19mcmVxMSRleHBlY3RlZA0KZl9tYXRbMywzXSA8LSBrX2ZyZXExJHNkDQpmX21hdFszLDRdIDwtIGtfZnJlcTEkcC52YWx1ZQ0KZl9tYXRbNCwxXSA8LSBrX2ZyZXEyJG9ic2VydmVkDQpmX21hdFs0LDJdIDwtIGtfZnJlcTIkZXhwZWN0ZWQNCmZfbWF0WzQsM10gPC0ga19mcmVxMiRzZA0KZl9tYXRbNCw0XSA8LSBrX2ZyZXEyJHAudmFsdWUNCg0KIyAyLiB2b2x1bWUNCnZfbWF0IDwtIG1hdHJpeChOQSwgbnJvdz00LCBuY29sPTQpDQp2X21hdFsxLDFdIDwtIGZfdm9sMSRvYnNlcnZlZA0Kdl9tYXRbMSwyXSA8LSBmX3ZvbDEkZXhwZWN0ZWQNCnZfbWF0WzEsM10gPC0gZl92b2wxJHNkDQp2X21hdFsxLDRdIDwtIGZfdm9sMSRwLnZhbHVlDQp2X21hdFsyLDFdIDwtIGZfdm9sMiRvYnNlcnZlZA0Kdl9tYXRbMiwyXSA8LSBmX3ZvbDIkZXhwZWN0ZWQNCnZfbWF0WzIsM10gPC0gZl92b2wyJHNkDQp2X21hdFsyLDRdIDwtIGZfdm9sMiRwLnZhbHVlDQp2X21hdFszLDFdIDwtIGtfdm9sMSRvYnNlcnZlZA0Kdl9tYXRbMywyXSA8LSBrX3ZvbDEkZXhwZWN0ZWQNCnZfbWF0WzMsM10gPC0ga192b2wxJHNkDQp2X21hdFszLDRdIDwtIGtfdm9sMSRwLnZhbHVlDQp2X21hdFs0LDFdIDwtIGtfdm9sMiRvYnNlcnZlZA0Kdl9tYXRbNCwyXSA8LSBrX3ZvbDIkZXhwZWN0ZWQNCnZfbWF0WzQsM10gPC0ga192b2wyJHNkDQp2X21hdFs0LDRdIDwtIGtfdm9sMiRwLnZhbHVlDQoNCmNvbG5hbWVzKGZfbWF0KSA8LSBjb2xuYW1lcyh2X21hdCkgPC0gYygib2JzZXJ2ZWQiLCAiZXhwZWN0ZWQiLCAic2QiLCAicC12YWx1ZSIpDQpyb3duYW1lcyhmX21hdCkgPC0gcm93bmFtZXModl9tYXQpIDwtIGMoImRpcmVjdCBmcmllbmRzIiwgImRpcmVjdCBhbmQgaW5kaXJlY3QgZnJpZW5kcyAoZGlzdGFuY2UtZGVjYXkpIiwgImRpcmVjdCBrdWRvcyB0aWVzIiwgImRpcmVjdCBhbmQgaW5kaXJlY3Qga3Vkb3MgdGllcyAoZGlzdGFuY2UtZGVjYXkpIikNCg0Ka25pdHI6OmthYmxlKGZfbWF0LCBkaWdpdHM9MiwgImh0bWwiLCBjYXB0aW9uPSJNb3JhbidzIEkgc3RhdGlzdGljIGZvciBzcGF0aWFsIGF1dG9jb3JyZWxhdGlvbiBiYXNlZCBvbiBnZW9kaXN0YW5jZXMgYW5kIHdlZWtseSBydW5uaW5nIGZyZXF1ZW5jeSIpICU+JSANCiAga2FibGVFeHRyYTo6a2FibGVfc3R5bGluZyhib290c3RyYXBfb3B0aW9ucyA9IGMoInN0cmlwZWQiLCAiaG92ZXIiKSkNCg0Ka25pdHI6OmthYmxlKHZfbWF0LCBkaWdpdHM9MiwgImh0bWwiLCBjYXB0aW9uPSJNb3JhbidzIEkgc3RhdGlzdGljIGZvciBzcGF0aWFsIGF1dG9jb3JyZWxhdGlvbiBiYXNlZCBvbiBnZW9kaXN0YW5jZXMgYW5kIG1vbnRobHkgcnVubmluZyB2b2x1bWUiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQpgYGANCg0KIyMjIENsdWIgMg0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFfZnJlcVtbMl1dICMgZ3JhYiBjbHViIA0KZGYyIDwtIGNsdWJkYXRhW1syXV0gIyBncmFiIGNsdWIgDQoNCmZuZXQgPC0gbmV0d29yazo6YXMubmV0d29yayhkZiRkeWNDb3ZhcnMkZnJpZW5kc2hpcCkgIyB0YWtlIGZyaWVuZHNoaXAgbmV0d29yaw0Ka25ldCA8LSBkZiRkZXB2YXJzJGt1ZG9uZXQgIyB0YWtlIGt1ZG8gbmV0d29yaw0Ka25ldDEgPC0gbmV0d29yazo6YXMubmV0d29yayhrbmV0WywsMV0pICMgbGV0J3MgdGFrZSB3YXZlIDENCg0KIyBnZXQgYmVoYXZpb3JhbCBkYXRhDQpmcmVxMSA8LSBkZjIkZnJlcV9ydW5bLCwxXSAjIHJ1bm5pbmcgZnJlcXVlbmNpZXMgd2F2ZSAxDQp2b2wxIDwtIGRmMiR0aW1lX3J1blssLDFdICMgcnVubmluZyB2b2x1bWUgd2F2ZSAxDQoNCiMgd2UgaW5jbHVkZSBnZW9kaXN0YW5jZXM6IHNob3J0ZXN0IHBhdGggbGVuZ3RocyBmcm9tIGkgdG8gag0KZl9nZW9kaXN0YW5jZXMgPC0gc25hOjpnZW9kaXN0KGZuZXQsIGNvdW50LnBhdGhzPVQpDQpmX2dlb2Rpc3RhbmNlcyA8LSBmX2dlb2Rpc3RhbmNlcyRnZGlzdCANCmtfZ2VvZGlzdGFuY2VzIDwtIHNuYTo6Z2VvZGlzdChrbmV0MSwgY291bnQucGF0aHM9VCkNCmtfZ2VvZGlzdGFuY2VzIDwtIGtfZ2VvZGlzdGFuY2VzJGdkaXN0IA0KDQojIHNldCB0aGUgZGlzdGFuY2UgJ3RvIHlvdXJzZWxmJyB0byAnSW5mJw0KZGlhZyhmX2dlb2Rpc3RhbmNlcykgPC0gSW5mDQpkaWFnKGtfZ2VvZGlzdGFuY2VzKSA8LSBJbmYNCg0KIyBmaXJzdCBjYWxjdWxhdGUgTW9yYW4ncyBpIGZvciBhbHRlcnMgYXQgZGlzdGFuY2UgMS4NCmZfd2VpZ2h0czEgPC0gZl9nZW9kaXN0YW5jZXMgPT0gMQ0Ka193ZWlnaHRzMSA8LSBrX2dlb2Rpc3RhbmNlcyA9PSAxDQoNCiMgYW5kIHVzZSB0aGUgbmVnYXRpdmUgZXhwb25lbnRpYWwgZGlzdGFuY2UtZGVjYXkgZnVuY3Rpb24NCmZfd2VpZ2h0czIgPC0gZXhwKC1mX2dlb2Rpc3RhbmNlcykNCmtfd2VpZ2h0czIgPC0gZXhwKC1rX2dlb2Rpc3RhbmNlcykNCg0KIyBjYWxjdWxhdGUgTW9yYW4ncyBJDQojIGZvciBkaXN0YW5jZS0xIGFuZCB3aXRoIGRpc3RhbmNlIGRlY2F5LCBpbiB0aGUgZnJpZW5kc2hpcCBhbmQga3VkbyBuZXR3b3JrLCBmb3IgZnJlcXVlbmN5IGFuZCB2b2x1bWUgIHJlc3BlY3RpdmVseQ0KIyB3ZSBkbyBub3Qgcm93IHN0YW5kYXJkaXplIQ0KZl9mcmVxMSA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGZfd2VpZ2h0czEsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmZfZnJlcTIgPC0gZk1vcmFuLkkoZnJlcTEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBmX3dlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQpmX3ZvbDEgPC0gZk1vcmFuLkkodm9sMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGZfd2VpZ2h0czEsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmZfdm9sMiA8LSBmTW9yYW4uSSh2b2wxLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gZl93ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KDQprX2ZyZXExIDwtIGZNb3Jhbi5JKGZyZXExLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0ga193ZWlnaHRzMSwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0Ka19mcmVxMiA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGtfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmtfdm9sMSA8LSBmTW9yYW4uSSh2b2wxLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0ga193ZWlnaHRzMSwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0Ka192b2wyIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBrX3dlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KIyAxLiBmcmVxdWVuY3kNCmZfbWF0IDwtIG1hdHJpeChOQSwgbnJvdz00LCBuY29sPTQpDQpmX21hdFsxLDFdIDwtIGZfZnJlcTEkb2JzZXJ2ZWQNCmZfbWF0WzEsMl0gPC0gZl9mcmVxMSRleHBlY3RlZA0KZl9tYXRbMSwzXSA8LSBmX2ZyZXExJHNkDQpmX21hdFsxLDRdIDwtIGZfZnJlcTEkcC52YWx1ZQ0KZl9tYXRbMiwxXSA8LSBmX2ZyZXEyJG9ic2VydmVkDQpmX21hdFsyLDJdIDwtIGZfZnJlcTIkZXhwZWN0ZWQNCmZfbWF0WzIsM10gPC0gZl9mcmVxMiRzZA0KZl9tYXRbMiw0XSA8LSBmX2ZyZXEyJHAudmFsdWUNCmZfbWF0WzMsMV0gPC0ga19mcmVxMSRvYnNlcnZlZA0KZl9tYXRbMywyXSA8LSBrX2ZyZXExJGV4cGVjdGVkDQpmX21hdFszLDNdIDwtIGtfZnJlcTEkc2QNCmZfbWF0WzMsNF0gPC0ga19mcmVxMSRwLnZhbHVlDQpmX21hdFs0LDFdIDwtIGtfZnJlcTIkb2JzZXJ2ZWQNCmZfbWF0WzQsMl0gPC0ga19mcmVxMiRleHBlY3RlZA0KZl9tYXRbNCwzXSA8LSBrX2ZyZXEyJHNkDQpmX21hdFs0LDRdIDwtIGtfZnJlcTIkcC52YWx1ZQ0KDQojIDIuIHZvbHVtZQ0Kdl9tYXQgPC0gbWF0cml4KE5BLCBucm93PTQsIG5jb2w9NCkNCnZfbWF0WzEsMV0gPC0gZl92b2wxJG9ic2VydmVkDQp2X21hdFsxLDJdIDwtIGZfdm9sMSRleHBlY3RlZA0Kdl9tYXRbMSwzXSA8LSBmX3ZvbDEkc2QNCnZfbWF0WzEsNF0gPC0gZl92b2wxJHAudmFsdWUNCnZfbWF0WzIsMV0gPC0gZl92b2wyJG9ic2VydmVkDQp2X21hdFsyLDJdIDwtIGZfdm9sMiRleHBlY3RlZA0Kdl9tYXRbMiwzXSA8LSBmX3ZvbDIkc2QNCnZfbWF0WzIsNF0gPC0gZl92b2wyJHAudmFsdWUNCnZfbWF0WzMsMV0gPC0ga192b2wxJG9ic2VydmVkDQp2X21hdFszLDJdIDwtIGtfdm9sMSRleHBlY3RlZA0Kdl9tYXRbMywzXSA8LSBrX3ZvbDEkc2QNCnZfbWF0WzMsNF0gPC0ga192b2wxJHAudmFsdWUNCnZfbWF0WzQsMV0gPC0ga192b2wyJG9ic2VydmVkDQp2X21hdFs0LDJdIDwtIGtfdm9sMiRleHBlY3RlZA0Kdl9tYXRbNCwzXSA8LSBrX3ZvbDIkc2QNCnZfbWF0WzQsNF0gPC0ga192b2wyJHAudmFsdWUNCg0KY29sbmFtZXMoZl9tYXQpIDwtIGNvbG5hbWVzKHZfbWF0KSA8LSBjKCJvYnNlcnZlZCIsICJleHBlY3RlZCIsICJzZCIsICJwLXZhbHVlIikNCnJvd25hbWVzKGZfbWF0KSA8LSByb3duYW1lcyh2X21hdCkgPC0gYygiZGlyZWN0IGZyaWVuZHMiLCAiZGlyZWN0IGFuZCBpbmRpcmVjdCBmcmllbmRzIChkaXN0YW5jZS1kZWNheSkiLCAiZGlyZWN0IGt1ZG9zIHRpZXMiLCAiZGlyZWN0IGFuZCBpbmRpcmVjdCBrdWRvcyB0aWVzIChkaXN0YW5jZS1kZWNheSkiKQ0KDQprbml0cjo6a2FibGUoZl9tYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249Ik1vcmFuJ3MgSSBzdGF0aXN0aWMgZm9yIHNwYXRpYWwgYXV0b2NvcnJlbGF0aW9uIGJhc2VkIG9uIGdlb2Rpc3RhbmNlcyBhbmQgd2Vla2x5IHJ1bm5pbmcgZnJlcXVlbmN5IikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KDQprbml0cjo6a2FibGUodl9tYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249Ik1vcmFuJ3MgSSBzdGF0aXN0aWMgZm9yIHNwYXRpYWwgYXV0b2NvcnJlbGF0aW9uIGJhc2VkIG9uIGdlb2Rpc3RhbmNlcyBhbmQgbW9udGhseSBydW5uaW5nIHZvbHVtZSIpICU+JSANCiAga2FibGVFeHRyYTo6a2FibGVfc3R5bGluZyhib290c3RyYXBfb3B0aW9ucyA9IGMoInN0cmlwZWQiLCAiaG92ZXIiKSkNCmBgYA0KDQojIyMgQ2x1YiAzDQpgYGB7cn0NCmRmIDwtIGNsdWJkYXRhX3JzaWVuYV9mcmVxW1szXV0gIyBncmFiIGNsdWIgDQpkZjIgPC0gY2x1YmRhdGFbWzNdXSAjIGdyYWIgY2x1YiANCg0KZm5ldCA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGRmJGR5Y0NvdmFycyRmcmllbmRzaGlwKSAjIHRha2UgZnJpZW5kc2hpcCBuZXR3b3JrDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2Uga3VkbyBuZXR3b3JrDQprbmV0MSA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGtuZXRbLCwxXSkgIyBsZXQncyB0YWtlIHdhdmUgMQ0KDQojIGdldCBiZWhhdmlvcmFsIGRhdGENCmZyZXExIDwtIGRmMiRmcmVxX3J1blssLDFdICMgcnVubmluZyBmcmVxdWVuY2llcyB3YXZlIDENCnZvbDEgPC0gZGYyJHRpbWVfcnVuWywsMV0gIyBydW5uaW5nIHZvbHVtZSB3YXZlIDENCg0KIyB3ZSBpbmNsdWRlIGdlb2Rpc3RhbmNlczogc2hvcnRlc3QgcGF0aCBsZW5ndGhzIGZyb20gaSB0byBqDQpmX2dlb2Rpc3RhbmNlcyA8LSBzbmE6Omdlb2Rpc3QoZm5ldCwgY291bnQucGF0aHM9VCkNCmZfZ2VvZGlzdGFuY2VzIDwtIGZfZ2VvZGlzdGFuY2VzJGdkaXN0IA0Ka19nZW9kaXN0YW5jZXMgPC0gc25hOjpnZW9kaXN0KGtuZXQxLCBjb3VudC5wYXRocz1UKQ0Ka19nZW9kaXN0YW5jZXMgPC0ga19nZW9kaXN0YW5jZXMkZ2Rpc3QgDQoNCiMgc2V0IHRoZSBkaXN0YW5jZSAndG8geW91cnNlbGYnIHRvICdJbmYnDQpkaWFnKGZfZ2VvZGlzdGFuY2VzKSA8LSBJbmYNCmRpYWcoa19nZW9kaXN0YW5jZXMpIDwtIEluZg0KDQojIGZpcnN0IGNhbGN1bGF0ZSBNb3JhbidzIGkgZm9yIGFsdGVycyBhdCBkaXN0YW5jZSAxLg0KZl93ZWlnaHRzMSA8LSBmX2dlb2Rpc3RhbmNlcyA9PSAxDQprX3dlaWdodHMxIDwtIGtfZ2VvZGlzdGFuY2VzID09IDENCg0KIyBhbmQgdXNlIHRoZSBuZWdhdGl2ZSBleHBvbmVudGlhbCBkaXN0YW5jZS1kZWNheSBmdW5jdGlvbg0KZl93ZWlnaHRzMiA8LSBleHAoLWZfZ2VvZGlzdGFuY2VzKQ0Ka193ZWlnaHRzMiA8LSBleHAoLWtfZ2VvZGlzdGFuY2VzKQ0KDQojIGNhbGN1bGF0ZSBNb3JhbidzIEkNCiMgZm9yIGRpc3RhbmNlLTEgYW5kIHdpdGggZGlzdGFuY2UgZGVjYXksIGluIHRoZSBmcmllbmRzaGlwIGFuZCBrdWRvIG5ldHdvcmssIGZvciBmcmVxdWVuY3kgYW5kIHZvbHVtZSAgcmVzcGVjdGl2ZWx5DQojIHdlIGRvIG5vdCByb3cgc3RhbmRhcmRpemUhDQpmX2ZyZXExIDwtIGZNb3Jhbi5JKGZyZXExLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gZl93ZWlnaHRzMSwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KZl9mcmVxMiA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGZfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmZfdm9sMSA8LSBmTW9yYW4uSSh2b2wxLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gZl93ZWlnaHRzMSwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KZl92b2wyIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBmX3dlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQoNCmtfZnJlcTEgPC0gZk1vcmFuLkkoZnJlcTEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBrX3dlaWdodHMxLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQprX2ZyZXEyIDwtIGZNb3Jhbi5JKGZyZXExLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0ga193ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0Ka192b2wxIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBrX3dlaWdodHMxLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQprX3ZvbDIgPC0gZk1vcmFuLkkodm9sMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGtfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCg0KIyBtYWtlIG9iamVjdCB0byBzdG9yZSByZXN1bHRzDQojIDEuIGZyZXF1ZW5jeQ0KZl9tYXQgPC0gbWF0cml4KE5BLCBucm93PTQsIG5jb2w9NCkNCmZfbWF0WzEsMV0gPC0gZl9mcmVxMSRvYnNlcnZlZA0KZl9tYXRbMSwyXSA8LSBmX2ZyZXExJGV4cGVjdGVkDQpmX21hdFsxLDNdIDwtIGZfZnJlcTEkc2QNCmZfbWF0WzEsNF0gPC0gZl9mcmVxMSRwLnZhbHVlDQpmX21hdFsyLDFdIDwtIGZfZnJlcTIkb2JzZXJ2ZWQNCmZfbWF0WzIsMl0gPC0gZl9mcmVxMiRleHBlY3RlZA0KZl9tYXRbMiwzXSA8LSBmX2ZyZXEyJHNkDQpmX21hdFsyLDRdIDwtIGZfZnJlcTIkcC52YWx1ZQ0KZl9tYXRbMywxXSA8LSBrX2ZyZXExJG9ic2VydmVkDQpmX21hdFszLDJdIDwtIGtfZnJlcTEkZXhwZWN0ZWQNCmZfbWF0WzMsM10gPC0ga19mcmVxMSRzZA0KZl9tYXRbMyw0XSA8LSBrX2ZyZXExJHAudmFsdWUNCmZfbWF0WzQsMV0gPC0ga19mcmVxMiRvYnNlcnZlZA0KZl9tYXRbNCwyXSA8LSBrX2ZyZXEyJGV4cGVjdGVkDQpmX21hdFs0LDNdIDwtIGtfZnJlcTIkc2QNCmZfbWF0WzQsNF0gPC0ga19mcmVxMiRwLnZhbHVlDQoNCiMgMi4gdm9sdW1lDQp2X21hdCA8LSBtYXRyaXgoTkEsIG5yb3c9NCwgbmNvbD00KQ0Kdl9tYXRbMSwxXSA8LSBmX3ZvbDEkb2JzZXJ2ZWQNCnZfbWF0WzEsMl0gPC0gZl92b2wxJGV4cGVjdGVkDQp2X21hdFsxLDNdIDwtIGZfdm9sMSRzZA0Kdl9tYXRbMSw0XSA8LSBmX3ZvbDEkcC52YWx1ZQ0Kdl9tYXRbMiwxXSA8LSBmX3ZvbDIkb2JzZXJ2ZWQNCnZfbWF0WzIsMl0gPC0gZl92b2wyJGV4cGVjdGVkDQp2X21hdFsyLDNdIDwtIGZfdm9sMiRzZA0Kdl9tYXRbMiw0XSA8LSBmX3ZvbDIkcC52YWx1ZQ0Kdl9tYXRbMywxXSA8LSBrX3ZvbDEkb2JzZXJ2ZWQNCnZfbWF0WzMsMl0gPC0ga192b2wxJGV4cGVjdGVkDQp2X21hdFszLDNdIDwtIGtfdm9sMSRzZA0Kdl9tYXRbMyw0XSA8LSBrX3ZvbDEkcC52YWx1ZQ0Kdl9tYXRbNCwxXSA8LSBrX3ZvbDIkb2JzZXJ2ZWQNCnZfbWF0WzQsMl0gPC0ga192b2wyJGV4cGVjdGVkDQp2X21hdFs0LDNdIDwtIGtfdm9sMiRzZA0Kdl9tYXRbNCw0XSA8LSBrX3ZvbDIkcC52YWx1ZQ0KDQpjb2xuYW1lcyhmX21hdCkgPC0gY29sbmFtZXModl9tYXQpIDwtIGMoIm9ic2VydmVkIiwgImV4cGVjdGVkIiwgInNkIiwgInAtdmFsdWUiKQ0Kcm93bmFtZXMoZl9tYXQpIDwtIHJvd25hbWVzKHZfbWF0KSA8LSBjKCJkaXJlY3QgZnJpZW5kcyIsICJkaXJlY3QgYW5kIGluZGlyZWN0IGZyaWVuZHMgKGRpc3RhbmNlLWRlY2F5KSIsICJkaXJlY3Qga3Vkb3MgdGllcyIsICJkaXJlY3QgYW5kIGluZGlyZWN0IGt1ZG9zIHRpZXMgKGRpc3RhbmNlLWRlY2F5KSIpDQoNCmtuaXRyOjprYWJsZShmX21hdCwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iTW9yYW4ncyBJIHN0YXRpc3RpYyBmb3Igc3BhdGlhbCBhdXRvY29ycmVsYXRpb24gYmFzZWQgb24gZ2VvZGlzdGFuY2VzIGFuZCB3ZWVrbHkgcnVubmluZyBmcmVxdWVuY3kiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQoNCmtuaXRyOjprYWJsZSh2X21hdCwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iTW9yYW4ncyBJIHN0YXRpc3RpYyBmb3Igc3BhdGlhbCBhdXRvY29ycmVsYXRpb24gYmFzZWQgb24gZ2VvZGlzdGFuY2VzIGFuZCBtb250aGx5IHJ1bm5pbmcgdm9sdW1lIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCg0KIyMjIENsdWIgNA0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFfZnJlcVtbNF1dICMgZ3JhYiBjbHViIA0KZGYyIDwtIGNsdWJkYXRhW1s0XV0gIyBncmFiIGNsdWIgDQoNCg0KZm5ldCA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGRmJGR5Y0NvdmFycyRmcmllbmRzaGlwKSAjIHRha2UgZnJpZW5kc2hpcCBuZXR3b3JrDQprbmV0IDwtIGRmJGRlcHZhcnMka3Vkb25ldCAjIHRha2Uga3VkbyBuZXR3b3JrDQprbmV0MSA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGtuZXRbLCwxXSkgIyBsZXQncyB0YWtlIHdhdmUgMQ0KDQojIGdldCBiZWhhdmlvcmFsIGRhdGENCmZyZXExIDwtIGRmMiRmcmVxX3J1blssLDFdICMgcnVubmluZyBmcmVxdWVuY2llcyB3YXZlIDENCnZvbDEgPC0gZGYyJHRpbWVfcnVuWywsMV0gIyBydW5uaW5nIHZvbHVtZSB3YXZlIDENCg0KIyB3ZSBpbmNsdWRlIGdlb2Rpc3RhbmNlczogc2hvcnRlc3QgcGF0aCBsZW5ndGhzIGZyb20gaSB0byBqDQpmX2dlb2Rpc3RhbmNlcyA8LSBzbmE6Omdlb2Rpc3QoZm5ldCwgY291bnQucGF0aHM9VCkNCmZfZ2VvZGlzdGFuY2VzIDwtIGZfZ2VvZGlzdGFuY2VzJGdkaXN0IA0Ka19nZW9kaXN0YW5jZXMgPC0gc25hOjpnZW9kaXN0KGtuZXQxLCBjb3VudC5wYXRocz1UKQ0Ka19nZW9kaXN0YW5jZXMgPC0ga19nZW9kaXN0YW5jZXMkZ2Rpc3QgDQoNCiMgc2V0IHRoZSBkaXN0YW5jZSAndG8geW91cnNlbGYnIHRvICdJbmYnDQpkaWFnKGZfZ2VvZGlzdGFuY2VzKSA8LSBJbmYNCmRpYWcoa19nZW9kaXN0YW5jZXMpIDwtIEluZg0KDQojIGZpcnN0IGNhbGN1bGF0ZSBNb3JhbidzIGkgZm9yIGFsdGVycyBhdCBkaXN0YW5jZSAxLg0KZl93ZWlnaHRzMSA8LSBmX2dlb2Rpc3RhbmNlcyA9PSAxDQprX3dlaWdodHMxIDwtIGtfZ2VvZGlzdGFuY2VzID09IDENCg0KIyBhbmQgdXNlIHRoZSBuZWdhdGl2ZSBleHBvbmVudGlhbCBkaXN0YW5jZS1kZWNheSBmdW5jdGlvbg0KZl93ZWlnaHRzMiA8LSBleHAoLWZfZ2VvZGlzdGFuY2VzKQ0Ka193ZWlnaHRzMiA8LSBleHAoLWtfZ2VvZGlzdGFuY2VzKQ0KDQojIGNhbGN1bGF0ZSBNb3JhbidzIEkNCiMgZm9yIGRpc3RhbmNlLTEgYW5kIHdpdGggZGlzdGFuY2UgZGVjYXksIGluIHRoZSBmcmllbmRzaGlwIGFuZCBrdWRvIG5ldHdvcmssIGZvciBmcmVxdWVuY3kgYW5kIHZvbHVtZSAgcmVzcGVjdGl2ZWx5DQojIHdlIGRvIG5vdCByb3cgc3RhbmRhcmRpemUhDQpmX2ZyZXExIDwtIGZNb3Jhbi5JKGZyZXExLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gZl93ZWlnaHRzMSwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KZl9mcmVxMiA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGZfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmZfdm9sMSA8LSBmTW9yYW4uSSh2b2wxLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gZl93ZWlnaHRzMSwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KZl92b2wyIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBmX3dlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQoNCmtfZnJlcTEgPC0gZk1vcmFuLkkoZnJlcTEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBrX3dlaWdodHMxLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQprX2ZyZXEyIDwtIGZNb3Jhbi5JKGZyZXExLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0ga193ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0Ka192b2wxIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBrX3dlaWdodHMxLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQprX3ZvbDIgPC0gZk1vcmFuLkkodm9sMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGtfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCg0KIyBtYWtlIG9iamVjdCB0byBzdG9yZSByZXN1bHRzDQojIDEuIGZyZXF1ZW5jeQ0KZl9tYXQgPC0gbWF0cml4KE5BLCBucm93PTQsIG5jb2w9NCkNCmZfbWF0WzEsMV0gPC0gZl9mcmVxMSRvYnNlcnZlZA0KZl9tYXRbMSwyXSA8LSBmX2ZyZXExJGV4cGVjdGVkDQpmX21hdFsxLDNdIDwtIGZfZnJlcTEkc2QNCmZfbWF0WzEsNF0gPC0gZl9mcmVxMSRwLnZhbHVlDQpmX21hdFsyLDFdIDwtIGZfZnJlcTIkb2JzZXJ2ZWQNCmZfbWF0WzIsMl0gPC0gZl9mcmVxMiRleHBlY3RlZA0KZl9tYXRbMiwzXSA8LSBmX2ZyZXEyJHNkDQpmX21hdFsyLDRdIDwtIGZfZnJlcTIkcC52YWx1ZQ0KZl9tYXRbMywxXSA8LSBrX2ZyZXExJG9ic2VydmVkDQpmX21hdFszLDJdIDwtIGtfZnJlcTEkZXhwZWN0ZWQNCmZfbWF0WzMsM10gPC0ga19mcmVxMSRzZA0KZl9tYXRbMyw0XSA8LSBrX2ZyZXExJHAudmFsdWUNCmZfbWF0WzQsMV0gPC0ga19mcmVxMiRvYnNlcnZlZA0KZl9tYXRbNCwyXSA8LSBrX2ZyZXEyJGV4cGVjdGVkDQpmX21hdFs0LDNdIDwtIGtfZnJlcTIkc2QNCmZfbWF0WzQsNF0gPC0ga19mcmVxMiRwLnZhbHVlDQoNCiMgMi4gdm9sdW1lDQp2X21hdCA8LSBtYXRyaXgoTkEsIG5yb3c9NCwgbmNvbD00KQ0Kdl9tYXRbMSwxXSA8LSBmX3ZvbDEkb2JzZXJ2ZWQNCnZfbWF0WzEsMl0gPC0gZl92b2wxJGV4cGVjdGVkDQp2X21hdFsxLDNdIDwtIGZfdm9sMSRzZA0Kdl9tYXRbMSw0XSA8LSBmX3ZvbDEkcC52YWx1ZQ0Kdl9tYXRbMiwxXSA8LSBmX3ZvbDIkb2JzZXJ2ZWQNCnZfbWF0WzIsMl0gPC0gZl92b2wyJGV4cGVjdGVkDQp2X21hdFsyLDNdIDwtIGZfdm9sMiRzZA0Kdl9tYXRbMiw0XSA8LSBmX3ZvbDIkcC52YWx1ZQ0Kdl9tYXRbMywxXSA8LSBrX3ZvbDEkb2JzZXJ2ZWQNCnZfbWF0WzMsMl0gPC0ga192b2wxJGV4cGVjdGVkDQp2X21hdFszLDNdIDwtIGtfdm9sMSRzZA0Kdl9tYXRbMyw0XSA8LSBrX3ZvbDEkcC52YWx1ZQ0Kdl9tYXRbNCwxXSA8LSBrX3ZvbDIkb2JzZXJ2ZWQNCnZfbWF0WzQsMl0gPC0ga192b2wyJGV4cGVjdGVkDQp2X21hdFs0LDNdIDwtIGtfdm9sMiRzZA0Kdl9tYXRbNCw0XSA8LSBrX3ZvbDIkcC52YWx1ZQ0KDQpjb2xuYW1lcyhmX21hdCkgPC0gY29sbmFtZXModl9tYXQpIDwtIGMoIm9ic2VydmVkIiwgImV4cGVjdGVkIiwgInNkIiwgInAtdmFsdWUiKQ0Kcm93bmFtZXMoZl9tYXQpIDwtIHJvd25hbWVzKHZfbWF0KSA8LSBjKCJkaXJlY3QgZnJpZW5kcyIsICJkaXJlY3QgYW5kIGluZGlyZWN0IGZyaWVuZHMgKGRpc3RhbmNlLWRlY2F5KSIsICJkaXJlY3Qga3Vkb3MgdGllcyIsICJkaXJlY3QgYW5kIGluZGlyZWN0IGt1ZG9zIHRpZXMgKGRpc3RhbmNlLWRlY2F5KSIpDQoNCmtuaXRyOjprYWJsZShmX21hdCwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iTW9yYW4ncyBJIHN0YXRpc3RpYyBmb3Igc3BhdGlhbCBhdXRvY29ycmVsYXRpb24gYmFzZWQgb24gZ2VvZGlzdGFuY2VzIGFuZCB3ZWVrbHkgcnVubmluZyBmcmVxdWVuY3kiKSAlPiUgDQogIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpDQoNCmtuaXRyOjprYWJsZSh2X21hdCwgZGlnaXRzPTIsICJodG1sIiwgY2FwdGlvbj0iTW9yYW4ncyBJIHN0YXRpc3RpYyBmb3Igc3BhdGlhbCBhdXRvY29ycmVsYXRpb24gYmFzZWQgb24gZ2VvZGlzdGFuY2VzIGFuZCBtb250aGx5IHJ1bm5pbmcgdm9sdW1lIikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KYGBgDQoNCg0KIyMjIENsdWIgNQ0KYGBge3J9DQpkZiA8LSBjbHViZGF0YV9yc2llbmFfZnJlcVtbNV1dICMgZ3JhYiBjbHViIA0KZGYyIDwtIGNsdWJkYXRhW1s1XV0gIyBncmFiIGNsdWIgDQoNCmZuZXQgPC0gbmV0d29yazo6YXMubmV0d29yayhkZiRkeWNDb3ZhcnMkZnJpZW5kc2hpcCkgIyB0YWtlIGZyaWVuZHNoaXAgbmV0d29yaw0Ka25ldCA8LSBkZiRkZXB2YXJzJGt1ZG9uZXQgIyB0YWtlIGt1ZG8gbmV0d29yaw0Ka25ldDEgPC0gbmV0d29yazo6YXMubmV0d29yayhrbmV0WywsMV0pICMgbGV0J3MgdGFrZSB3YXZlIDENCg0KIyBnZXQgYmVoYXZpb3JhbCBkYXRhDQpmcmVxMSA8LSBkZjIkZnJlcV9ydW5bLCwxXSAjIHJ1bm5pbmcgZnJlcXVlbmNpZXMgd2F2ZSAxDQp2b2wxIDwtIGRmMiR0aW1lX3J1blssLDFdICMgcnVubmluZyB2b2x1bWUgd2F2ZSAxDQoNCiMgd2UgaW5jbHVkZSBnZW9kaXN0YW5jZXM6IHNob3J0ZXN0IHBhdGggbGVuZ3RocyBmcm9tIGkgdG8gag0KZl9nZW9kaXN0YW5jZXMgPC0gc25hOjpnZW9kaXN0KGZuZXQsIGNvdW50LnBhdGhzPVQpDQpmX2dlb2Rpc3RhbmNlcyA8LSBmX2dlb2Rpc3RhbmNlcyRnZGlzdCANCmtfZ2VvZGlzdGFuY2VzIDwtIHNuYTo6Z2VvZGlzdChrbmV0MSwgY291bnQucGF0aHM9VCkNCmtfZ2VvZGlzdGFuY2VzIDwtIGtfZ2VvZGlzdGFuY2VzJGdkaXN0IA0KDQojIHNldCB0aGUgZGlzdGFuY2UgJ3RvIHlvdXJzZWxmJyB0byAnSW5mJw0KZGlhZyhmX2dlb2Rpc3RhbmNlcykgPC0gSW5mDQpkaWFnKGtfZ2VvZGlzdGFuY2VzKSA8LSBJbmYNCg0KIyBmaXJzdCBjYWxjdWxhdGUgTW9yYW4ncyBpIGZvciBhbHRlcnMgYXQgZGlzdGFuY2UgMS4NCmZfd2VpZ2h0czEgPC0gZl9nZW9kaXN0YW5jZXMgPT0gMQ0Ka193ZWlnaHRzMSA8LSBrX2dlb2Rpc3RhbmNlcyA9PSAxDQoNCiMgYW5kIHVzZSB0aGUgbmVnYXRpdmUgZXhwb25lbnRpYWwgZGlzdGFuY2UtZGVjYXkgZnVuY3Rpb24NCmZfd2VpZ2h0czIgPC0gZXhwKC1mX2dlb2Rpc3RhbmNlcykNCmtfd2VpZ2h0czIgPC0gZXhwKC1rX2dlb2Rpc3RhbmNlcykNCg0KIyBjYWxjdWxhdGUgTW9yYW4ncyBJDQojIGZvciBkaXN0YW5jZS0xIGFuZCB3aXRoIGRpc3RhbmNlIGRlY2F5LCBpbiB0aGUgZnJpZW5kc2hpcCBhbmQga3VkbyBuZXR3b3JrLCBmb3IgZnJlcXVlbmN5IGFuZCB2b2x1bWUgIHJlc3BlY3RpdmVseQ0KIyB3ZSBkbyBub3Qgcm93IHN0YW5kYXJkaXplIQ0KZl9mcmVxMSA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGZfd2VpZ2h0czEsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmZfZnJlcTIgPC0gZk1vcmFuLkkoZnJlcTEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBmX3dlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQpmX3ZvbDEgPC0gZk1vcmFuLkkodm9sMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGZfd2VpZ2h0czEsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmZfdm9sMiA8LSBmTW9yYW4uSSh2b2wxLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0gZl93ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KDQprX2ZyZXExIDwtIGZNb3Jhbi5JKGZyZXExLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0ga193ZWlnaHRzMSwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0Ka19mcmVxMiA8LSBmTW9yYW4uSShmcmVxMSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IGtfd2VpZ2h0czIsIG5hLnJtID0gVFJVRSwgcm93c3RhbmRhcmRpemUgPSBGQUxTRSkNCmtfdm9sMSA8LSBmTW9yYW4uSSh2b2wxLCBzY2FsZWQgPSBGQUxTRSwgd2VpZ2h0ID0ga193ZWlnaHRzMSwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0Ka192b2wyIDwtIGZNb3Jhbi5JKHZvbDEsIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSBrX3dlaWdodHMyLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQoNCiMgbWFrZSBvYmplY3QgdG8gc3RvcmUgcmVzdWx0cw0KIyAxLiBmcmVxdWVuY3kNCmZfbWF0IDwtIG1hdHJpeChOQSwgbnJvdz00LCBuY29sPTQpDQpmX21hdFsxLDFdIDwtIGZfZnJlcTEkb2JzZXJ2ZWQNCmZfbWF0WzEsMl0gPC0gZl9mcmVxMSRleHBlY3RlZA0KZl9tYXRbMSwzXSA8LSBmX2ZyZXExJHNkDQpmX21hdFsxLDRdIDwtIGZfZnJlcTEkcC52YWx1ZQ0KZl9tYXRbMiwxXSA8LSBmX2ZyZXEyJG9ic2VydmVkDQpmX21hdFsyLDJdIDwtIGZfZnJlcTIkZXhwZWN0ZWQNCmZfbWF0WzIsM10gPC0gZl9mcmVxMiRzZA0KZl9tYXRbMiw0XSA8LSBmX2ZyZXEyJHAudmFsdWUNCmZfbWF0WzMsMV0gPC0ga19mcmVxMSRvYnNlcnZlZA0KZl9tYXRbMywyXSA8LSBrX2ZyZXExJGV4cGVjdGVkDQpmX21hdFszLDNdIDwtIGtfZnJlcTEkc2QNCmZfbWF0WzMsNF0gPC0ga19mcmVxMSRwLnZhbHVlDQpmX21hdFs0LDFdIDwtIGtfZnJlcTIkb2JzZXJ2ZWQNCmZfbWF0WzQsMl0gPC0ga19mcmVxMiRleHBlY3RlZA0KZl9tYXRbNCwzXSA8LSBrX2ZyZXEyJHNkDQpmX21hdFs0LDRdIDwtIGtfZnJlcTIkcC52YWx1ZQ0KDQojIDIuIHZvbHVtZQ0Kdl9tYXQgPC0gbWF0cml4KE5BLCBucm93PTQsIG5jb2w9NCkNCnZfbWF0WzEsMV0gPC0gZl92b2wxJG9ic2VydmVkDQp2X21hdFsxLDJdIDwtIGZfdm9sMSRleHBlY3RlZA0Kdl9tYXRbMSwzXSA8LSBmX3ZvbDEkc2QNCnZfbWF0WzEsNF0gPC0gZl92b2wxJHAudmFsdWUNCnZfbWF0WzIsMV0gPC0gZl92b2wyJG9ic2VydmVkDQp2X21hdFsyLDJdIDwtIGZfdm9sMiRleHBlY3RlZA0Kdl9tYXRbMiwzXSA8LSBmX3ZvbDIkc2QNCnZfbWF0WzIsNF0gPC0gZl92b2wyJHAudmFsdWUNCnZfbWF0WzMsMV0gPC0ga192b2wxJG9ic2VydmVkDQp2X21hdFszLDJdIDwtIGtfdm9sMSRleHBlY3RlZA0Kdl9tYXRbMywzXSA8LSBrX3ZvbDEkc2QNCnZfbWF0WzMsNF0gPC0ga192b2wxJHAudmFsdWUNCnZfbWF0WzQsMV0gPC0ga192b2wyJG9ic2VydmVkDQp2X21hdFs0LDJdIDwtIGtfdm9sMiRleHBlY3RlZA0Kdl9tYXRbNCwzXSA8LSBrX3ZvbDIkc2QNCnZfbWF0WzQsNF0gPC0ga192b2wyJHAudmFsdWUNCg0KY29sbmFtZXMoZl9tYXQpIDwtIGNvbG5hbWVzKHZfbWF0KSA8LSBjKCJvYnNlcnZlZCIsICJleHBlY3RlZCIsICJzZCIsICJwLXZhbHVlIikNCnJvd25hbWVzKGZfbWF0KSA8LSByb3duYW1lcyh2X21hdCkgPC0gYygiZGlyZWN0IGZyaWVuZHMiLCAiZGlyZWN0IGFuZCB1bmRpcmVjdCBmcmllbmRzIChkaXN0YW5jZS1kZWNheSkiLCAiZGlyZWN0IGt1ZG9zIHRpZXMiLCAiZGlyZWN0IGFuZCBpbmRpcmVjdCBrdWRvcyB0aWVzIChkaXN0YW5jZS1kZWNheSkiKQ0KDQprbml0cjo6a2FibGUoZl9tYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249Ik1vcmFuJ3MgSSBzdGF0aXN0aWMgZm9yIHNwYXRpYWwgYXV0b2NvcnJlbGF0aW9uIGJhc2VkIG9uIGdlb2Rpc3RhbmNlcyBhbmQgd2Vla2x5IHJ1bm5pbmcgZnJlcXVlbmN5IikgJT4lIA0KICBrYWJsZUV4dHJhOjprYWJsZV9zdHlsaW5nKGJvb3RzdHJhcF9vcHRpb25zID0gYygic3RyaXBlZCIsICJob3ZlciIpKQ0KDQprbml0cjo6a2FibGUodl9tYXQsIGRpZ2l0cz0yLCAiaHRtbCIsIGNhcHRpb249Ik1vcmFuJ3MgSSBzdGF0aXN0aWMgZm9yIHNwYXRpYWwgYXV0b2NvcnJlbGF0aW9uIGJhc2VkIG9uIGdlb2Rpc3RhbmNlcyBhbmQgbW9udGhseSBydW5uaW5nIHZvbHVtZSIpICU+JSANCiAga2FibGVFeHRyYTo6a2FibGVfc3R5bGluZyhib290c3RyYXBfb3B0aW9ucyA9IGMoInN0cmlwZWQiLCAiaG92ZXIiKSkNCmBgYA0KDQoNCiMjIHstfQ0KDQpIZXJlLCB0aGUgTW9yYW4ncyBJIHN0YXRpc3RpYyB0ZXN0cyB3aGV0aGVyIGNsdWIgbWVtYmVycyB0aGF0IGFyZSAqY2xvc2VyIHRvIG9uZSBhbm90aGVyKiAoaS5lLiwgaGF2aW5nIGEgc2hvcnRlciBnZW9kZXNpYy9wYXRoIGxlbmd0aCksIGFyZSBtb3JlIGEgc2ltaWxhciB3aXRoIHJlc3BlY3QgdG8gdGhlaXIgYmVoYXZpb3IsIHVuZGVyIHRoZSBudWxsIGh5cG90aGVzaXMgdGhhdCBiZWhhdmlvciBpcyAncmFuZG9tbHkgZGlzdHJpYnV0ZWQnIGFtb25nIHRoZSBjbHViIG1lbWJlcnMuDQoNCldlIG9ic2VydmUgdGhhdCwgaW5kZWVkLCBmcmllbmRzIHRoYXQgYXJlIGNsb3NlciB0byBvbmUgYW5vdGhlciBhcmUgbW9yZSBhbGlrZSwgYW5kIGVzcGVjaWFsbHkga3Vkb3MtdGllcyEgQXV0b2NvcnJlbGF0aW9uIHdhcyBzdHJvbmdlciB3aXRob3V0IHRoZSBkaXN0YW5jZS1kZWNheSBmdW5jdGlvbiwgd2hpY2ggc3VnZ2VzdHMgdGhhdCBlc3BlY2lhbGx5IGNsb3NlIGFsdGVycyAod2l0aCBwYXRoIGxlbmd0aCBvbmUpIGFyZSBzaW1pbGFyLiANCg0KLS0tLQ0KDQo8YnI+DQoNCg0KDQoNCi0tLS0NCiMjIFJlZmVyZW5jZXM=</div>
<style>
.center {
  text-align: center;
  color: red;
}
</style>

<hr>
<br>
<p class="center">Copyright &copy; 2021 Rob Franken</p>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("des.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
