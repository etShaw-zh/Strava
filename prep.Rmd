---
title: "Data preparation"
bibliography: references.bib
date: "Last compiled on `r format(Sys.time(), '%B, %Y')`"
output: 
  html_document:
    css: tweaks.css
    toc:  true
    toc_float: true
    number_sections: false
    toc_depth: 1
    code_folding: show
    code_download: yes
---

```{r, globalsettings, echo=FALSE, warning=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
opts_chunk$set(tidy.opts=list(width.cutoff=100),tidy=TRUE, warning = FALSE, message = FALSE,comment = "#>", cache=TRUE, class.source=c("test"), class.output=c("test2"))
options(width = 100)
rgl::setupKnitr()


colorize <- function(x, color) {sprintf("<span style='color: %s;'>%s</span>", color, x) }
```


```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(position = c('top', 'right'))
#klippy::klippy(color = 'darkred')
#klippy::klippy(tooltip_message = 'Click to copy', tooltip_success = 'Done')
```


---  



# clubdata.RData

In the following scripts a list containing the (anonymized) data of all clubs is made (clubdata.RData).

* Our primary network variable is the Kudo-network. We argue that Kudos are an indication of the 'strength' of friendships. We construct and ordered Kudo-network variable, i.e., a network in which awarding/receiving **more than 1** Kudo constitutes the presence of a (directed) tie, is a sub-network of the network in which awarding/receiving **at least 1 Kudo** counts as a tie. Thus, the Kudo-network with numeric tie values (i.e., number of Kudos awarded/received) is represented as a multivariate network, in which it is impossible that a tie exists in the second-order but not in the first-order network, as suggested by @rsienamanual, section 5.6.

* For the behavioral data we include information on the *frequency* (i.e., in times per week) and *volume* (i.e., in minutes per month) of running activities. We included activity (frequency and volume) in other sports (e.g., cycling and swimming) as a time-varying covariate. We categorized these continuous behavioral variables following recommendations in the literature: chapter 6 of @niezink and page 27 of @rsienamanual.

  + For *frequency*, I chose 9 categories, ranging from 0-7 times per week, and a 9th category, since in some clubs a substantial proportion of club members ran more frequently than once a day.

  + For *volume*, I chose 9 categories, with category 0 indicating 0 minutes spent on training, and categories 1-8 being equally populated (as in @flashman). Note that this results in different categorizations for each club. 


```{r clubs, eval=FALSE}
# first, install the required packages.
library(RSiena)
library(dplyr)


# clean the working environment 
rm (list = ls( ))

# club string represents the club ID
club_str <- c("clubid1", "clubid2", "clubid3", "clubid4" ,"clubid5") 

# the following script reads the data of the clubs from the folder for each club, stores them in a list, and saves it in an object in the last function call of this script. 


for (i in (1: length(club_str))) {
  club_id <- club_str[i] 

  # read the data from the club    
  clubdata <- read.csv(paste("clubs/", club_id, "/", "egoData_extended.csv", sep = ""), row.names = NULL, sep= ",")
  # saving club size
  size <- length(clubdata[, 'gender'])
  # the number of months that we want to add as waves
  n_waves <- 12
  # separating male/female/other
  male <- ifelse(clubdata[,'gender'] == "M", 1, 0)
  female <- ifelse(clubdata[,'gender'] == "F", 1, 0)
  other <- ifelse(clubdata[,'gender'] == "O", 1, 0)
  
  
  # let's load the friendship network
  friend_data <- as.matrix(read.csv(paste("clubs/", club_id, "/", "socialnetwork.csv", sep = ""), row.names = NULL, sep= ","))
  # remove the first column (represents index made in the csv)
  friend_data <- friend_data[, 2:ncol(friend_data)]
  # and anonymize the user id, with an id-maker function
  idmaker <- function(x)
  {
    max.val = x*100000
    count <- nchar(as.character(max.val))           # find out how many 'numbers' each id will have after the letter
    size <- paste("%0",count,"d",sep="")            # set the variable to be fed into 'sprintf' to ensure we have leading 0's
    lets <- toupper(sample(letters,x, replace=T))   # randomizing the letters 
    nums <- sprintf(size,sample(1:max.val)[1:x])    # randomizing the numbers, and ensuring they all have the same number of characters
    ids <- paste(lets,nums,sep="")                  # joining them together
    return(ids)
  }
  fakeid <- idmaker(nrow(friend_data)) # generate random id
  colnames(friend_data) <- fakeid # anonymizing users
  
  
  # let's load the kudo network
  path <- paste("clubs/", club_id, "/", "kudos", sep="") # create path
  {
    kudo_w1 <- as.matrix(read.csv(paste(path, "1-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w1 <- kudo_w1[,2:ncol(kudo_w1)]
    kudo_w2 <- as.matrix(read.csv(paste(path, "2-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w2 <- kudo_w2[,2:ncol(kudo_w2)]
    kudo_w3 <- as.matrix(read.csv(paste(path, "3-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w3 <- kudo_w3[,2:ncol(kudo_w3)]
    kudo_w4 <- as.matrix(read.csv(paste(path, "4-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w4 <- kudo_w4[,2:ncol(kudo_w4)]
    kudo_w5 <- as.matrix(read.csv(paste(path, "5-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w5 <- kudo_w5[,2:ncol(kudo_w5)]
    kudo_w6 <- as.matrix(read.csv(paste(path, "6-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w6 <- kudo_w6[,2:ncol(kudo_w6)]
    kudo_w7 <- as.matrix(read.csv(paste(path, "7-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w7 <- kudo_w7[,2:ncol(kudo_w7)]
    kudo_w8 <- as.matrix(read.csv(paste(path, "8-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w8 <- kudo_w8[,2:ncol(kudo_w8)]
    kudo_w9 <- as.matrix(read.csv(paste(path, "9-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w9 <- kudo_w9[,2:ncol(kudo_w9)]
    kudo_w10 <- as.matrix(read.csv(paste(path, "10-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w10 <- kudo_w10[,2:ncol(kudo_w10)]
    kudo_w11 <- as.matrix(read.csv(paste(path, "11-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w11 <- kudo_w11[,2:ncol(kudo_w11)]
    kudo_w12 <- as.matrix(read.csv(paste(path, "12-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w12 <- kudo_w12[,2:ncol(kudo_w12)]
  }
  kudos <- array( c(kudo_w1,kudo_w2,kudo_w3,kudo_w4,kudo_w5,kudo_w6,kudo_w7,kudo_w8,kudo_w9,kudo_w10,kudo_w11,kudo_w12),
                  dim = c( size, size, n_waves)) #Kudo matrix
  
  # we operationalize kudo-relationships in different ways: in an ordered fashion
  # rsiena will set constraints between the networks
  kudo_data <- ifelse(kudos > 0, 1, 0) #if at least 1 Kudo is send, tie exists
  kudo_data2 <- ifelse(kudos > 1, 1, 0) #at least 2 Kudos
  kudo_data3 <- ifelse(kudos > 2, 1, 0) #at least 3 Kudos
  #for now, these order cut-offs were quite arbitrarily chosen; can be extended, or be applied with other categories.
  
  
  # running time
  time_run <- array( c( clubdata[, 'time_run_1.2019'], clubdata[, 'time_run_2.2019'], clubdata[, 'time_run_3.2019'], clubdata[, 'time_run_4.2019'], clubdata[, 'time_run_5.2019'], clubdata[, 'time_run_6.2019'], clubdata[, 'time_run_7.2019'], clubdata[, 'time_run_8.2019'], clubdata[, 'time_run_9.2019'], clubdata[, 'time_run_10.2019'], clubdata[, 'time_run_11.2019'], clubdata[, 'time_run_12.2019']),
                     dim = c( size, 1, n_waves ) )

  # we cluster the time into 9 categories (from 0 to 8, with 0 being 0 minutes)
  # we will equally populate the categories 1-8 (cf. Flashman 2012)
  df <- data.frame(matrix(time_run))
  df$matrix.time_run. <- ifelse(df$matrix.time_run. == 0, NA, df$matrix.time_run.) #turn 0's to NA
  df <- mutate(df, cat = ntile(df$matrix.time_run., 8))
  df$cat <- ifelse(is.na(df$cat), 0, df$cat)
  time_run_temp <- array(df$cat, dim = c(size, 1, n_waves))

  # we also make an independent behavior-based variable that does not consider
  # actors' absolute score (or category), but rather their ranking on the behavioral scale, for each time point. 
  # this variable will be used to construct independent influence effects of alters that score higher and lower than ego
  # we use dense ranking ("111223") ranking (so all actors scoring 0 get the same rank)
  out <- list()
  for (i in 1:n_waves) { 
    df <- data.frame(x = time_run[,,i]) # raw scores for each time point
    df <- mutate(df, rank = rank(x, ties.method = "max")) # rank and keep ties ties 
    denserank <- df$rank - (min(df$rank) - 1) # make dense ranking
    out[[i]] <- denserank
  }
  time_rank <- array(
    c(out[[1]], out[[2]], out[[3]], out[[4]], out[[5]], out[[6]], out[[7]], out[[8]], out[[9]], out[[10]], out[[11]], out[[12]]),
    dim = c( size, 1, n_waves)) 

  
  # running frequency
  freq_run <- array( c( clubdata[, 'X.run_1.2019'], clubdata[, 'X.run_2.2019'], clubdata[, 'X.run_3.2019'], clubdata[, 'X.run_4.2019'], clubdata[, 'X.run_5.2019'], clubdata[, 'X.run_6.2019'], clubdata[, 'X.run_7.2019'], clubdata[, 'X.run_8.2019'], clubdata[, 'X.run_9.2019'], clubdata[, 'X.run_10.2019'], clubdata[, 'X.run_11.2019'], clubdata[, 'X.run_12.2019']),
                     dim = c( size, 1, n_waves ) ) # frequencies per month
  frequencies <- ceiling(freq_run/4) # per week
  freq_run_temp <- ifelse(frequencies > 7, 7, frequencies) # cap off at 7 times per week
  
  # also make the independent ranking variable for running frequency
  out <- list()
  for (i in 1:n_waves) { 
    df <- data.frame(x = freq_run[,,i]) # raw scores for each time point
    df <- mutate(df, rank = rank(x, ties.method = "max")) # rank and keep ties ties 
    denserank <- df$rank - (min(df$rank) - 1) # make dense ranking
    out[[i]] <- denserank
  }
  freq_rank <- array(
    c(out[[1]], out[[2]], out[[3]], out[[4]], out[[5]], out[[6]], out[[7]], out[[8]], out[[9]], out[[10]], out[[11]], out[[12]]),
    dim = c( size, 1, n_waves)) 

  
  # now that we have running data, let's load other activity data (e.g., cycling, swimming)
  # time
  time_ride <- array( c( clubdata[, 'time_ride_1.2019'], clubdata[, 'time_ride_2.2019'], clubdata[, 'time_ride_3.2019'], clubdata[, 'time_ride_4.2019'], clubdata[, 'time_ride_5.2019'], clubdata[, 'time_ride_6.2019'], clubdata[, 'time_ride_7.2019'], clubdata[, 'time_ride_8.2019'], clubdata[, 'time_ride_9.2019'], clubdata[, 'time_ride_10.2019'], clubdata[, 'time_ride_11.2019'], clubdata[, 'time_ride_12.2019']),
                      dim = c( size, 1, n_waves ) )
  time_other <- array( c( clubdata[, 'time_other_1.2019'], clubdata[, 'time_other_2.2019'], clubdata[, 'time_other_3.2019'], clubdata[, 'time_other_4.2019'], clubdata[, 'time_other_5.2019'], clubdata[, 'time_other_6.2019'], clubdata[, 'time_other_7.2019'], clubdata[, 'time_other_8.2019'], clubdata[, 'time_other_9.2019'], clubdata[, 'time_other_10.2019'], clubdata[, 'time_other_11.2019'], clubdata[, 'time_other_12.2019']),
                       dim = c( size, 1, n_waves ) )
  
  time_other <- time_ride + time_other
  
  df <- data.frame(matrix(time_other))
  df$matrix.time_other. <- ifelse(df$matrix.time_other. == 0, NA, df$matrix.time_other.) #turn 0's to NA
  df <- mutate(df, cat = ntile(df$matrix.time_other., 8))
  df$cat <- ifelse(is.na(df$cat), 0, df$cat)
  time_other_temp <- array(df$cat, dim = c(size, 1, n_waves))
  
  # frequency
  freq_ride <- array( c( clubdata[, 'X.ride_1.2019'], clubdata[, 'X.ride_2.2019'], clubdata[, 'X.ride_3.2019'], clubdata[, 'X.ride_4.2019'], clubdata[, 'X.ride_5.2019'], clubdata[, 'X.ride_6.2019'], clubdata[, 'X.ride_7.2019'], clubdata[, 'X.ride_8.2019'], clubdata[, 'X.ride_9.2019'], clubdata[, 'X.ride_10.2019'], clubdata[, 'X.ride_11.2019'], clubdata[, 'X.ride_12.2019']),
                      dim = c( size, 1, n_waves ) )
  freq_other <- array( c( clubdata[, 'X.other_1.2019'], clubdata[, 'X.other_2.2019'], clubdata[, 'X.other_3.2019'], clubdata[, 'X.other_4.2019'], clubdata[, 'X.other_5.2019'], clubdata[, 'X.other_6.2019'], clubdata[, 'X.other_7.2019'], clubdata[, 'X.other_8.2019'], clubdata[, 'X.other_9.2019'], clubdata[, 'X.other_10.2019'], clubdata[, 'X.other_11.2019'], clubdata[, 'X.other_12.2019']),
                       dim = c( size, 1, n_waves ) )
  
  freq_other <- freq_ride + freq_other
  frequencies <- ceiling(freq_other/4)
  freq_other_temp <- ifelse(frequencies > 7, 7, frequencies)
  
  # specify months of winter in case we want to use it as a varying covariate
  # starts with december
  winter <- rep(c(1,1,1,0,0,0,0,0,0,0,0,0), size)
  winter <- matrix(winter,nrow = size,ncol = n_waves, byrow = TRUE)
  
  # create a list containing all the read club data for the current club
  club <- list("friendship" = friend_data, 
               "kudo" = kudo_data, "kudo2" = kudo_data2, "kudo3" = kudo_data3,
               "freq_run" = freq_run_temp, "time_run" = time_run_temp, "freq_other" = freq_other_temp, "time_other" = time_other_temp, "winter" = winter, "male" = male, "female" = female, "other" = other, "netsize" = size,
               "freq_rank" = freq_rank, "time_rank" = time_rank)
  
  # save 
  
  save(club, file=paste("clubs/", "club", club_id, ".RData", sep = ""))
  
}

####################################################

# Now that we have saved the clubdata for all clubs, let's combine them in one list

# first clean the working directory
rm (list = ls( ))

# load in the separate club-objects
{
  load("clubs/club1.RData")
  club1 <- club
  
  club2 <- load("clubs/club2.RData")
  club2 <- club
  
  club3 <- load("clubs/club3.RData")
  club3 <- club
  
  club4 <- load("clubs/club4.RData")
  club4 <- club
  
  club5 <- load("clubs/club5.RData")
  club5 <- club
}
# and make a list containing all the clubdata
clubdata <- list(club1, club2, club3, club4, club5)

# save the output
save(clubdata, file="clubs/clubdata.RData")


``` 

---  

# clubdata_rsiena.RData

The following script creates a list containing R-SIENA objects for all clubs (clubdata_rsiena.RData).

```{r eval=FALSE}
# clean the working environment 
rm (list = ls( ))

# load the clubdata
load("clubs/clubdata.RData")
str(clubdata) # inspect structure
# clubdata is a list of 5 lists, 
# with each of these lists containing data of the corresponding club.

####################################################


clubdata_rsiena <- list()

for (i in 1:5) { 
  club <- clubdata[[i]]
  # specify the roles of variables
  names(club)
  
  # A: network variables
  kudonet <- sienaDependent(club$kudo) #at least one Kudo
  kudonet2 <- sienaDependent(club$kudo2) #>1 Kudos
  kudonet3 <- sienaDependent(club$kudo3) #>2 Kudos
  
  # B: behavioral variables
  time_run <- sienaDependent(club$time_run, type= "behavior")
  freq_run <- sienaDependent(club$freq_run, type= "behavior")
  
  time_other <- varCovar(club$time_other[,,])
  freq_other <- varCovar(club$freq_other[,,])

  # B: covariates
  friendship <- coDyadCovar(club$friendship)
  winter <- varCovar(club$winter)
  gender <- NA #we dichotomize gender as binary (men vs. women and other)
  gender <- ifelse(club$male == 1, 1, gender)
  gender <- ifelse(club$female == 1, 2, gender)
  gender <- ifelse(club$other == 1, 2, gender)
  gender <- coCovar(gender)
  exp <- coCovar(club$exp)
  
  # now combine the dependent and independent variables in a data object
  mydata <- sienaDataCreate(kudonet, friendship, time_run, freq_run, time_other, freq_other, 
                            gender, winter, exp)
  #mydata2 <- sienaDataCreate(kudonet, kudonet2, kudonet3, friendship, time_run, freq_run, 
  #                           time_other, freq_other, gender, winter, exp) #ordered network variable.

  #print01Report(mydata)

  # this finishes the data specification
  clubdata_rsiena[[i]] <- mydata 
} 

# add netsize
{
  clubdata_rsiena[[1]]$netsize <- clubdata[[1]]$netsize
  clubdata_rsiena[[2]]$netsize <- clubdata[[2]]$netsize
  clubdata_rsiena[[3]]$netsize <- clubdata[[3]]$netsize
  clubdata_rsiena[[4]]$netsize <- clubdata[[4]]$netsize
  clubdata_rsiena[[5]]$netsize <- clubdata[[5]]$netsize
}

# save the output
save(clubdata_rsiena, file="clubs/clubdata_rsiena.RData")

```

---  


# egodata.RData
 
In the following script we will do the same for our ego-centered data (egodata.RData). 
We make a list containing 1.5 degree ego-centered networks of all egos; and a list containing 2.5 degree ego-centered networks. 


```{r egos, eval=FALSE}
# Install required packages
library(RSiena)
library(dplyr)
library(stringr)
library(igraph)

#clean working directory
rm (list = ls( )) 

n_egos <- 11 #number of egonets to be included
user_str <- paste(toString("user"), c(1:n_egos), sep = "")

# the following script reads the data of the egos from the folder for each ego, stores them in a list, and saves it in an object in the last function call of this script. 
  for (i in (1: length(user_str))) {
    
    user_id <- user_str[i] 

    # read the data from the egonet  
    user_data <- read.csv(paste(user_str[i], "/", user_str[i], "egoData_extended.csv", sep = ""), row.names = NULL, sep=",")

    
    # we will read in the 1.5 degree and 2.5 degree ego-centered network data, respectively
    
  
    # 1.5 DEGREE
    friend_data <- read.csv(paste(user_id, "/", user_id,"_extended.csv", sep = ""), row.names = NULL, sep= ",")
    # remove the first column (represents index made in the csv)
    friend_data <- friend_data[, 2:ncol(friend_data)]
    # get edgelist
    e <- as.data.frame(igraph::get.edgelist(igraph::graph_from_adjacency_matrix(RSiena::coDyadCovar(data.matrix(friend_data)), mode = "directed", diag = FALSE)))
    colnames(e) <- c("i", "j")
    # identify level-1 alters: ego's friends
    e$alter <- ifelse(e$i == e$i[1], 1, 0) 
    # and construct a 1.5 degree friendship matrix
    friend_data1.5 <- friend_data[c(e$i[1], e$j[e$alter==1])][1:ncol(friend_data[c(e$i[1], e$j[e$alter==1])]), ]
    print(    friend_data1.5)
    user_data1.5 <- user_data[user_data$id == str_remove(colnames(friend_data1.5), "X"), ]

    # save netsize
    size1.5 <- length(user_data1.5[, 'gender'])
    # number of waves
    n_waves <- 11
    # separating male/female/other
    male1.5 <- ifelse(user_data1.5[,'gender'] == "M", 1, 0)
    female1.5 <- ifelse(user_data1.5[,'gender'] == "F", 1, 0)
    other1.5 <- ifelse(user_data1.5[,'gender'] == "O", 1, 0)

    # kudo network
    path <- paste(user_id, "/", user_id, "kudos", sep="") # create path
    {
      kudo_w1 <- as.matrix(read.csv(paste(path, "1-2019.csv", sep=""), row.names = NULL, sep= ","))
      kudo_w1 <- kudo_w1[,2:ncol(kudo_w1)]
      rownames(kudo_w1) <- colnames(kudo_w1)
      kudo_w1_1.5 <- kudo_w1[colnames(friend_data1.5), colnames(friend_data1.5)]
      rownames(kudo_w1_1.5) <- NULL
      
      kudo_w2 <- as.matrix(read.csv(paste(path, "2-2019.csv", sep=""), row.names = NULL, sep= ","))
      kudo_w2 <- kudo_w2[,2:ncol(kudo_w2)]
      rownames(kudo_w2) <- colnames(kudo_w2)
      kudo_w2_1.5 <- kudo_w2[colnames(friend_data1.5), colnames(friend_data1.5)]
      rownames(kudo_w2_1.5) <- NULL
      
      kudo_w3 <- as.matrix(read.csv(paste(path, "3-2019.csv", sep=""), row.names = NULL, sep= ","))
      kudo_w3 <- kudo_w3[,2:ncol(kudo_w3)]
      rownames(kudo_w3) <- colnames(kudo_w3)
      kudo_w3_1.5 <- kudo_w3[colnames(friend_data1.5), colnames(friend_data1.5)]
      rownames(kudo_w3_1.5) <- NULL
      
      kudo_w4 <- as.matrix(read.csv(paste(path, "4-2019.csv", sep=""), row.names = NULL, sep= ","))
      kudo_w4 <- kudo_w4[,2:ncol(kudo_w4)]
      rownames(kudo_w4) <- colnames(kudo_w4)
      kudo_w4_1.5 <- kudo_w4[colnames(friend_data1.5), colnames(friend_data1.5)]
      rownames(kudo_w4_1.5) <- NULL
      
      kudo_w5 <- as.matrix(read.csv(paste(path, "5-2019.csv", sep=""), row.names = NULL, sep= ","))
      kudo_w5 <- kudo_w5[,2:ncol(kudo_w5)]
      rownames(kudo_w5) <- colnames(kudo_w5)
      kudo_w5_1.5 <- kudo_w5[colnames(friend_data1.5), colnames(friend_data1.5)]
      rownames(kudo_w5_1.5) <- NULL
      
      kudo_w6 <- as.matrix(read.csv(paste(path, "6-2019.csv", sep=""), row.names = NULL, sep= ","))
      kudo_w6 <- kudo_w6[,2:ncol(kudo_w6)]
      rownames(kudo_w6) <- colnames(kudo_w6)
      kudo_w6_1.5 <- kudo_w6[colnames(friend_data1.5), colnames(friend_data1.5)]
      rownames(kudo_w6_1.5) <- NULL
      
      kudo_w7 <- as.matrix(read.csv(paste(path, "7-2019.csv", sep=""), row.names = NULL, sep= ","))
      kudo_w7 <- kudo_w7[,2:ncol(kudo_w7)]
      rownames(kudo_w7) <- colnames(kudo_w7)
      kudo_w7_1.5 <- kudo_w7[colnames(friend_data1.5), colnames(friend_data1.5)]
      rownames(kudo_w7_1.5) <- NULL
      
      kudo_w8 <- as.matrix(read.csv(paste(path, "8-2019.csv", sep=""), row.names = NULL, sep= ","))
      kudo_w8 <- kudo_w8[,2:ncol(kudo_w8)]
      rownames(kudo_w8) <- colnames(kudo_w8)
      kudo_w8_1.5 <- kudo_w8[colnames(friend_data1.5), colnames(friend_data1.5)]
      rownames(kudo_w8_1.5) <- NULL
      
      kudo_w9 <- as.matrix(read.csv(paste(path, "9-2019.csv", sep=""), row.names = NULL, sep= ","))
      kudo_w9 <- kudo_w9[,2:ncol(kudo_w9)]
      rownames(kudo_w9) <- colnames(kudo_w9)
      kudo_w9_1.5 <- kudo_w9[colnames(friend_data1.5), colnames(friend_data1.5)]
      rownames(kudo_w9_1.5) <- NULL
      
      kudo_w10 <- as.matrix(read.csv(paste(path, "10-2019.csv", sep=""), row.names = NULL, sep= ","))
      kudo_w10 <- kudo_w10[,2:ncol(kudo_w10)]
      rownames(kudo_w10) <- colnames(kudo_w10)
      kudo_w10_1.5 <- kudo_w10[colnames(friend_data1.5), colnames(friend_data1.5)]
      rownames(kudo_w10_1.5) <- NULL
      
      kudo_w11 <- as.matrix(read.csv(paste(path, "11-2019.csv", sep=""), row.names = NULL, sep= ","))
      kudo_w11 <- kudo_w11[,2:ncol(kudo_w11)]
      rownames(kudo_w11) <- colnames(kudo_w11)
      kudo_w11_1.5 <- kudo_w11[colnames(friend_data1.5), colnames(friend_data1.5)]
      rownames(kudo_w11_1.5) <- NULL
      
    }
    kudos1.5 <- array( c(kudo_w1_1.5,kudo_w2_1.5,kudo_w3_1.5,kudo_w4_1.5,kudo_w5_1.5,kudo_w6_1.5,kudo_w7_1.5,kudo_w8_1.5,kudo_w9_1.5,kudo_w10_1.5,kudo_w11_1.5),
                    dim = c( size1.5, size1.5, n_waves)) #Kudo matrix

    # we operationalize kudo-relationships in different ways: in an ordered fashion
    # rsiena will set constraints between the networks
    kudo_data_1.5 <- ifelse(kudos1.5 > 0, 1, 0) #if at least 1 Kudo is send, tie exists
    kudo_data2_1.5 <- ifelse(kudos1.5 > 1, 1, 0) #at least 2 Kudos
    kudo_data3_1.5 <- ifelse(kudos1.5 > 2, 1, 0) #at least 3 Kudos

    # running time
    time_run <- array( c( user_data1.5[, 'time_run_1.2019'], user_data1.5[, 'time_run_2.2019'], user_data1.5[, 'time_run_3.2019'], user_data1.5[, 'time_run_4.2019'], user_data1.5[, 'time_run_5.2019'], user_data1.5[, 'time_run_6.2019'], user_data1.5[, 'time_run_7.2019'], user_data1.5[, 'time_run_8.2019'], user_data1.5[, 'time_run_9.2019'], user_data1.5[, 'time_run_10.2019'], user_data1.5[, 'time_run_11.2019']),
                       dim = c( size1.5, 1, n_waves ) )
    # we cluster the time into 8 categories (from 0 to 8, with 0 being 0 minutes)
    # we will equally populate the categories 1-8 (cf. Flashman 2012)
    df <- data.frame(matrix(time_run))
    df$matrix.time_run. <- ifelse(df$matrix.time_run. == 0, NA, df$matrix.time_run.) #turn 0's to NA
    df <- dplyr::mutate(df, cat = dplyr::ntile(df$matrix.time_run., 8))
    df$cat <- ifelse(is.na(df$cat), 0, df$cat)
    time_run_temp1.5 <- array(df$cat, dim = c(size1.5, 1, n_waves))
    
    # running frequency
    freq_run <- array( c( user_data1.5[, 'X.run_1.2019'], user_data1.5[, 'X.run_2.2019'], user_data1.5[, 'X.run_3.2019'], user_data1.5[, 'X.run_4.2019'], user_data1.5[, 'X.run_5.2019'], user_data1.5[, 'X.run_6.2019'], user_data1.5[, 'X.run_7.2019'], user_data1.5[, 'X.run_8.2019'], user_data1.5[, 'X.run_9.2019'], user_data1.5[, 'X.run_10.2019'], user_data1.5[, 'X.run_11.2019']),
                       dim = c( size1.5, 1, n_waves ) )
    frequencies <- ceiling(freq_run/4)
    freq_run_temp1.5 <- ifelse(frequencies > 7, 8, frequencies) 
    
    # now that we have running data, let's load other activity data (e.g., cycling, swimming)
    # time
    time_ride <- array( c( user_data1.5[, 'time_ride_1.2019'], user_data1.5[, 'time_ride_2.2019'], user_data1.5[, 'time_ride_3.2019'], user_data1.5[, 'time_ride_4.2019'], user_data1.5[, 'time_ride_5.2019'], user_data1.5[, 'time_ride_6.2019'], user_data1.5[, 'time_ride_7.2019'], user_data1.5[, 'time_ride_8.2019'], user_data1.5[, 'time_ride_9.2019'], user_data1.5[, 'time_ride_10.2019'], user_data1.5[, 'time_ride_11.2019']),
                        dim = c( size1.5, 1, n_waves ) )
    time_other <- array( c( user_data1.5[, 'time_other_1.2019'], user_data1.5[, 'time_other_2.2019'], user_data1.5[, 'time_other_3.2019'], user_data1.5[, 'time_other_4.2019'], user_data1.5[, 'time_other_5.2019'], user_data1.5[, 'time_other_6.2019'], user_data1.5[, 'time_other_7.2019'], user_data1.5[, 'time_other_8.2019'], user_data1.5[, 'time_other_9.2019'], user_data1.5[, 'time_other_10.2019'], user_data1.5[, 'time_other_11.2019']),
                         dim = c( size1.5, 1, n_waves ) )
    
    time_other <- time_ride + time_other
    
    df <- data.frame(matrix(time_other))
    df$matrix.time_other. <- ifelse(df$matrix.time_other. == 0, NA, df$matrix.time_other.) #turn 0's to NA
    df <- dplyr::mutate(df, cat = dplyr::ntile(df$matrix.time_other., 8))
    df$cat <- ifelse(is.na(df$cat), 0, df$cat)
    time_other_temp1.5 <- array(df$cat, dim = c(size1.5, 1, n_waves))
    
    # frequency
    freq_ride <- array( c( user_data1.5[, 'X.ride_1.2019'], user_data1.5[, 'X.ride_2.2019'], user_data1.5[, 'X.ride_3.2019'], user_data1.5[, 'X.ride_4.2019'], user_data1.5[, 'X.ride_5.2019'], user_data1.5[, 'X.ride_6.2019'], user_data1.5[, 'X.ride_7.2019'], user_data1.5[, 'X.ride_8.2019'], user_data1.5[, 'X.ride_9.2019'], user_data1.5[, 'X.ride_10.2019'], user_data1.5[, 'X.ride_11.2019']),
                        dim = c( size1.5, 1, n_waves ) )
    freq_other <- array( c( user_data1.5[, 'X.other_1.2019'], user_data1.5[, 'X.other_2.2019'], user_data1.5[, 'X.other_3.2019'], user_data1.5[, 'X.other_4.2019'], user_data1.5[, 'X.other_5.2019'], user_data1.5[, 'X.other_6.2019'], user_data1.5[, 'X.other_7.2019'], user_data1.5[, 'X.other_8.2019'], user_data1.5[, 'X.other_9.2019'], user_data1.5[, 'X.other_10.2019'], user_data1.5[, 'X.other_11.2019']),
                         dim = c( size1.5, 1, n_waves ) )
  
    freq_other <- freq_ride + freq_other
    frequencies <- ceiling(freq_other/4)
    freq_other_temp1.5 <- ifelse(frequencies > 7, 8, frequencies)
    
    # specify months of winter in case we want to use it as a varying covariate
    # starts with december
    winter1.5 <- rep(c(1,1,1,0,0,0,0,0,0,0,0), size1.5)
    winter1.5 <- matrix(winter1.5,nrow = size1.5,ncol = n_waves, byrow = TRUE)
    
    # anonymize user IDs
    idmaker <- function(x)
    {
      max.val = x*100000
      count <- nchar(as.character(max.val))         
      size <- paste("%0",count,"d",sep="")           
      lets <- toupper(sample(letters,x, replace=T))   
      nums <- sprintf(size,sample(1:max.val)[1:x])    
      ids <- paste(lets,nums,sep="")                  
      return(ids)
    }
    fakeid <- idmaker(nrow(friend_data1.5)) 
    colnames(friend_data1.5) <- fakeid 
    
    # create list containing all 1.5 degree egonet data
    ego1.5 <- list("friendship" = friend_data1.5, 
                "kudo" = kudo_data_1.5, "kudo2" = kudo_data2_1.5, "kudo3" = kudo_data3_1.5,
                "freq_run" = freq_run_temp1.5, "time_run" = time_run_temp1.5, "freq_other" = freq_other_temp1.5, "time_other" = time_other_temp1.5, "winter" = winter1.5, "male" = male1.5, "female" = female1.5, "other" = other1.5, "netsize" = size1.5)
    
    # 2.5 DEGREE
    # save netsize
    size <- length(user_data[, 'gender'])
    # separating male/female/other
    male <- ifelse(user_data[,'gender'] == "M", 1, 0)
    female <- ifelse(user_data[,'gender'] == "F", 1, 0)
    other <- ifelse(user_data[,'gender'] == "O", 1, 0)
    
    # anonymize friendship data
    fakeid <- idmaker(nrow(friend_data))
    colnames(friend_data) <- fakeid
    
    # set structural zeros to non-existing ties with a distance >2 in their friendship ties
    G <- igraph::graph_from_adjacency_matrix(RSiena::coDyadCovar(data.matrix(friend_data)), mode = "directed",
                                     diag = FALSE)
    # distance matrix
    friend_distances <- distances(G, v = V(G), to = V(G), mode = "all", weights = NULL)
  
    # kudos
    kudos <- array( c(kudo_w1,kudo_w2,kudo_w3,kudo_w4,kudo_w5,kudo_w6,kudo_w7,kudo_w8,kudo_w9,kudo_w10,kudo_w11),
                    dim = c( size, size, n_waves))

    kudo_data <- ifelse(kudos > 0, 1, 0) #if at least 1 Kudo is send, tie exists
    #kudo_data2 <- ifelse(kudos > 1, 1, 0) #at least 2 Kudos
    #kudo_data3 <- ifelse(kudos > 2, 1, 0) #at least 3 Kudos
    
    # apply the structural zeros
    {
      temp_kudonet1 <- ifelse( (friend_distances > 2) & (kudo_data[,,1] == 0), 10, kudo_data[,,1] )
      temp_kudonet2 <- ifelse( (friend_distances > 2) & (kudo_data[,,2] == 0), 10, kudo_data[,,2] )
      temp_kudonet3 <- ifelse( (friend_distances > 2) & (kudo_data[,,3] == 0), 10, kudo_data[,,3] )
      temp_kudonet4 <- ifelse( (friend_distances > 2) & (kudo_data[,,4] == 0), 10, kudo_data[,,4] )
      temp_kudonet5 <- ifelse( (friend_distances > 2) & (kudo_data[,,5] == 0), 10, kudo_data[,,5] )
      temp_kudonet6 <- ifelse( (friend_distances > 2) & (kudo_data[,,6] == 0), 10, kudo_data[,,6] )
      temp_kudonet7 <- ifelse( (friend_distances > 2) & (kudo_data[,,7] == 0), 10, kudo_data[,,7] )
      temp_kudonet8 <- ifelse( (friend_distances > 2) & (kudo_data[,,8] == 0), 10, kudo_data[,,8] )
      temp_kudonet9 <- ifelse( (friend_distances > 2) & (kudo_data[,,9] == 0), 10, kudo_data[,,9] )
      temp_kudonet10 <- ifelse( (friend_distances > 2) & (kudo_data[,,10] == 0), 10, kudo_data[,,10] )
      temp_kudonet11 <- ifelse( (friend_distances > 2) & (kudo_data[,,11] == 0), 10, kudo_data[,,11] )
    }
    
    kudo_data <- array( c(temp_kudonet1,temp_kudonet2,temp_kudonet3, temp_kudonet4,temp_kudonet5,temp_kudonet6,temp_kudonet7,temp_kudonet8,temp_kudonet9,temp_kudonet10,temp_kudonet11),
                      dim = c( size, size, n_waves))
    
    # running time
    time_run <- array( c( user_data[, 'time_run_1.2019'], user_data[, 'time_run_2.2019'], user_data[, 'time_run_3.2019'], user_data[, 'time_run_4.2019'], user_data[, 'time_run_5.2019'], user_data[, 'time_run_6.2019'], user_data[, 'time_run_7.2019'], user_data[, 'time_run_8.2019'], user_data[, 'time_run_9.2019'], user_data[, 'time_run_10.2019'], user_data[, 'time_run_11.2019']),
                       dim = c( size, 1, n_waves ) )

    df <- data.frame(matrix(time_run))
    df$matrix.time_run. <- ifelse(df$matrix.time_run. == 0, NA, df$matrix.time_run.) #turn 0's to NA
    df <- dplyr::mutate(df, cat = dplyr::ntile(df$matrix.time_run., 8))
    df$cat <- ifelse(is.na(df$cat), 0, df$cat)
    time_run_temp <- array(df$cat, dim = c(size, 1, n_waves))
    
    # running frequency
    freq_run <- array( c( user_data[, 'X.run_1.2019'], user_data[, 'X.run_2.2019'], user_data[, 'X.run_3.2019'], user_data[, 'X.run_4.2019'], user_data[, 'X.run_5.2019'], user_data[, 'X.run_6.2019'], user_data[, 'X.run_7.2019'], user_data[, 'X.run_8.2019'], user_data[, 'X.run_9.2019'], user_data[, 'X.run_10.2019'], user_data[, 'X.run_11.2019']),
                       dim = c( size, 1, n_waves ) )
    frequencies <- ceiling(freq_run/4)
    freq_run_temp <- ifelse(frequencies > 7, 8, frequencies) 
    
    # other activity  (e.g., cycling, swimming)
    # 
    time_ride <- array( c( user_data[, 'time_ride_1.2019'], user_data[, 'time_ride_2.2019'], user_data[, 'time_ride_3.2019'], user_data[, 'time_ride_4.2019'], user_data[, 'time_ride_5.2019'], user_data[, 'time_ride_6.2019'], user_data[, 'time_ride_7.2019'], user_data[, 'time_ride_8.2019'], user_data[, 'time_ride_9.2019'], user_data[, 'time_ride_10.2019'], user_data[, 'time_ride_11.2019']),
                        dim = c( size, 1, n_waves ) )
    time_other <- array( c( user_data[, 'time_other_1.2019'], user_data[, 'time_other_2.2019'], user_data[, 'time_other_3.2019'], user_data[, 'time_other_4.2019'], user_data[, 'time_other_5.2019'], user_data[, 'time_other_6.2019'], user_data[, 'time_other_7.2019'], user_data[, 'time_other_8.2019'], user_data[, 'time_other_9.2019'], user_data[, 'time_other_10.2019'], user_data[, 'time_other_11.2019']),
                         dim = c( size, 1, n_waves ) )
    
    time_other <- time_ride + time_other
    
    df <- data.frame(matrix(time_other))
    df$matrix.time_other. <- ifelse(df$matrix.time_other. == 0, NA, df$matrix.time_other.) #turn 0's to NA
    df <- dplyr::mutate(df, cat = dplyr::ntile(df$matrix.time_other., 8))
    df$cat <- ifelse(is.na(df$cat), 0, df$cat)
    time_other_temp <- array(df$cat, dim = c(size, 1, n_waves))
    
    # frequency
    freq_ride <- array( c( user_data[, 'X.ride_1.2019'], user_data[, 'X.ride_2.2019'], user_data[, 'X.ride_3.2019'], user_data[, 'X.ride_4.2019'], user_data[, 'X.ride_5.2019'], user_data[, 'X.ride_6.2019'], user_data[, 'X.ride_7.2019'], user_data[, 'X.ride_8.2019'], user_data[, 'X.ride_9.2019'], user_data[, 'X.ride_10.2019'], user_data[, 'X.ride_11.2019']),
                        dim = c( size, 1, n_waves ) )
    freq_other <- array( c( user_data[, 'X.other_1.2019'], user_data[, 'X.other_2.2019'], user_data[, 'X.other_3.2019'], user_data[, 'X.other_4.2019'], user_data[, 'X.other_5.2019'], user_data[, 'X.other_6.2019'], user_data[, 'X.other_7.2019'], user_data[, 'X.other_8.2019'], user_data[, 'X.other_9.2019'], user_data[, 'X.other_10.2019'], user_data[, 'X.other_11.2019']),
                         dim = c( size, 1, n_waves ) )
    
    freq_other <- freq_ride + freq_other
    frequencies <- ceiling(freq_other/4)
    freq_other_temp <- ifelse(frequencies > 7, 8, frequencies)
    
    # winter
    winter <- rep(c(1,1,1,0,0,0,0,0,0,0,0), size)
    winter <- matrix(winter,nrow = size,ncol = n_waves, byrow = TRUE)
    
    ego2.5 <- list("friendship" = friend_data, 
                 "kudo" = kudo_data,
                 "freq_run" = freq_run_temp, "time_run" = time_run_temp, "freq_other" = freq_other_temp, "time_other" = time_other_temp, "winter" = winter, "male" = male, "female" = female, "other" = other, "netsize" = size)
    
    # save 
    save(ego1.5, file=paste("egonets", "/", "1.5degree/", "ego", i, ".RData", sep = ""))
    save(ego2.5, file=paste("egonets", "/", "2.5degree/", "ego", i, ".RData", sep = ""))
    
   
  }
####################################################

# Now that we have saved data of all egonets, let's combine them in one list

# load in the separate egonet objects:
# for 1.5 degree networks
{
  load("egonets/1.5degree/ego1.RData")
  ego1 <- ego1.5
  
  load("egonets/1.5degree/ego2.RData")
  ego2 <- ego1.5
  
  load("egonets/1.5degree/ego3.RData")
  ego3 <- ego1.5
  
  load("egonets/1.5degree/ego4.RData")
  ego4 <- ego1.5
  
  load("egonets/1.5degree/ego5.RData")
  ego5 <- ego1.5
  
  load("egonets/1.5degree/ego6.RData")
  ego6 <- ego1.5
  
  load("egonets/1.5degree/ego7.RData")
  ego7 <- ego1.5
  
  load("egonets/1.5degree/ego8.RData")
  ego8 <- ego1.5
  
  load("egonets/1.5degree/ego9.RData")
  ego9 <- ego1.5
  
  load("egonets/1.5degree/ego10.RData")
  ego10 <- ego1.5
  
  load("egonets/1.5degree/ego11.RData")
  ego11 <- ego1.5

}
# and make a list containing all the egodata
egodata1.5 <- list(ego1, ego2, ego3, ego4, ego5, ego6, ego7, ego8, ego9, ego10, ego11)

# and for 2.5 degree network
{
  load("egonets/2.5degree/ego1.RData")
  ego1 <- ego2.5
  
  load("egonets/2.5degree/ego2.RData")
  ego2 <- ego2.5
  
  load("egonets/2.5degree/ego3.RData")
  ego3 <- ego2.5
  
  load("egonets/2.5degree/ego4.RData")
  ego4 <- ego2.5
  
  load("egonets/2.5degree/ego5.RData")
  ego5 <- ego2.5
  
  load("egonets/2.5degree/ego6.RData")
  ego6 <- ego2.5
  
  load("egonets/2.5degree/ego7.RData")
  ego7 <- ego2.5
  
  load("egonets/2.5degree/ego8.RData")
  ego8 <- ego2.5
  
  load("egonets/2.5degree/ego9.RData")
  ego9 <- ego2.5
  
  load("egonets/2.5degree/ego10.RData")
  ego10 <- ego2.5
  
  load("egonets/2.5degree/ego11.RData")
  ego11 <- ego2.5
  
}
egodata2.5 <- list(ego1, ego2, ego3, ego4, ego5, ego6, ego7, ego8, ego9, ego10, ego11)

# save the output
save(egodata1.5, file="egonets/egodata1.5.RData")
save(egodata2.5, file="egonets/egodata2.5.RData")

``` 

---  

# egodata_rsiena.RData

And we create a list containing R-SIENA objects for all ego-centered networks, seperately for 1.5 and 2.5 degree networks. 

```{r eval=FALSE}
# clean the working environment 
rm (list = ls( ))

# load the clubdata
load("egonets/egodata1.5.RData")
load("egonets/egodata2.5.RData")

####################################################

egodata1.5_rsiena <- list()

for (i in 1:length(egodata1.5)) { 
  ego <- egodata1.5[[i]]
  # specify the roles of variables
  names(ego)
  
  # A: network variables
  kudonet <- sienaDependent(ego$kudo) #at least one Kudo
  kudonet2 <- sienaDependent(ego$kudo2) #>1 Kudos
  kudonet3 <- sienaDependent(ego$kudo3) #>2 Kudos
  
  # B: behavioral variables
  time_run <- sienaDependent(ego$time_run, type= "behavior")
  freq_run <- sienaDependent(ego$freq_run, type= "behavior")
  
  time_other <- varCovar(ego$time_other[,,])
  freq_other <- varCovar(ego$freq_other[,,])
  
  # B: covariates
  friendship <- coDyadCovar(as.matrix(ego$friendship))
  winter <- varCovar(ego$winter)
  gender <- NA 
  gender <- ifelse(ego$male == 1, 1, gender)
  gender <- ifelse(ego$female == 1, 2, gender)
  gender <- ifelse(ego$other == 1, 2, gender)
  gender <- coCovar(gender)
  
  # dataframe
  mydata <- sienaDataCreate(kudonet, kudonet2, kudonet3, friendship, time_run, freq_run, time_other, freq_other, 
                            gender, winter)

  # this finishes the data specification
  egodata1.5_rsiena[[i]] <- mydata 
} 


# add netsize
{
  egodata1.5_rsiena[[1]]$netsize <- egodata1.5[[1]]$netsize
  egodata1.5_rsiena[[2]]$netsize <- egodata1.5[[2]]$netsize
  egodata1.5_rsiena[[3]]$netsize <- egodata1.5[[3]]$netsize
  egodata1.5_rsiena[[4]]$netsize <- egodata1.5[[4]]$netsize
  egodata1.5_rsiena[[5]]$netsize <- egodata1.5[[5]]$netsize
}

# save the output
save(egodata1.5_rsiena, file="egonets/egodata1.5_rsiena.RData")

####################################################

egodata2.5_rsiena <- list()

for (i in 1:length(egodata2.5)) { 
  ego <- egodata2.5[[i]]
  # specify the roles of variables
  names(ego)
  
  # A: network variables
  kudonet <- sienaDependent(ego$kudo) #at least one Kudo
  #kudonet2 <- sienaDependent(ego$kudo2) #>1 Kudos
  #kudonet3 <- sienaDependent(ego$kudo3) #>2 Kudos
  
  # B: behavioral variables
  time_run <- sienaDependent(ego$time_run, type= "behavior")
  freq_run <- sienaDependent(ego$freq_run, type= "behavior")
  
  time_other <- varCovar(ego$time_other[,,])
  freq_other <- varCovar(ego$freq_other[,,])
  
  # B: covariates
  friendship <- coDyadCovar(as.matrix(ego$friendship))
  winter <- varCovar(ego$winter)
  gender <- NA 
  gender <- ifelse(ego$male == 1, 1, gender)
  gender <- ifelse(ego$female == 1, 2, gender)
  gender <- ifelse(ego$other == 1, 2, gender)
  gender <- coCovar(gender)
  
  # dataframe
  mydata <- sienaDataCreate(kudonet, kudonet2, kudonet3, friendship, time_run, freq_run, time_other, freq_other, 
                            gender, winter)
  
  # this finishes the data specification
  egodata2.5_rsiena[[i]] <- mydata 
} 

# add netsize
{
  egodata2.5_rsiena[[1]]$netsize <- egodata2.5[[1]]$netsize
  egodata2.5_rsiena[[2]]$netsize <- egodata2.5[[2]]$netsize
  egodata2.5_rsiena[[3]]$netsize <- egodata2.5[[3]]$netsize
  egodata2.5_rsiena[[4]]$netsize <- egodata2.5[[4]]$netsize
  egodata2.5_rsiena[[5]]$netsize <- egodata2.5[[5]]$netsize
}

# save the output
save(egodata2.5_rsiena, file="egonets/egodata2.5_rsiena.RData")

```

<!--- 

#RF I added to the clubdata.RData the behavior-based 'ranking' variable for creating the interaction average alter effect and alter-level behavior.

# I have to update the clubdata_rsiena.RData and the ego preps accordingly.

Also, in the clubdata.RData I altered some stuff, e.g., removing experience, and capping frequency with a maximum of 7 times per week. 

---> 



---

## References
