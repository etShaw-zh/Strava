---
title: "Data preparation"
bibliography: references.bib
date: "Last compiled on `r format(Sys.time(), '%B, %Y')`"
output: 
  html_document:
    css: tweaks.css
    toc:  true
    toc_float: true
    number_sections: false
    toc_depth: 1
    code_folding: show
    code_download: yes
---

```{r, globalsettings, echo=FALSE, warning=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
opts_chunk$set(tidy.opts=list(width.cutoff=100),tidy=TRUE, warning = FALSE, message = FALSE,comment = "#>", cache=TRUE, class.source=c("test"), class.output=c("test2"))
options(width = 100)
rgl::setupKnitr()


colorize <- function(x, color) {sprintf("<span style='color: %s;'>%s</span>", color, x) }
```


```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(position = c('top', 'right'))
#klippy::klippy(color = 'darkred')
#klippy::klippy(tooltip_message = 'Click to copy', tooltip_success = 'Done')
```


---  



# clubdata.RData

In the following scripts a list containing the (anonymized) data of all clubs is made (clubdata.RData).

* Our primary network variable is the Kudo-network. We argue that Kudos are an indication of the 'strength' of friendships. We construct and ordered Kudo-network variable, i.e., a network in which awarding/receiving **more than 1** Kudo constitutes the presence of a (directed) tie, is a sub-network of the network in which awarding/receiving **at least 1 Kudo** counts as a tie. Thus, the Kudo-network with numeric tie values (i.e., number of Kudos awarded/received) is represented as a multivariate network, in which it is impossible that a tie exists in the second-order but not in the first-order network, as suggested by @rsienamanual, section 5.6.


* For the behavioral data we include information on the *frequency* (i.e., in times per week) and *volume* (i.e., in minutes per month) of running activities. We included activity (frequency and volume) in other sports (e.g., cycling and swimming) as a time-varying covariate. We categorized these continuous behavioral variables following recommendations in the literature: chapter 6 of @niezink and page 27 of @rsienamanual.

  + For *frequency*, I chose 9 categories, ranging from 0-7 times per week, and a 9th category, since in some clubs a substantial proportion of club members ran more frequently than once a day.

  + For *volume*, I chose 9 categories, with category 0 indicating 0 minutes spent on training, and categories 1-8 being equally populated (as in @flashman). Note that this results in different categorizations for each club. 


```{r clubs, eval=FALSE}
# first, install the required packages.
library(RSiena)
library(dplyr)


# clean the working environment 
rm (list = ls( ))

# club string represents the club ID
club_str <- c("clubid1", "clubid2", "clubid3", "clubid4" ,"clubid5") 

# the following script reads the data of the clubs from the folder for each club, stores them in a list, and saves it in an object in the last function call of this script. 


for (i in (1: length(club_str))) {
  club_id <- club_str[i] 

  # read the data from the club    
  clubdata <- read.csv(paste("clubs/", club_id, "/", "egoData_extended.csv", sep = ""), row.names = NULL, sep= ",")
  # saving club size
  size <- length(clubdata[, 'gender'])
  # the number of months that we want to add as waves
  n_waves <- 12
  # separating male/female/other
  male <- ifelse(clubdata[,'gender'] == "M", 1, 0)
  female <- ifelse(clubdata[,'gender'] == "F", 1, 0)
  other <- ifelse(clubdata[,'gender'] == "O", 1, 0)
  
  # in case we want to condition on the first activity recorded by users:
  # experience variable: higher values indicate longer since first activity.
  st_yr <- clubdata[,'start_date_year']
  novice <-  ifelse(clubdata[,'start_date_year'] <= 2011, 9, st_yr)
  novice <-  ifelse(clubdata[,'start_date_year'] == 2012, 8, novice)
  novice <-  ifelse(clubdata[,'start_date_year'] == 2013, 7, novice)
  novice <-  ifelse(clubdata[,'start_date_year'] == 2014, 6, novice)
  novice <-  ifelse(clubdata[,'start_date_year'] == 2015, 5, novice)
  novice <-  ifelse(clubdata[,'start_date_year'] == 2016, 4, novice)
  novice <-  ifelse(clubdata[,'start_date_year'] == 2017, 3, novice)
  novice <-  ifelse(clubdata[,'start_date_year'] == 2018, 2, novice)
  novice <-  ifelse(clubdata[,'start_date_year'] == 2019, 1, novice)
  
  
  # let's load the friendship network
  friend_data <- as.matrix(read.csv(paste("clubs/", club_id, "/", "socialnetwork.csv", sep = ""), row.names = NULL, sep= ","))
  # remove the first column (represents index made in the csv)
  friend_data <- friend_data[, 2:ncol(friend_data)]
  # and anonymize the user id, with an id-maker function
  idmaker <- function(x)
  {
    max.val = x*100000
    count <- nchar(as.character(max.val))           # find out how many 'numbers' each id will have after the letter
    size <- paste("%0",count,"d",sep="")            # set the variable to be fed into 'sprintf' to ensure we have leading 0's
    lets <- toupper(sample(letters,x, replace=T))   # randomizing the letters 
    nums <- sprintf(size,sample(1:max.val)[1:x])    # randomizing the numbers, and ensuring they all have the same number of characters
    ids <- paste(lets,nums,sep="")                  # joining them together
    return(ids)
  }
  fakeid <- idmaker(nrow(friend_data)) # generate random id
  colnames(friend_data) <- fakeid # anonymizing users
  
  # the following line makes a friendship network of reciprocal ties.
  friend_recip <- matrix(NA, nrow = nrow(friend_data), ncol = ncol(friend_data))
  for(row in 1:nrow(friend_data)) {
    for(col in 1:ncol(friend_data)) {
      value <- friend_data[row,col] * friend_data[col,row]
      friend_recip[row,col] <- value
      friend_recip[col,row] <- value
    }
  }
  
  # let's load the kudo network
  path <- paste("clubs/", club_id, "/", "kudos", sep="") # create path
  {
    kudo_w1 <- as.matrix(read.csv(paste(path, "1-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w1 <- kudo_w1[,2:ncol(kudo_w1)]
    kudo_w2 <- as.matrix(read.csv(paste(path, "2-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w2 <- kudo_w2[,2:ncol(kudo_w2)]
    kudo_w3 <- as.matrix(read.csv(paste(path, "3-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w3 <- kudo_w3[,2:ncol(kudo_w3)]
    kudo_w4 <- as.matrix(read.csv(paste(path, "4-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w4 <- kudo_w4[,2:ncol(kudo_w4)]
    kudo_w5 <- as.matrix(read.csv(paste(path, "5-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w5 <- kudo_w5[,2:ncol(kudo_w5)]
    kudo_w6 <- as.matrix(read.csv(paste(path, "6-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w6 <- kudo_w6[,2:ncol(kudo_w6)]
    kudo_w7 <- as.matrix(read.csv(paste(path, "7-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w7 <- kudo_w7[,2:ncol(kudo_w7)]
    kudo_w8 <- as.matrix(read.csv(paste(path, "8-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w8 <- kudo_w8[,2:ncol(kudo_w8)]
    kudo_w9 <- as.matrix(read.csv(paste(path, "9-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w9 <- kudo_w9[,2:ncol(kudo_w9)]
    kudo_w10 <- as.matrix(read.csv(paste(path, "10-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w10 <- kudo_w10[,2:ncol(kudo_w10)]
    kudo_w11 <- as.matrix(read.csv(paste(path, "11-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w11 <- kudo_w11[,2:ncol(kudo_w11)]
    kudo_w12 <- as.matrix(read.csv(paste(path, "12-2019.csv", sep=""), row.names = NULL, sep= ","))
    kudo_w12 <- kudo_w12[,2:ncol(kudo_w12)]
  }
  kudos <- array( c(kudo_w1,kudo_w2,kudo_w3,kudo_w4,kudo_w5,kudo_w6,kudo_w7,kudo_w8,kudo_w9,kudo_w10,kudo_w11,kudo_w12),
                  dim = c( size, size, n_waves)) #Kudo matrix
  
  # we operationalize kudo-relationships in different ways: in an ordered fashion
  # rsiena will set constraints between the networks
  kudo_data <- ifelse(kudos > 0, 1, 0) #if at least 1 Kudo is send, tie exists
  kudo_data2 <- ifelse(kudos > 1, 1, 0) #at least 2 Kudos
  kudo_data3 <- ifelse(kudos > 2, 1, 0) #at least 3 Kudos
  #for now, these order cut-offs were quite arbitrarily chosen; can be extended, or be applied with other categories.
  
  # running time
  time_run <- array( c( clubdata[, 'time_run_1.2019'], clubdata[, 'time_run_2.2019'], clubdata[, 'time_run_3.2019'], clubdata[, 'time_run_4.2019'], clubdata[, 'time_run_5.2019'], clubdata[, 'time_run_6.2019'], clubdata[, 'time_run_7.2019'], clubdata[, 'time_run_8.2019'], clubdata[, 'time_run_9.2019'], clubdata[, 'time_run_10.2019'], clubdata[, 'time_run_11.2019'], clubdata[, 'time_run_12.2019']),
                     dim = c( size, 1, n_waves ) )
  
  # we cluster the time into 8 categories (from 0 to 8, with 0 being 0 minutes)
  # we will equally populate the categories 1-8 (cf. Flashman 2012)
  df <- data.frame(matrix(time_run))
  df$matrix.time_run. <- ifelse(df$matrix.time_run. == 0, NA, df$matrix.time_run.) #turn 0's to NA
  df <- mutate(df, cat = ntile(df$matrix.time_run., 8))
  df$cat <- ifelse(is.na(df$cat), 0, df$cat)
  time_run_temp <- array(df$cat, dim = c(size, 1, n_waves))
  
  # running frequency
  freq_run <- array( c( clubdata[, 'X.run_1.2019'], clubdata[, 'X.run_2.2019'], clubdata[, 'X.run_3.2019'], clubdata[, 'X.run_4.2019'], clubdata[, 'X.run_5.2019'], clubdata[, 'X.run_6.2019'], clubdata[, 'X.run_7.2019'], clubdata[, 'X.run_8.2019'], clubdata[, 'X.run_9.2019'], clubdata[, 'X.run_10.2019'], clubdata[, 'X.run_11.2019'], clubdata[, 'X.run_12.2019']),
                     dim = c( size, 1, n_waves ) )
  frequencies <- ceiling(freq_run/4)
  freq_run_temp <- ifelse(frequencies > 7, 8, frequencies) 
  
  # now that we have running data, let's load other activity data (e.g., cycling, swimming)
  # time
  time_ride <- array( c( clubdata[, 'time_ride_1.2019'], clubdata[, 'time_ride_2.2019'], clubdata[, 'time_ride_3.2019'], clubdata[, 'time_ride_4.2019'], clubdata[, 'time_ride_5.2019'], clubdata[, 'time_ride_6.2019'], clubdata[, 'time_ride_7.2019'], clubdata[, 'time_ride_8.2019'], clubdata[, 'time_ride_9.2019'], clubdata[, 'time_ride_10.2019'], clubdata[, 'time_ride_11.2019'], clubdata[, 'time_ride_12.2019']),
                      dim = c( size, 1, n_waves ) )
  time_other <- array( c( clubdata[, 'time_other_1.2019'], clubdata[, 'time_other_2.2019'], clubdata[, 'time_other_3.2019'], clubdata[, 'time_other_4.2019'], clubdata[, 'time_other_5.2019'], clubdata[, 'time_other_6.2019'], clubdata[, 'time_other_7.2019'], clubdata[, 'time_other_8.2019'], clubdata[, 'time_other_9.2019'], clubdata[, 'time_other_10.2019'], clubdata[, 'time_other_11.2019'], clubdata[, 'time_other_12.2019']),
                       dim = c( size, 1, n_waves ) )
  
  time_other <- time_ride + time_other
  
  df <- data.frame(matrix(time_other))
  df$matrix.time_other. <- ifelse(df$matrix.time_other. == 0, NA, df$matrix.time_other.) #turn 0's to NA
  df <- mutate(df, cat = ntile(df$matrix.time_other., 8))
  df$cat <- ifelse(is.na(df$cat), 0, df$cat)
  time_other_temp <- array(df$cat, dim = c(size, 1, n_waves))
  
  # frequency
  freq_ride <- array( c( clubdata[, 'X.ride_1.2019'], clubdata[, 'X.ride_2.2019'], clubdata[, 'X.ride_3.2019'], clubdata[, 'X.ride_4.2019'], clubdata[, 'X.ride_5.2019'], clubdata[, 'X.ride_6.2019'], clubdata[, 'X.ride_7.2019'], clubdata[, 'X.ride_8.2019'], clubdata[, 'X.ride_9.2019'], clubdata[, 'X.ride_10.2019'], clubdata[, 'X.ride_11.2019'], clubdata[, 'X.ride_12.2019']),
                      dim = c( size, 1, n_waves ) )
  freq_other <- array( c( clubdata[, 'X.other_1.2019'], clubdata[, 'X.other_2.2019'], clubdata[, 'X.other_3.2019'], clubdata[, 'X.other_4.2019'], clubdata[, 'X.other_5.2019'], clubdata[, 'X.other_6.2019'], clubdata[, 'X.other_7.2019'], clubdata[, 'X.other_8.2019'], clubdata[, 'X.other_9.2019'], clubdata[, 'X.other_10.2019'], clubdata[, 'X.other_11.2019'], clubdata[, 'X.other_12.2019']),
                       dim = c( size, 1, n_waves ) )
  
  freq_other <- freq_ride + freq_other
  frequencies <- ceiling(freq_other/4)
  freq_other_temp <- ifelse(frequencies > 7, 8, frequencies)
  
  # specify months of winter in case we want to use it as a varying covariate
  # starts with december
  winter <- rep(c(1,1,1,0,0,0,0,0,0,0,0,0), size)
  winter <- matrix(winter,nrow = size,ncol = n_waves, byrow = TRUE)
  
  # create a list containing all the read club data for the current club
  club <- list("friendship" = friend_data, 
               "kudo" = kudo_data, "kudo2" = kudo_data2, "kudo3" = kudo_data3,
               "freq_run" = freq_run_temp, "time_run" = time_run_temp, "freq_other" = freq_other_temp, "time_other" = time_other_temp, "winter" = winter, "male" = male, "female" = female, "other" = other, "netsize" = size, "exp" = novice)
  


  # save 
  save(club, file=paste("clubs/", "club", i, ".RData", sep = ""))

}

####################################################

# Now that we have saved the clubdata for all clubs, let's combine them in one list

# first clean the working directory
rm (list = ls( ))

# load in the separate club-objects
{
  load("clubs/club1.RData")
  club1 <- club
  
  club2 <- load("clubs/club2.RData")
  club2 <- club
  
  club3 <- load("clubs/club3.RData")
  club3 <- club
  
  club4 <- load("clubs/club4.RData")
  club4 <- club
  
  club5 <- load("clubs/club5.RData")
  club5 <- club
}
# and make a list containing all the clubdata
clubdata <- list(club1, club2, club3, club4, club5)

# save the output
save(clubdata, file="clubs/clubdata.RData")


``` 

---  

# clubdata_rsiena.RData

The following script creates a list containing R-SIENA objects for all clubs (clubdata_rsiena.RData).

```{r eval=FALSE}
# install RSiena
library(RSiena)

# clean the working environment 
rm (list = ls( ))

# load the clubdata
load("clubs/clubdata.RData")
str(clubdata) # inspect structure
# clubdata is a list of 5 lists, 
# with each of these lists containing data of the corresponding club.

# the following script will make a RSiena object.
# again, we start with the first club.
# the script can be re-run after pulling from the list the data of another club (and so forth...)
# eventually, we will combine the output into a list containing the RSiena objects of all the clubs.

####################################################


clubdata_rsiena <- list()

for (i in 1:5) { 
  club <- clubdata[[1]]
  # specify the roles of variables
  names(club)
  
  # A: network variables
  kudonet <- sienaDependent(club$kudo) #at least one Kudo
  kudonet2 <- sienaDependent(club$kudo2) #>1 Kudos
  kudonet3 <- sienaDependent(club$kudo3) #>2 Kudos
  
  # B: behavioral variables
  time_run <- sienaDependent(club$time_run, type= "behavior")
  freq_run <- sienaDependent(club$freq_run, type= "behavior")
  
  time_other <- varCovar(club$time_other[,,])
  freq_other <- varCovar(club$freq_other[,,])

  # B: covariates
  friendship <- coDyadCovar(club$friendship)
  winter <- varCovar(club$winter)
  gender <- NA #we dichotomize gender as binary (men vs. women and other)
  gender <- ifelse(club$male == 1, 1, gender)
  gender <- ifelse(club$female == 1, 2, gender)
  gender <- ifelse(club$other == 1, 2, gender)
  gender <- coCovar(gender)
  exp <- coCovar(club$exp)
  
  # now combine the dependent and independent variables in a data object
  mydata <- sienaDataCreate(kudonet, friendship, time_run, freq_run, time_other, freq_other, 
                            gender, winter, exp)
  #mydata2 <- sienaDataCreate(kudonet, kudonet2, kudonet3, friendship, time_run, freq_run, 
  #                           time_other, freq_other, gender, winter, exp) #ordered network variable.

  #print01Report(mydata)

  # this finishes the data specification
  clubdata_rsiena[[i]] <- mydata 
} 

# add netsize
{
  clubdata_rsiena[[1]]$netsize <- clubdata[[1]]$netsize
  clubdata_rsiena[[2]]$netsize <- clubdata[[2]]$netsize
  clubdata_rsiena[[3]]$netsize <- clubdata[[3]]$netsize
  clubdata_rsiena[[4]]$netsize <- clubdata[[4]]$netsize
  clubdata_rsiena[[5]]$netsize <- clubdata[[5]]$netsize
}

# save the output
save(clubdata_rsiena, file="clubs/clubdata_rsiena.RData")

```

---  


# egodata.RData
 
In the following script we will do the same for our ego-centered data (egodata.RData). Note that we set non-existing (Kudo) ties between actors *i* and *j* with a distance >2 in their friendship ties to *structural zeros*. 


---  

# egodata_rsiena.RData

And create a list containing R-SIENA objects for all ego-centered networks (egodata_rsiena.RData).

---

## References
